OBJECT Codeunit 22 Item Jnl.-Post Line
{
  OBJECT-PROPERTIES
  {
    Date=20171006D;
    Time=120000T;
    Version List=NAVW111.0;
  }
  PROPERTIES
  {
    TableNo="Item Journal Line";
    Permissions=TableData Item=imd,
                TableData "Item Ledger Entry"=imd,
                TableData "Item Register"=imd,
                TableData "Phys. Inventory Ledger Entry"=imd,
                TableData "Item Application Entry"=imd,
                TableData "Prod. Order Capacity Need"=imd,
                TableData "Stockkeeping Unit"=imd,
                TableData "Value Entry"=imd,
                TableData "Avg. Cost Adjmt. Entry Point"=rim,
                TableData "Post Value Entry to G/L"=ri,
                TableData "Capacity Ledger Entry"=imd,
                TableData "Inventory Adjmt. Entry (Order)"=rim;
    OnRun=BEGIN
            GetGLSetup;
            RunWithCheck(Rec);
          END;

  }
  CODE
  {
    VAR
      Text000@1063 : TextConst 'ENU=cannot be less than zero';
      Text001@1071 : TextConst 'ENU=Item Tracking is signed wrongly.';
      Text003@1000 : TextConst 'ENU=Reserved item %1 is not on inventory.';
      Text004@1001 : TextConst 'ENU=is too low';
      Text011@1003 : TextConst 'ENU=Tracking Specification is missing.';
      Text012@1007 : TextConst 'ENU=Item %1 must be reserved.';
      Text014@1009 : TextConst 'ENU=Serial No. %1 is already on inventory.';
      SerialNoRequiredErr@1010 : TextConst '@@@=%1 - Item No.;ENU=You must assign a serial number for item %1.';
      LotNoRequiredErr@1011 : TextConst '@@@=%1 - Item No.;ENU=You must assign a lot number for item %1.';
      LineNoTxt@1090 : TextConst '@@@=%1 - Line No.;ENU=" Line No. = ''%1''."';
      Text017@1012 : TextConst 'ENU=" is before the posting date."';
      Text018@1013 : TextConst 'ENU=Item Tracking Serial No. %1 Lot No. %2 for Item No. %3 Variant %4 cannot be fully applied.';
      Text021@1044 : TextConst 'ENU=You must not define item tracking on %1 %2.';
      Text022@1064 : TextConst 'ENU=You cannot apply %1 to %2 on the same item %3 on Production Order %4.';
      Text100@1006 : TextConst 'ENU=Fatal error when retrieving Tracking Specification.';
      Text99000000@1014 : TextConst 'ENU=must not be filled out when reservations exist';
      GLSetup@1028 : Record "General Ledger Setup";
      Currency@1027 : Record Currency;
      InvtSetup@1017 : Record "Inventory Setup";
      MfgSetup@1070 : Record "Manufacturing Setup";
      Location@1076 : Record Location;
      NewLocation@1082 : Record Location;
      Item@1016 : Record Item;
      GlobalItemLedgEntry@1018 : Record "Item Ledger Entry";
      OldItemLedgEntry@1019 : Record "Item Ledger Entry";
      ItemReg@1020 : Record "Item Register";
      ItemJnlLine@1021 : Record "Item Journal Line";
      ItemJnlLineOrigin@1072 : Record "Item Journal Line";
      SourceCodeSetup@1022 : Record "Source Code Setup";
      GenPostingSetup@1023 : Record "General Posting Setup";
      ItemApplnEntry@1024 : Record "Item Application Entry";
      GlobalValueEntry@1025 : Record "Value Entry";
      DirCostValueEntry@1079 : Record "Value Entry";
      SKU@1026 : Record "Stockkeeping Unit";
      CurrExchRate@1029 : Record "Currency Exchange Rate";
      ItemTrackingCode@1032 : Record "Item Tracking Code";
      TempSplitItemJnlLine@1035 : TEMPORARY Record "Item Journal Line";
      TempTrackingSpecification@1034 : TEMPORARY Record "Tracking Specification";
      TempValueEntryRelation@1033 : TEMPORARY Record "Value Entry Relation";
      TempItemEntryRelation@1030 : TEMPORARY Record "Item Entry Relation";
      WhseJnlLine@1074 : Record "Warehouse Journal Line";
      TouchedItemLedgerEntries@1065 : TEMPORARY Record "Item Ledger Entry";
      TempItemApplnEntryHistory@1095 : TEMPORARY Record "Item Application Entry History";
      PrevAppliedItemLedgEntry@1002 : Record "Item Ledger Entry";
      WMSMgmt@1073 : Codeunit "WMS Management";
      WhseJnlRegisterLine@1075 : Codeunit "Whse. Jnl.-Register Line";
      ItemJnlCheckLine@1037 : Codeunit "Item Jnl.-Check Line";
      ReservEngineMgt@1038 : Codeunit "Reservation Engine Mgt.";
      ReserveItemJnlLine@1039 : Codeunit "Item Jnl. Line-Reserve";
      ReserveProdOrderComp@1066 : Codeunit "Prod. Order Comp.-Reserve";
      ReserveProdOrderLine@1004 : Codeunit "Prod. Order Line-Reserve";
      JobPlanningLineReserve@1036 : Codeunit "Job Planning Line-Reserve";
      ItemTrackingMgt@1041 : Codeunit "Item Tracking Management";
      InvtPost@1042 : Codeunit "Inventory Posting To G/L";
      CostCalcMgt@1068 : Codeunit "Cost Calculation Management";
      ACYMgt@1005 : Codeunit "Additional-Currency Management";
      ItemLedgEntryNo@1043 : Integer;
      PhysInvtEntryNo@1045 : Integer;
      CapLedgEntryNo@1060 : Integer;
      ValueEntryNo@1046 : Integer;
      ItemApplnEntryNo@1077 : Integer;
      TotalAppliedQty@1048 : Decimal;
      OverheadAmount@1049 : Decimal;
      VarianceAmount@1050 : Decimal;
      OverheadAmountACY@1051 : Decimal;
      VarianceAmountACY@1052 : Decimal;
      QtyPerUnitOfMeasure@1084 : Decimal;
      RoundingResidualAmount@1096 : Decimal;
      RoundingResidualAmountACY@1097 : Decimal;
      InvtSetupRead@1053 : Boolean;
      GLSetupRead@1054 : Boolean;
      MfgSetupRead@1069 : Boolean;
      SKUExists@1055 : Boolean;
      AverageTransfer@1056 : Boolean;
      SNRequired@1057 : Boolean;
      LotRequired@1058 : Boolean;
      PostponeReservationHandling@1059 : Boolean;
      VarianceRequired@1031 : Boolean;
      LastOperation@1062 : Boolean;
      DisableItemTracking@1015 : Boolean;
      CalledFromInvtPutawayPick@1080 : Boolean;
      CalledFromAdjustment@1078 : Boolean;
      PostToGL@1008 : Boolean;
      ProdOrderCompModified@1083 : Boolean;
      Text023@1061 : TextConst 'ENU=Entries applied to an Outbound Transfer cannot be unapplied.';
      Text024@1047 : TextConst 'ENU=Entries applied to a Drop Shipment Order cannot be unapplied.';
      Text025@1085 : TextConst 'ENU=Entries applied to a Correction entry cannot be unapplied.';
      IsServUndoConsumption@1088 : Boolean;
      Text027@1086 : TextConst 'ENU=A fixed application was not unapplied and this prevented the reapplication. Use the Application Worksheet to remove the applications.';
      Text01@1087 : TextConst 'ENU=Checking for open entries.';
      BlockRetrieveIT@1067 : Boolean;
      Text029@1091 : TextConst 'ENU=%1 %2 for %3 %4 is reserved for %5.';
      Text030@1092 : TextConst 'ENU=The quantity that you are trying to invoice is larger than the quantity in the item ledger with the entry number %1.';
      Text031@1093 : TextConst '@@@="%2 = Lot No. %3 = Serial No. Both are tracking numbers.";ENU=You cannot invoice the item %1 with item tracking number %2 %3 in this purchase order before the associated sales order %4 has been invoiced.';
      Text032@1094 : TextConst 'ENU=You cannot invoice item %1 in this purchase order before the associated sales order %2 has been invoiced.';
      Text033@1040 : TextConst 'ENU=Quantity must be -1, 0 or 1 when Serial No. is stated.';
      SkipApplicationCheck@1089 : Boolean;
      CalledFromApplicationWorksheet@1098 : Boolean;

    [External]
    PROCEDURE RunWithCheck@13(VAR ItemJnlLine2@1000 : Record "Item Journal Line") : Boolean;
    VAR
      TrackingSpecExists@1001 : Boolean;
    BEGIN
      PrepareItem(ItemJnlLine2);
      TrackingSpecExists := ItemTrackingMgt.RetrieveItemTracking(ItemJnlLine2,TempTrackingSpecification);
      exit(PostSplitJnlLine(ItemJnlLine2,TrackingSpecExists));
    END;

    [Internal]
    PROCEDURE RunPostWithReservation@128(VAR ItemJnlLine2@1000 : Record "Item Journal Line";VAR ReservationEntry@1001 : Record "Reservation Entry") : Boolean;
    VAR
      TrackingSpecExists@1002 : Boolean;
    BEGIN
      PrepareItem(ItemJnlLine2);

      ReservationEntry.RESET;
      TrackingSpecExists :=
        ItemTrackingMgt.RetrieveItemTrackingFromReservEntry(ItemJnlLine2,ReservationEntry,TempTrackingSpecification);

      exit(PostSplitJnlLine(ItemJnlLine2,TrackingSpecExists));
    END;

    LOCAL PROCEDURE Code@3();
    BEGIN
      OnBeforePostItemJnlLine(ItemJnlLine);

      with ItemJnlLine do begin
        if EmptyLine and not Correction and not Adjustment then
          if not IsValueEntryForDeletedItem then
            exit;

        ItemJnlCheckLine.SetCalledFromInvtPutawayPick(CalledFromInvtPutawayPick);
        ItemJnlCheckLine.SetCalledFromAdjustment(CalledFromAdjustment);

        ItemJnlCheckLine.RunCheck(ItemJnlLine);

        if "Document Date" = 0D then
          "Document Date" := "Posting Date";

        if ItemLedgEntryNo = 0 then begin
          GlobalItemLedgEntry.LOCKTABLE;
          if GlobalItemLedgEntry.FINDLAST then
            ItemLedgEntryNo := GlobalItemLedgEntry."Entry No.";
        end;
        InitValueEntryNo;

        GetInvtSetup;
        if not CalledFromAdjustment then
          PostToGL := InvtSetup."Automatic Cost Posting";

        if (SNRequired or LotRequired) and ("Quantity (Base)" <> 0) and
           ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and
           not DisableItemTracking and not Adjustment and
           not Subcontracting and not IsAssemblyResourceConsumpLine
        then
          CheckItemTracking;

        if Correction then
          UndoQuantityPosting;

        if ("Entry Type" in
            ["Entry Type"::Consumption,"Entry Type"::Output,"Entry Type"::"Assembly Consumption","Entry Type"::"Assembly Output"]) and
           not ("Value Entry Type" = "Value Entry Type"::Revaluation) and
           not OnlyStopTime
        then begin
          case "Entry Type" of
            "Entry Type"::"Assembly Consumption","Entry Type"::"Assembly Output":
              TESTFIELD("Order Type","Order Type"::Assembly);
            "Entry Type"::Consumption,"Entry Type"::Output:
              TESTFIELD("Order Type","Order Type"::Production);
          end;
          TESTFIELD("Order No.");
          if IsAssemblyOutputLine then
            TESTFIELD("Order Line No.",0)
          else
            TESTFIELD("Order Line No.");
        end;

        if ("Gen. Bus. Posting Group" <> GenPostingSetup."Gen. Bus. Posting Group") or
           ("Gen. Prod. Posting Group" <> GenPostingSetup."Gen. Prod. Posting Group")
        then
          GenPostingSetup.GET("Gen. Bus. Posting Group","Gen. Prod. Posting Group");

        if "Qty. per Unit of Measure" = 0 then
          "Qty. per Unit of Measure" := 1;
        if "Qty. per Cap. Unit of Measure" = 0 then
          "Qty. per Cap. Unit of Measure" := 1;

        Quantity := "Quantity (Base)";
        "Invoiced Quantity" := "Invoiced Qty. (Base)";
        "Setup Time" := "Setup Time (Base)";
        "Run Time" := "Run Time (Base)";
        "Stop Time" := "Stop Time (Base)";
        "Output Quantity" := "Output Quantity (Base)";
        "Scrap Quantity" := "Scrap Quantity (Base)";

        if not Subcontracting and
           (("Entry Type" = "Entry Type"::Output) or
            IsAssemblyResourceConsumpLine)
        then
          QtyPerUnitOfMeasure := "Qty. per Cap. Unit of Measure"
        else
          QtyPerUnitOfMeasure := "Qty. per Unit of Measure";

        RoundingResidualAmount := 0;
        RoundingResidualAmountACY := 0;
        if "Value Entry Type" = "Value Entry Type"::Revaluation then
          if Item.GET("Item No.") and (Item."Costing Method" = Item."Costing Method"::Average) then begin
            RoundingResidualAmount := Quantity *
              ("Unit Cost" - ROUND("Unit Cost" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision"));
            RoundingResidualAmountACY := Quantity *
              ("Unit Cost (ACY)" - ROUND("Unit Cost (ACY)" / QtyPerUnitOfMeasure,Currency."Unit-Amount Rounding Precision"));
            if ABS(RoundingResidualAmount) < GLSetup."Amount Rounding Precision" then
              RoundingResidualAmount := 0;
            if ABS(RoundingResidualAmountACY) < Currency."Amount Rounding Precision" then
              RoundingResidualAmountACY := 0;
          end;

        "Unit Amount" := ROUND(
            "Unit Amount" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
        "Unit Cost" := ROUND(
            "Unit Cost" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
        "Unit Cost (ACY)" := ROUND(
            "Unit Cost (ACY)" / QtyPerUnitOfMeasure,Currency."Unit-Amount Rounding Precision");

        OverheadAmount := 0;
        VarianceAmount := 0;
        OverheadAmountACY := 0;
        VarianceAmountACY := 0;
        VarianceRequired := false;
        LastOperation := false;

        case true of
          IsAssemblyResourceConsumpLine:
            PostAssemblyResourceConsump;
          Adjustment,
          "Value Entry Type" in ["Value Entry Type"::Rounding,"Value Entry Type"::Revaluation],
          "Entry Type" = "Entry Type"::"Assembly Consumption",
          "Entry Type" = "Entry Type"::"Assembly Output":
            PostItem;
          "Entry Type" = "Entry Type"::Consumption:
            PostConsumption;
          "Entry Type" = "Entry Type"::Output:
            PostOutput;
          not Correction:
            PostItem;
        end;

        // Entry no. is returned to shipment/receipt
        if Subcontracting then
          "Item Shpt. Entry No." := CapLedgEntryNo
        else
          "Item Shpt. Entry No." := GlobalItemLedgEntry."Entry No.";
      end;

      OnAfterPostItemJnlLine(ItemJnlLine);
    END;

    LOCAL PROCEDURE PostSplitJnlLine@131(VAR ItemJnlLineToPost@1000 : Record "Item Journal Line";TrackingSpecExists@1001 : Boolean) : Boolean;
    VAR
      PostItemJnlLine@1002 : Boolean;
    BEGIN
      PostItemJnlLine := SetupSplitJnlLine(ItemJnlLineToPost,TrackingSpecExists);
      if not PostItemJnlLine then
        PostItemJnlLine := IsNotInternalWhseMovement(ItemJnlLineToPost);

      while SplitJnlLine(ItemJnlLine,PostItemJnlLine) do
        if PostItemJnlLine then
          Code;
      CLEAR(PrevAppliedItemLedgEntry);
      ItemJnlLineToPost := ItemJnlLine;
      CorrectOutputValuationDate(GlobalItemLedgEntry);
      RedoApplications;

      exit(PostItemJnlLine);
    END;

    LOCAL PROCEDURE PostConsumption@29();
    VAR
      ProdOrderComp@1003 : Record "Prod. Order Component";
      TempHandlingSpecification@1000 : TEMPORARY Record "Tracking Specification";
      RemQtyToPost@1004 : Decimal;
      RemQtyToPostThisLine@1001 : Decimal;
      QtyToPost@1005 : Decimal;
      UseItemTrackingApplication@1007 : Boolean;
      LastLoop@1006 : Boolean;
      EndLoop@1002 : Boolean;
      NewRemainingQty@1008 : Decimal;
    BEGIN
      with ProdOrderComp do begin
        ItemJnlLine.TESTFIELD("Order Type",ItemJnlLine."Order Type"::Production);
        SETCURRENTKEY(Status,"Prod. Order No.","Prod. Order Line No.","Item No.","Line No.");
        SETRANGE(Status,Status::Released);
        SETRANGE("Prod. Order No.",ItemJnlLine."Order No.");
        SETRANGE("Prod. Order Line No.",ItemJnlLine."Order Line No.");
        SETRANGE("Item No.",ItemJnlLine."Item No.");
        if ItemJnlLine."Prod. Order Comp. Line No." <> 0 then
          SETRANGE("Line No.",ItemJnlLine."Prod. Order Comp. Line No.");
        LOCKTABLE;

        RemQtyToPost := ItemJnlLine.Quantity;

        if FINDSET then begin
          if ItemJnlLine.TrackingExists and not BlockRetrieveIT then
            UseItemTrackingApplication :=
              ItemTrackingMgt.RetrieveConsumpItemTracking(ItemJnlLine,TempHandlingSpecification);

          if UseItemTrackingApplication then begin
            TempHandlingSpecification.SetTrackingFilter(ItemJnlLine."Serial No.",ItemJnlLine."Lot No.");
            LastLoop := false;
          end else
            if ReservationExists(ItemJnlLine) then begin
              if SNRequired and (ItemJnlLine."Serial No." = '') then
                ERROR(SerialNoRequiredErr,ItemJnlLine."Item No.");
              if LotRequired and (ItemJnlLine."Lot No." = '') then
                ERROR(LotNoRequiredErr,ItemJnlLine."Item No.");
            end;

          repeat
            if UseItemTrackingApplication then begin
              TempHandlingSpecification.SETRANGE("Source Ref. No.","Line No.");
              if LastLoop then begin
                RemQtyToPostThisLine := "Remaining Qty. (Base)";
                if TempHandlingSpecification.FINDSET then
                  repeat
                    CheckItemTrackingOfComp(TempHandlingSpecification,ItemJnlLine);
                    RemQtyToPostThisLine += TempHandlingSpecification."Qty. to Handle (Base)";
                  until TempHandlingSpecification.NEXT = 0;
                if RemQtyToPostThisLine * RemQtyToPost < 0 then
                  ERROR(Text001); // Assertion: Test signing
              end else begin
                if TempHandlingSpecification.FINDFIRST then begin
                  RemQtyToPostThisLine := -TempHandlingSpecification."Qty. to Handle (Base)";
                  TempHandlingSpecification.DELETE;
                end else begin
                  TempHandlingSpecification.ClearTrackingFilter;
                  TempHandlingSpecification.FINDFIRST;
                  CheckItemTrackingOfComp(TempHandlingSpecification,ItemJnlLine);
                  RemQtyToPostThisLine := 0;
                end;
              end;
              if RemQtyToPostThisLine > RemQtyToPost then
                RemQtyToPostThisLine := RemQtyToPost;
            end else begin
              RemQtyToPostThisLine := RemQtyToPost;
              LastLoop := true;
            end;

            QtyToPost := RemQtyToPostThisLine;
            CALCFIELDS("Act. Consumption (Qty)");
            NewRemainingQty := "Expected Qty. (Base)" - "Act. Consumption (Qty)" - QtyToPost;
            NewRemainingQty := ROUND(NewRemainingQty,0.00001);
            if (NewRemainingQty * "Expected Qty. (Base)") <= 0 then begin
              QtyToPost := "Remaining Qty. (Base)";
              "Remaining Qty. (Base)" := 0;
            end else begin
              if ("Remaining Qty. (Base)" * "Expected Qty. (Base)") >= 0 then
                QtyToPost := "Remaining Qty. (Base)" - NewRemainingQty
              else
                QtyToPost := NewRemainingQty;
              "Remaining Qty. (Base)" := NewRemainingQty;
            end;

            "Remaining Quantity" := ROUND("Remaining Qty. (Base)" / "Qty. per Unit of Measure",0.00001);

            if QtyToPost <> 0 then begin
              RemQtyToPost := RemQtyToPost - QtyToPost;
              MODIFY;
              if ProdOrderCompModified then
                InsertConsumpEntry(ProdOrderComp,"Line No.",QtyToPost,false)
              else
                InsertConsumpEntry(ProdOrderComp,"Line No.",QtyToPost,true);
            end;

            if UseItemTrackingApplication then begin
              if NEXT = 0 then begin
                EndLoop := LastLoop;
                LastLoop := true;
                FINDFIRST;
                TempHandlingSpecification.RESET;
              end;
            end else
              EndLoop := NEXT = 0;

          until EndLoop or (RemQtyToPost = 0);
        end;

        if RemQtyToPost <> 0 then
          InsertConsumpEntry(ProdOrderComp,ItemJnlLine."Prod. Order Comp. Line No.",RemQtyToPost,false);
      end;
      ProdOrderCompModified := false;
    END;

    LOCAL PROCEDURE PostOutput@25();
    VAR
      MfgItem@1012 : Record Item;
      MfgSKU@1003 : Record "Stockkeeping Unit";
      MachCenter@1008 : Record "Machine Center";
      WorkCenter@1004 : Record "Work Center";
      CapLedgEntry@1000 : Record "Capacity Ledger Entry";
      ProdOrder@1007 : Record "Production Order";
      ProdOrderLine@1006 : Record "Prod. Order Line";
      ProdOrderRtngLine@1005 : Record "Prod. Order Routing Line";
      ItemLedgerEntry@1013 : Record "Item Ledger Entry";
      DirCostAmt@1002 : Decimal;
      IndirCostAmt@1001 : Decimal;
      ValuedQty@1011 : Decimal;
      MfgUnitCost@1010 : Decimal;
      ReTrack@1009 : Boolean;
    BEGIN
      with ItemJnlLine do begin
        if "Stop Time" <> 0 then begin
          InsertCapLedgEntry(CapLedgEntry,"Stop Time","Stop Time");
          if OnlyStopTime then
            exit;
        end;

        if OutputValuePosting then begin
          PostItem;
          exit;
        end;

        if Subcontracting then
          ValuedQty := "Invoiced Quantity"
        else
          ValuedQty := CalcCapQty;

        if Item.GET("Item No.") then
          if not CalledFromAdjustment then
            Item.TESTFIELD("Inventory Value Zero",false);

        if "Item Shpt. Entry No." <> 0 then
          CapLedgEntry.GET("Item Shpt. Entry No.")
        else begin
          TESTFIELD("Order Type","Order Type"::Production);
          ProdOrder.GET(ProdOrder.Status::Released,"Order No.");
          ProdOrder.TESTFIELD(Blocked,false);
          ProdOrderLine.LOCKTABLE;
          ProdOrderLine.GET(ProdOrder.Status::Released,"Order No.","Order Line No.");

          "Inventory Posting Group" := ProdOrderLine."Inventory Posting Group";

          ProdOrderRtngLine.SETRANGE(Status,ProdOrderRtngLine.Status::Released);
          ProdOrderRtngLine.SETRANGE("Prod. Order No.","Order No.");
          ProdOrderRtngLine.SETRANGE("Routing Reference No.","Routing Reference No.");
          ProdOrderRtngLine.SETRANGE("Routing No.","Routing No.");
          if ProdOrderRtngLine.FINDFIRST then begin
            TESTFIELD("Operation No.");
            TESTFIELD("No.");

            if Type = Type::"Machine Center" then begin
              MachCenter.GET("No.");
              MachCenter.TESTFIELD(Blocked,false);
            end;
            WorkCenter.GET("Work Center No.");
            WorkCenter.TESTFIELD(Blocked,false);

            ApplyCapNeed("Setup Time (Base)","Run Time (Base)");
          end;

          if "Operation No." <> '' then begin
            ProdOrderRtngLine.GET(
              ProdOrderRtngLine.Status::Released,"Order No.",
              "Routing Reference No.","Routing No.","Operation No.");
            if Finished then
              ProdOrderRtngLine."Routing Status" := ProdOrderRtngLine."Routing Status"::Finished
            else
              ProdOrderRtngLine."Routing Status" := ProdOrderRtngLine."Routing Status"::"In Progress";
            LastOperation := (not NextOperationExist(ProdOrderRtngLine));
            ProdOrderRtngLine.MODIFY;
          end else
            LastOperation := true;

          if Subcontracting then
            InsertCapLedgEntry(CapLedgEntry,Quantity,"Invoiced Quantity")
          else
            InsertCapLedgEntry(CapLedgEntry,ValuedQty,ValuedQty);

          if "Output Quantity" >= 0 then
            FlushOperation(ProdOrder,ProdOrderLine);
        end;

        CalcDirAndIndirCostAmts(DirCostAmt,IndirCostAmt,ValuedQty,"Unit Cost","Indirect Cost %","Overhead Rate");

        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Direct Cost",ValuedQty,ValuedQty,DirCostAmt);
        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Indirect Cost",ValuedQty,0,IndirCostAmt);

        if LastOperation and ("Output Quantity" <> 0) then begin
          CheckItemTracking;
          if ("Output Quantity" < 0) and not Adjustment then begin
            TESTFIELD("Applies-to Entry");
            ItemLedgerEntry.GET("Applies-to Entry");
            TESTFIELD("Lot No.",ItemLedgerEntry."Lot No.");
            TESTFIELD("Serial No.",ItemLedgerEntry."Serial No.");
          end;
          MfgItem.GET(ProdOrderLine."Item No.");
          MfgItem.TESTFIELD("Gen. Prod. Posting Group");

          if not Subcontracting then begin
            if MfgSKU.GET(ProdOrderLine."Location Code",ProdOrderLine."Item No.",ProdOrderLine."Variant Code") then
              MfgUnitCost := MfgSKU."Unit Cost"
            else
              MfgUnitCost := MfgItem."Unit Cost";
            Amount := "Output Quantity" * MfgUnitCost;
          end;

          "Amount (ACY)" := ACYMgt.CalcACYAmt(Amount,"Posting Date",false);
          "Gen. Bus. Posting Group" := ProdOrder."Gen. Bus. Posting Group";
          "Gen. Prod. Posting Group" := MfgItem."Gen. Prod. Posting Group";
          if "Output Quantity (Base)" * ProdOrderLine."Remaining Qty. (Base)" <= 0 then
            ReTrack := true
          else
            if not CalledFromInvtPutawayPick then
              ReserveProdOrderLine.TransferPOLineToItemJnlLine(
                ProdOrderLine,ItemJnlLine,"Output Quantity (Base)");

          GetLocation("Location Code");
          if Location."Bin Mandatory" and (not CalledFromInvtPutawayPick) then begin
            WMSMgmt.CreateWhseJnlLineFromOutputJnl(ItemJnlLine,WhseJnlLine);
            WMSMgmt.CheckWhseJnlLine(WhseJnlLine,2,0,false);
          end;

          Description := ProdOrderLine.Description;
          if Subcontracting then begin
            "Document Type" := "Document Type"::" ";
            "Document No." := "Order No.";
            "Document Line No." := 0;
            "Invoiced Quantity" := 0;
          end;
          PostItem;
          UpdateProdOrderLine(ProdOrderLine,ReTrack);
          if Location."Bin Mandatory" and (not CalledFromInvtPutawayPick) then
            WhseJnlRegisterLine.RegisterWhseJnlLine(WhseJnlLine);
        end;
      end;
    END;

    LOCAL PROCEDURE PostItem@28();
    BEGIN
      with ItemJnlLine do begin
        SKUExists := SKU.GET("Location Code","Item No.","Variant Code");
        if "Item Shpt. Entry No." <> 0 then begin
          "Location Code" := '';
          "Variant Code" := '';
        end;

        if Item.GET("Item No.") then begin
          if not CalledFromAdjustment then
            Item.TESTFIELD(Blocked,false);
          Item.CheckBlockedByApplWorksheet;
        end;

        if ("Inventory Posting Group" = '') and (Item.Type = Item.Type::Inventory) then begin
          Item.TESTFIELD("Inventory Posting Group");
          "Inventory Posting Group" := Item."Inventory Posting Group";
        end;

        if ("Entry Type" = "Entry Type"::Transfer) and
           (Item."Costing Method" = Item."Costing Method"::Average) and
           ("Applies-to Entry" = 0)
        then begin
          AverageTransfer := true;
          TotalAppliedQty := 0;
        end else
          AverageTransfer := false;

        if "Job Contract Entry No." <> 0 then
          TransReserveFromJobPlanningLine("Job Contract Entry No.",ItemJnlLine);

        if Item."Costing Method" = Item."Costing Method"::Standard then begin
          "Overhead Rate" := Item."Overhead Rate";
          "Indirect Cost %" := Item."Indirect Cost %";
        end;

        if ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") or
           ("Item Charge No." <> '')
        then begin
          "Overhead Rate" := 0;
          "Indirect Cost %" := 0;
        end;

        if (Quantity <> 0) and
           ("Item Charge No." = '') and
           not ("Value Entry Type" in ["Value Entry Type"::Revaluation,"Value Entry Type"::Rounding]) and
           not Adjustment
        then
          ItemQtyPosting
        else begin
          if ("Invoiced Quantity" <> 0) or Adjustment or
             IsInterimRevaluation
          then begin
            if "Value Entry Type" = "Value Entry Type"::"Direct Cost" then
              GlobalItemLedgEntry.GET("Item Shpt. Entry No.")
            else
              GlobalItemLedgEntry.GET("Applies-to Entry");
            CorrectOutputValuationDate(GlobalItemLedgEntry);
            InitValueEntry(GlobalValueEntry,GlobalItemLedgEntry);
          end;
        end;
        if (Quantity <> 0) or ("Invoiced Quantity" <> 0) then
          ItemValuePosting;

        UpdateUnitCost(GlobalValueEntry);
      end;
    END;

    LOCAL PROCEDURE InsertConsumpEntry@31(VAR ProdOrderComp@1005 : Record "Prod. Order Component";ProdOrderCompLineNo@1004 : Integer;QtyBase@1003 : Decimal;ModifyProdOrderComp@1000 : Boolean);
    VAR
      PostWhseJnlLine@1001 : Boolean;
    BEGIN
      with ItemJnlLine do begin
        Quantity := QtyBase;
        "Quantity (Base)" := QtyBase;
        "Invoiced Quantity" := QtyBase;
        "Invoiced Qty. (Base)" := QtyBase;
        "Prod. Order Comp. Line No." := ProdOrderCompLineNo;
        if ModifyProdOrderComp then begin
          if not CalledFromInvtPutawayPick then
            ReserveProdOrderComp.TransferPOCompToItemJnlLine(ProdOrderComp,ItemJnlLine,QtyBase);
          ProdOrderComp.MODIFY;
        end;

        if "Value Entry Type" <> "Value Entry Type"::Revaluation then begin
          GetLocation("Location Code");
          if Location."Bin Mandatory" and (not CalledFromInvtPutawayPick) then begin
            WMSMgmt.CreateWhseJnlLineFromConsumJnl(ItemJnlLine,WhseJnlLine);
            WMSMgmt.CheckWhseJnlLine(WhseJnlLine,3,0,false);
            PostWhseJnlLine := true;
          end;
        end;
      end;

      PostItem;
      if PostWhseJnlLine then
        WhseJnlRegisterLine.RegisterWhseJnlLine(WhseJnlLine);
    END;

    LOCAL PROCEDURE CalcCapQty@30() CapQty@1000 : Decimal;
    BEGIN
      GetMfgSetup;

      with ItemJnlLine do begin
        if "Unit Cost Calculation" = "Unit Cost Calculation"::Time then begin
          if MfgSetup."Cost Incl. Setup" then
            CapQty := "Setup Time" + "Run Time"
          else
            CapQty := "Run Time";
        end else
          CapQty := Quantity + "Scrap Quantity";
      end;
    END;

    LOCAL PROCEDURE CalcDirAndIndirCostAmts@26(VAR DirCostAmt@1000 : Decimal;VAR IndirCostAmt@1001 : Decimal;CapQty@1005 : Decimal;UnitCost@1002 : Decimal;IndirCostPct@1003 : Decimal;OvhdRate@1004 : Decimal);
    VAR
      CostAmt@1006 : Decimal;
    BEGIN
      CostAmt := ROUND(CapQty * UnitCost);
      DirCostAmt := ROUND((CostAmt - CapQty * OvhdRate) / (1 + IndirCostPct / 100));
      IndirCostAmt := CostAmt - DirCostAmt;
    END;

    LOCAL PROCEDURE ApplyCapNeed@27(PostedSetupTime@1000 : Decimal;PostedRunTime@1003 : Decimal);
    VAR
      ProdOrderCapNeed@1001 : Record "Prod. Order Capacity Need";
      Qty@1002 : Decimal;
    BEGIN
      with ItemJnlLine do begin
        ProdOrderCapNeed.LOCKTABLE;
        ProdOrderCapNeed.RESET;
        ProdOrderCapNeed.SETCURRENTKEY(
          Status,"Prod. Order No.","Routing Reference No.","Operation No.",Date,"Starting Time");
        ProdOrderCapNeed.SETRANGE(Status,ProdOrderCapNeed.Status::Released);
        ProdOrderCapNeed.SETRANGE("Prod. Order No.","Order No.");
        ProdOrderCapNeed.SETRANGE("Requested Only",false);
        ProdOrderCapNeed.SETRANGE("Routing No.","Routing No.");
        ProdOrderCapNeed.SETRANGE("Routing Reference No.","Routing Reference No.");
        ProdOrderCapNeed.SETRANGE("Operation No.","Operation No.");

        if Finished then
          ProdOrderCapNeed.MODIFYALL("Allocated Time",0)
        else begin
          if PostedSetupTime <> 0 then begin
            ProdOrderCapNeed.SETRANGE("Time Type",ProdOrderCapNeed."Time Type"::Setup);
            if ProdOrderCapNeed.FINDSET then
              repeat
                if ProdOrderCapNeed."Allocated Time" > PostedSetupTime then
                  Qty := PostedSetupTime
                else
                  Qty := ProdOrderCapNeed."Allocated Time";
                ProdOrderCapNeed."Allocated Time" :=
                  ProdOrderCapNeed."Allocated Time" - Qty;
                ProdOrderCapNeed.MODIFY;
                PostedSetupTime := PostedSetupTime - Qty;
              until (ProdOrderCapNeed.NEXT = 0) or (PostedSetupTime = 0);
          end;

          if PostedRunTime <> 0 then begin
            ProdOrderCapNeed.SETRANGE("Time Type",ProdOrderCapNeed."Time Type"::Run);
            if ProdOrderCapNeed.FINDSET then
              repeat
                if ProdOrderCapNeed."Allocated Time" > PostedRunTime then
                  Qty := PostedRunTime
                else
                  Qty := ProdOrderCapNeed."Allocated Time";
                ProdOrderCapNeed."Allocated Time" :=
                  ProdOrderCapNeed."Allocated Time" - Qty;
                ProdOrderCapNeed.MODIFY;
                PostedRunTime := PostedRunTime - Qty;
              until (ProdOrderCapNeed.NEXT = 0) or (PostedRunTime = 0);
          end;
        end;
      end;
    END;

    LOCAL PROCEDURE UpdateProdOrderLine@38(VAR ProdOrderLine@1000 : Record "Prod. Order Line";ReTrack@1005 : Boolean);
    VAR
      ReservMgt@1002 : Codeunit "Reservation Management";
    BEGIN
      with ProdOrderLine do begin
        if ItemJnlLine."Output Quantity (Base)" > "Remaining Qty. (Base)" then
          ReserveProdOrderLine.AssignForPlanning(ProdOrderLine);
        "Finished Qty. (Base)" := "Finished Qty. (Base)" + ItemJnlLine."Output Quantity (Base)";
        "Finished Quantity" := "Finished Qty. (Base)" / "Qty. per Unit of Measure";
        if "Finished Qty. (Base)" < 0 then
          FIELDERROR("Finished Quantity",Text000);
        "Remaining Qty. (Base)" := "Quantity (Base)" - "Finished Qty. (Base)";
        if "Remaining Qty. (Base)" < 0 then
          "Remaining Qty. (Base)" := 0;
        "Remaining Quantity" := "Remaining Qty. (Base)" / "Qty. per Unit of Measure";
        MODIFY;

        if ReTrack then begin
          ReservMgt.SetProdOrderLine(ProdOrderLine);
          ReservMgt.ClearSurplus;
          ReservMgt.AutoTrack("Remaining Qty. (Base)");
        end;
      end;
    END;

    LOCAL PROCEDURE InsertCapLedgEntry@23(VAR CapLedgEntry@1000 : Record "Capacity Ledger Entry";Qty@1001 : Decimal;InvdQty@1002 : Decimal);
    BEGIN
      with ItemJnlLine do begin
        if CapLedgEntryNo = 0 then begin
          CapLedgEntry.LOCKTABLE;
          if CapLedgEntry.FINDLAST then
            CapLedgEntryNo := CapLedgEntry."Entry No.";
        end;

        CapLedgEntryNo := CapLedgEntryNo + 1;

        CapLedgEntry.INIT;
        CapLedgEntry."Entry No." := CapLedgEntryNo;

        CapLedgEntry."Operation No." := "Operation No.";
        CapLedgEntry.Type := Type;
        CapLedgEntry."No." := "No.";
        CapLedgEntry.Description := Description;
        CapLedgEntry."Work Center No." := "Work Center No.";
        CapLedgEntry."Work Center Group Code" := "Work Center Group Code";
        CapLedgEntry.Subcontracting := Subcontracting;

        CapLedgEntry.Quantity := Qty;
        CapLedgEntry."Invoiced Quantity" := InvdQty;
        CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry.Quantity;

        CapLedgEntry."Setup Time" := "Setup Time";
        CapLedgEntry."Run Time" := "Run Time";
        CapLedgEntry."Stop Time" := "Stop Time";

        if "Unit Cost Calculation" = "Unit Cost Calculation"::Time then begin
          CapLedgEntry."Cap. Unit of Measure Code" := "Cap. Unit of Measure Code";
          CapLedgEntry."Qty. per Cap. Unit of Measure" := "Qty. per Cap. Unit of Measure";
        end;

        CapLedgEntry."Item No." := "Item No.";
        CapLedgEntry."Variant Code" := "Variant Code";
        CapLedgEntry."Output Quantity" := "Output Quantity";
        CapLedgEntry."Scrap Quantity" := "Scrap Quantity";
        CapLedgEntry."Unit of Measure Code" := "Unit of Measure Code";
        CapLedgEntry."Qty. per Unit of Measure" := "Qty. per Unit of Measure";

        CapLedgEntry."Order Type" := "Order Type";
        CapLedgEntry."Order No." := "Order No.";
        CapLedgEntry."Order Line No." := "Order Line No.";
        CapLedgEntry."Routing No." := "Routing No.";
        CapLedgEntry."Routing Reference No." := "Routing Reference No.";
        CapLedgEntry."Operation No." := "Operation No.";

        CapLedgEntry."Posting Date" := "Posting Date";
        CapLedgEntry."Document Date" := "Document Date";
        CapLedgEntry."Document No." := "Document No.";
        CapLedgEntry."External Document No." := "External Document No.";

        CapLedgEntry."Starting Time" := "Starting Time";
        CapLedgEntry."Ending Time" := "Ending Time";
        CapLedgEntry."Concurrent Capacity" := "Concurrent Capacity";
        CapLedgEntry."Work Shift Code" := "Work Shift Code";

        CapLedgEntry."Stop Code" := "Stop Code";
        CapLedgEntry."Scrap Code" := "Scrap Code";
        CapLedgEntry."Last Output Line" := LastOperation;

        CapLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        CapLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        CapLedgEntry."Dimension Set ID" := "Dimension Set ID";

        OnBeforeInsertCapLedgEntry(CapLedgEntry,ItemJnlLine);

        CapLedgEntry.INSERT;

        OnAfterInsertCapLedgEntry(CapLedgEntry,ItemJnlLine);

        InsertItemReg(0,0,0,CapLedgEntry."Entry No.");
      end;
    END;

    LOCAL PROCEDURE InsertCapValueEntry@24(VAR CapLedgEntry@1001 : Record "Capacity Ledger Entry";ValueEntryType@1003 : Option;ValuedQty@1005 : Decimal;InvdQty@1004 : Decimal;AdjdCost@1002 : Decimal);
    VAR
      ValueEntry@1000 : Record "Value Entry";
    BEGIN
      with ItemJnlLine do begin
        if (InvdQty = 0) and (AdjdCost = 0) then
          exit;

        ValueEntryNo := ValueEntryNo + 1;

        ValueEntry.INIT;
        ValueEntry."Entry No." := ValueEntryNo;
        ValueEntry."Capacity Ledger Entry No." := CapLedgEntry."Entry No.";
        ValueEntry."Entry Type" := ValueEntryType;
        ValueEntry."Item Ledger Entry Type" := ValueEntry."Item Ledger Entry Type"::" ";

        ValueEntry.Type := Type;
        ValueEntry."No." := "No.";
        ValueEntry.Description := Description;
        ValueEntry."Order Type" := "Order Type";
        ValueEntry."Order No." := "Order No.";
        ValueEntry."Order Line No." := "Order Line No.";
        ValueEntry."Source Type" := "Source Type";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        ValueEntry."Invoiced Quantity" := InvdQty;
        ValueEntry."Valued Quantity" := ValuedQty;

        ValueEntry."Cost Amount (Actual)" := AdjdCost;
        ValueEntry."Cost Amount (Actual) (ACY)" := ACYMgt.CalcACYAmt(AdjdCost,"Posting Date",false);
        ValueEntry."Cost per Unit" :=
          CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",false);
        ValueEntry."Cost per Unit (ACY)" :=
          CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",true);
        ValueEntry.Inventoriable := true;

        if Type = Type::Resource then
          TESTFIELD("Inventory Posting Group",'')
        else
          TESTFIELD("Inventory Posting Group");
        ValueEntry."Inventory Posting Group" := "Inventory Posting Group";
        ValueEntry."Gen. Bus. Posting Group" := "Gen. Bus. Posting Group";
        ValueEntry."Gen. Prod. Posting Group" := "Gen. Prod. Posting Group";

        ValueEntry."Posting Date" := "Posting Date";
        ValueEntry."Valuation Date" := "Posting Date";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        ValueEntry."Document Type" := "Document Type";
        if ValueEntry."Expected Cost" or ("Invoice No." = '') then
          ValueEntry."Document No." := "Document No."
        else begin
          ValueEntry."Document No." := "Invoice No.";
          if "Document Type" in
             ["Document Type"::"Purchase Receipt","Document Type"::"Purchase Return Shipment",
              "Document Type"::"Sales Shipment","Document Type"::"Sales Return Receipt",
              "Document Type"::"Service Shipment"]
          then
            ValueEntry."Document Type" := "Document Type" + 1;
        end;
        ValueEntry."Document Line No." := "Document Line No.";
        ValueEntry."Document Date" := "Document Date";
        ValueEntry."External Document No." := "External Document No.";
        ValueEntry."User ID" := USERID;
        ValueEntry."Source Code" := "Source Code";
        ValueEntry."Reason Code" := "Reason Code";
        ValueEntry."Journal Batch Name" := "Journal Batch Name";

        ValueEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        ValueEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        ValueEntry."Dimension Set ID" := "Dimension Set ID";

        OnBeforeInsertCapValueEntry(ValueEntry,ItemJnlLine);

        InvtPost.SetRunOnlyCheck(true,not InvtSetup."Automatic Cost Posting",false);
        if InvtPost.BufferInvtPosting(ValueEntry) then
          InvtPost.PostInvtPostBufPerEntry(ValueEntry);

        ValueEntry.INSERT(true);

        OnAfterInsertCapValueEntry(ValueEntry,ItemJnlLine);

        UpdateAdjmtProp(ValueEntry,CapLedgEntry."Posting Date");

        InsertItemReg(0,0,ValueEntry."Entry No.",0);
        InsertPostValueEntryToGL(ValueEntry);
        if Item."Item Tracking Code" <> '' then begin
          TempValueEntryRelation.INIT;
          TempValueEntryRelation."Value Entry No." := ValueEntry."Entry No.";
          TempValueEntryRelation.INSERT;
        end;
        if ("Item Shpt. Entry No." <> 0) and
           (ValueEntryType = "Value Entry Type"::"Direct Cost")
        then begin
          CapLedgEntry."Invoiced Quantity" := CapLedgEntry."Invoiced Quantity" + "Invoiced Quantity";
          if Subcontracting then
            CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry."Output Quantity"
          else
            CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry.Quantity;
          CapLedgEntry.MODIFY;
        end;
      end;
    END;

    LOCAL PROCEDURE ItemQtyPosting@17();
    VAR
      IsReserved@1000 : Boolean;
    BEGIN
      with ItemJnlLine do begin
        if Quantity <> "Invoiced Quantity" then
          TESTFIELD("Invoiced Quantity",0);
        TESTFIELD("Item Shpt. Entry No.",0);

        InitItemLedgEntry(GlobalItemLedgEntry);
        InitValueEntry(GlobalValueEntry,GlobalItemLedgEntry);

        if Item.Type = Item.Type::Inventory then begin
          GlobalItemLedgEntry."Remaining Quantity" := GlobalItemLedgEntry.Quantity;
          GlobalItemLedgEntry.Open := GlobalItemLedgEntry."Remaining Quantity" <> 0;
        end else begin
          GlobalItemLedgEntry."Remaining Quantity" := 0;
          GlobalItemLedgEntry.Open := false;
        end;
        GlobalItemLedgEntry.Positive := GlobalItemLedgEntry.Quantity > 0;
        if GlobalItemLedgEntry."Entry Type" = GlobalItemLedgEntry."Entry Type"::Transfer then
          GlobalItemLedgEntry."Completely Invoiced" := true;

        if GlobalItemLedgEntry.Quantity > 0 then
          if GlobalItemLedgEntry."Entry Type" <> GlobalItemLedgEntry."Entry Type"::Transfer then
            IsReserved :=
              ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(
                ItemJnlLine,GlobalItemLedgEntry,"Quantity (Base)",true);

        ApplyItemLedgEntry(GlobalItemLedgEntry,OldItemLedgEntry,GlobalValueEntry,false);
        CheckApplFromInProduction(GlobalItemLedgEntry,"Applies-from Entry");
        AutoTrack(GlobalItemLedgEntry,IsReserved);

        if ("Entry Type" = "Entry Type"::Transfer) and AverageTransfer then
          InsertTransferEntry(GlobalItemLedgEntry,OldItemLedgEntry,TotalAppliedQty);

        if "Entry Type" in ["Entry Type"::"Assembly Output","Entry Type"::"Assembly Consumption"] then
          InsertAsmItemEntryRelation(GlobalItemLedgEntry);

        if (not "Phys. Inventory") or (Quantity <> 0) then begin
          InsertItemLedgEntry(GlobalItemLedgEntry,false);
          if GlobalItemLedgEntry.Positive then
            InsertApplEntry(
              GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry."Entry No.",
              "Applies-from Entry",0,GlobalItemLedgEntry."Posting Date",
              GlobalItemLedgEntry.Quantity,true);
        end;
      end;
    END;

    LOCAL PROCEDURE ItemValuePosting@22();
    BEGIN
      with ItemJnlLine do begin
        if ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and
           ("Item Charge No." = '') and
           not Adjustment
        then begin
          if (Quantity = 0) and ("Invoiced Quantity" <> 0) then begin
            if (GlobalValueEntry."Invoiced Quantity" < 0) and
               (Item."Costing Method" = Item."Costing Method"::Average)
            then
              ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          end else begin
            if (GlobalValueEntry."Valued Quantity" < 0) and ("Entry Type" <> "Entry Type"::Transfer) then
              if Item."Costing Method" = Item."Costing Method"::Average then
                ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          end;
        end;

        InsertValueEntry(GlobalValueEntry,GlobalItemLedgEntry,false);

        if ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") or
           ("Item Charge No." <> '')
        then begin
          if ("Value Entry Type" <> "Value Entry Type"::Rounding) and (not Adjustment) then begin
            if GlobalItemLedgEntry.Positive then
              GlobalItemLedgEntry.MODIFY;
            if ((GlobalValueEntry."Valued Quantity" > 0) or
                (("Applies-to Entry" <> 0) and ("Entry Type" in ["Entry Type"::Purchase,"Entry Type"::"Assembly Output"]))) and
               (OverheadAmount <> 0)
            then
              InsertOHValueEntry(GlobalValueEntry,OverheadAmount,OverheadAmountACY);
            if (Item."Costing Method" = Item."Costing Method"::Standard) and
               ("Entry Type" = "Entry Type"::Purchase) and
               (GlobalValueEntry."Entry Type" <> GlobalValueEntry."Entry Type"::Revaluation)
            then
              InsertVarValueEntry(
                GlobalValueEntry,
                -GlobalValueEntry."Cost Amount (Actual)" + OverheadAmount,
                -(GlobalValueEntry."Cost Amount (Actual) (ACY)" + OverheadAmountACY));
          end;
        end else begin
          if IsBalanceExpectedCostFromRev(ItemJnlLine) then
            InsertBalanceExpCostRevEntry(GlobalValueEntry);

          if ((GlobalValueEntry."Valued Quantity" > 0) or
              (("Applies-to Entry" <> 0) and ("Entry Type" in ["Entry Type"::Purchase,"Entry Type"::"Assembly Output"]))) and
             (OverheadAmount <> 0)
          then
            InsertOHValueEntry(GlobalValueEntry,OverheadAmount,OverheadAmountACY);

          if ((GlobalValueEntry."Valued Quantity" > 0) or ("Applies-to Entry" <> 0)) and
             ("Entry Type" = "Entry Type"::Purchase) and
             (Item."Costing Method" = Item."Costing Method"::Standard) and
             (ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") <> 0) or
             VarianceRequired
          then
            InsertVarValueEntry(GlobalValueEntry,VarianceAmount,VarianceAmountACY);
        end;
        if (GlobalValueEntry."Valued Quantity" < 0) and
           (GlobalItemLedgEntry.Quantity = GlobalItemLedgEntry."Invoiced Quantity")
        then
          UpdateItemApplnEntry(GlobalValueEntry."Item Ledger Entry No.","Posting Date");
      end;
    END;

    LOCAL PROCEDURE FlushOperation@33(ProdOrder@1000 : Record "Production Order";ProdOrderLine@1001 : Record "Prod. Order Line");
    VAR
      ProdOrderRtngLine@1002 : Record "Prod. Order Routing Line";
      ProdOrderComp@1003 : Record "Prod. Order Component";
      OldItemJnlLine@1004 : Record "Item Journal Line";
      OldTempSplitItemJnlLine@1008 : TEMPORARY Record "Item Journal Line";
      OldItemTrackingCode@1011 : Record "Item Tracking Code";
      OldSNRequired@1006 : Boolean;
      OldLotRequired@1005 : Boolean;
      xCalledFromInvtPutawayPick@1007 : Boolean;
    BEGIN
      if ItemJnlLine."Operation No." = '' then
        exit;

      OldItemJnlLine := ItemJnlLine;
      OldTempSplitItemJnlLine.RESET;
      OldTempSplitItemJnlLine.DELETEALL;
      TempSplitItemJnlLine.RESET;
      if TempSplitItemJnlLine.FINDSET then
        repeat
          OldTempSplitItemJnlLine := TempSplitItemJnlLine;
          OldTempSplitItemJnlLine.INSERT;
        until TempSplitItemJnlLine.NEXT = 0;
      OldSNRequired := SNRequired;
      OldLotRequired := LotRequired;
      OldItemTrackingCode := ItemTrackingCode;
      xCalledFromInvtPutawayPick := CalledFromInvtPutawayPick;
      CalledFromInvtPutawayPick := false;

      ProdOrderRtngLine.GET(
        ProdOrderRtngLine.Status::Released,
        OldItemJnlLine."Order No.",
        OldItemJnlLine."Routing Reference No.",
        OldItemJnlLine."Routing No.",
        OldItemJnlLine."Operation No.");
      if ProdOrderRtngLine."Routing Link Code" <> '' then
        with ProdOrderComp do begin
          SETCURRENTKEY(Status,"Prod. Order No.","Routing Link Code","Flushing Method");
          SETRANGE("Flushing Method","Flushing Method"::Forward,"Flushing Method"::"Pick + Backward");
          SETRANGE("Routing Link Code",ProdOrderRtngLine."Routing Link Code");
          SETRANGE(Status,Status::Released);
          SETRANGE("Prod. Order No.",OldItemJnlLine."Order No.");
          SETRANGE("Prod. Order Line No.",OldItemJnlLine."Order Line No.");
          if FINDSET then begin
            BlockRetrieveIT := true;
            repeat
              PostFlushedConsump(
                ProdOrder,ProdOrderLine,ProdOrderComp,
                OldItemJnlLine."Output Quantity (Base)" + OldItemJnlLine."Scrap Quantity (Base)",
                OldItemJnlLine."Posting Date",OldItemJnlLine."Document No.");
            until NEXT = 0;
            BlockRetrieveIT := false;
          end;
        end;

      ItemJnlLine := OldItemJnlLine;
      TempSplitItemJnlLine.RESET;
      TempSplitItemJnlLine.DELETEALL;
      if OldTempSplitItemJnlLine.FINDSET then
        repeat
          TempSplitItemJnlLine := OldTempSplitItemJnlLine;
          TempSplitItemJnlLine.INSERT;
        until OldTempSplitItemJnlLine.NEXT = 0;
      SNRequired := OldSNRequired;
      LotRequired := OldLotRequired;
      ItemTrackingCode := OldItemTrackingCode;
      CalledFromInvtPutawayPick := xCalledFromInvtPutawayPick;
    END;

    LOCAL PROCEDURE PostFlushedConsump@32(ProdOrder@1000 : Record "Production Order";ProdOrderLine@1001 : Record "Prod. Order Line";ProdOrderComp@1002 : Record "Prod. Order Component";ActOutputQtyBase@1008 : Decimal;PostingDate@1006 : Date;DocumentNo@1003 : Code[20]);
    VAR
      CompItem@1004 : Record Item;
      OldTempTrackingSpecification@1009 : TEMPORARY Record "Tracking Specification";
      QtyToPost@1007 : Decimal;
      CalcBasedOn@1005 : '"Actual Output","Expected Output"';
      PostItemJnlLine@1013 : Boolean;
      DimsAreTaken@1010 : Boolean;
      TrackingSpecExists@1011 : Boolean;
    BEGIN
      CompItem.GET(ProdOrderComp."Item No.");
      CompItem.TESTFIELD("Rounding Precision");

      if ProdOrderComp."Flushing Method" in
         [ProdOrderComp."Flushing Method"::Backward,ProdOrderComp."Flushing Method"::"Pick + Backward"]
      then
        QtyToPost :=
          CostCalcMgt.CalcActNeededQtyBase(ProdOrderLine,ProdOrderComp,ActOutputQtyBase) / ProdOrderComp."Qty. per Unit of Measure"
      else
        QtyToPost := ProdOrderComp.GetNeededQty(CalcBasedOn::"Expected Output",true);
      QtyToPost := ROUND(QtyToPost,CompItem."Rounding Precision",'>');

      if QtyToPost = 0 then
        exit;

      with ItemJnlLine do begin
        INIT;
        "Line No." := 0;
        "Entry Type" := "Entry Type"::Consumption;
        VALIDATE("Posting Date",PostingDate);
        "Document No." := DocumentNo;
        "Source No." := ProdOrderLine."Item No.";
        "Order Type" := "Order Type"::Production;
        "Order No." := ProdOrderLine."Prod. Order No.";
        VALIDATE("Order Line No.",ProdOrderLine."Line No.");
        VALIDATE("Item No.",ProdOrderComp."Item No.");
        VALIDATE("Prod. Order Comp. Line No.",ProdOrderComp."Line No.");
        VALIDATE("Unit of Measure Code",ProdOrderComp."Unit of Measure Code");
        Description := ProdOrderComp.Description;
        VALIDATE(Quantity,QtyToPost);
        VALIDATE("Unit Cost",ProdOrderComp."Unit Cost");
        "Location Code" := ProdOrderComp."Location Code";
        "Bin Code" := ProdOrderComp."Bin Code";
        "Variant Code" := ProdOrderComp."Variant Code";
        "Source Code" := SourceCodeSetup.Flushing;
        "Gen. Bus. Posting Group" := ProdOrder."Gen. Bus. Posting Group";
        "Gen. Prod. Posting Group" := CompItem."Gen. Prod. Posting Group";

        OldTempTrackingSpecification.RESET;
        OldTempTrackingSpecification.DELETEALL;
        TempTrackingSpecification.RESET;
        if TempTrackingSpecification.FINDSET then
          repeat
            OldTempTrackingSpecification := TempTrackingSpecification;
            OldTempTrackingSpecification.INSERT;
          until TempTrackingSpecification.NEXT = 0;
        ReserveProdOrderComp.TransferPOCompToItemJnlLine(
          ProdOrderComp,ItemJnlLine,ROUND(QtyToPost * ProdOrderComp."Qty. per Unit of Measure",0.00001));

        PrepareItem(ItemJnlLine);
        TrackingSpecExists := ItemTrackingMgt.RetrieveItemTracking(ItemJnlLine,TempTrackingSpecification);
        PostItemJnlLine := SetupSplitJnlLine(ItemJnlLine,TrackingSpecExists);

        while SplitJnlLine(ItemJnlLine,PostItemJnlLine) do begin
          if SNRequired and ("Serial No." = '') then
            ERROR(SerialNoRequiredErr,"Item No.");
          if LotRequired and ("Lot No." = '') then
            ERROR(LotNoRequiredErr,"Item No.");

          if not DimsAreTaken then begin
            "Dimension Set ID" := GetCombinedDimSetID(ProdOrderComp."Dimension Set ID",ProdOrderLine."Dimension Set ID");
            DimsAreTaken := true;
          end;
          ItemJnlCheckLine.RunCheck(ItemJnlLine);
          ProdOrderCompModified := true;
          Quantity := "Quantity (Base)";
          "Invoiced Quantity" := "Invoiced Qty. (Base)";
          QtyPerUnitOfMeasure := "Qty. per Unit of Measure";

          "Unit Amount" := ROUND(
              "Unit Amount" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
          "Unit Cost" := ROUND(
              "Unit Cost" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
          "Unit Cost (ACY)" := ROUND(
              "Unit Cost (ACY)" / QtyPerUnitOfMeasure,Currency."Unit-Amount Rounding Precision");
          PostConsumption;
        end;

        TempTrackingSpecification.RESET;
        TempTrackingSpecification.DELETEALL;
        if OldTempTrackingSpecification.FINDSET then
          repeat
            TempTrackingSpecification := OldTempTrackingSpecification;
            TempTrackingSpecification.INSERT;
          until OldTempTrackingSpecification.NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE UpdateUnitCost@9(ValueEntry@1002 : Record "Value Entry");
    VAR
      ItemCostMgt@1000 : Codeunit ItemCostManagement;
      LastDirectCost@1001 : Decimal;
    BEGIN
      with ValueEntry do begin
        if ("Valued Quantity" > 0) and not ("Expected Cost" or ItemJnlLine.Adjustment) then begin
          Item.LOCKTABLE;
          if not Item.FIND then
            exit;

          if IsInbound and
             (("Cost Amount (Actual)" + "Discount Amount" > 0) or (Item.Type = Item.Type::Service)) and
             (ItemJnlLine."Value Entry Type" = ItemJnlLine."Value Entry Type"::"Direct Cost") and
             (ItemJnlLine."Item Charge No." = '') and not Item."Inventory Value Zero"
          then
            LastDirectCost :=
              ROUND(
                (ItemJnlLine.Amount + ItemJnlLine."Discount Amount") / "Valued Quantity",
                GLSetup."Unit-Amount Rounding Precision");
          if "Drop Shipment" then begin
            if LastDirectCost <> 0 then begin
              Item."Last Direct Cost" := LastDirectCost;
              Item.MODIFY;
              ItemCostMgt.SetProperties(false,"Invoiced Quantity");
              ItemCostMgt.FindUpdateUnitCostSKU(Item,"Location Code","Variant Code",true,LastDirectCost);
            end;
          end else begin
            ItemCostMgt.SetProperties(false,"Invoiced Quantity");
            ItemCostMgt.UpdateUnitCost(Item,"Location Code","Variant Code",LastDirectCost,0,true,true,false,0);
          end;
        end;
      end;
    END;

    [External]
    PROCEDURE UnApply@73(Application@1000 : Record "Item Application Entry");
    VAR
      ItemLedgEntry1@1001 : Record "Item Ledger Entry";
      ItemLedgEntry2@1002 : Record "Item Ledger Entry";
      CostItemLedgEntry@1004 : Record "Item Ledger Entry";
      InventoryPeriod@1005 : Record "Inventory Period";
      Valuationdate@1008 : Date;
    BEGIN
      if not InventoryPeriod.IsValidDate(Application."Posting Date") then
        InventoryPeriod.ShowError(Application."Posting Date");

      // If we can't get both entries then the application is not a real application or a date compression might have been done
      ItemLedgEntry1.GET(Application."Inbound Item Entry No.");
      ItemLedgEntry2.GET(Application."Outbound Item Entry No.");

      if Application."Item Ledger Entry No." = Application."Inbound Item Entry No." then
        if ItemLedgEntry1.Correction then
          ERROR(Text025);
      if Application."Item Ledger Entry No." = Application."Outbound Item Entry No." then
        if ItemLedgEntry2.Correction then
          ERROR(Text025);

      if ItemLedgEntry1."Drop Shipment" and ItemLedgEntry2."Drop Shipment" then
        ERROR(Text024);

      if ItemLedgEntry2."Entry Type" = ItemLedgEntry2."Entry Type"::Transfer then
        ERROR(Text023);

      Application.TESTFIELD("Transferred-from Entry No.",0);

      // We won't allow deletion of applications for deleted items
      Item.GET(ItemLedgEntry1."Item No.");
      CostItemLedgEntry.GET(Application.CostReceiver); // costreceiver

      if ItemLedgEntry1."Applies-to Entry" = ItemLedgEntry2."Entry No." then
        ItemLedgEntry1."Applies-to Entry" := 0;

      if ItemLedgEntry2."Applies-to Entry" = ItemLedgEntry1."Entry No." then
        ItemLedgEntry2."Applies-to Entry" := 0;

      // only if real/quantity application
      if not Application.CostApplication then begin
        ItemLedgEntry1."Remaining Quantity" := ItemLedgEntry1."Remaining Quantity" - Application.Quantity;
        ItemLedgEntry1.Open := ItemLedgEntry1."Remaining Quantity" <> 0;
        ItemLedgEntry1.MODIFY;

        ItemLedgEntry2."Remaining Quantity" := ItemLedgEntry2."Remaining Quantity" + Application.Quantity;
        ItemLedgEntry2.Open := ItemLedgEntry2."Remaining Quantity" <> 0;
        ItemLedgEntry2.MODIFY;
      end else begin
        ItemLedgEntry2."Shipped Qty. Not Returned" := ItemLedgEntry2."Shipped Qty. Not Returned" - ABS(Application.Quantity);
        if ABS(ItemLedgEntry2."Shipped Qty. Not Returned") > ABS(ItemLedgEntry2.Quantity) then
          ItemLedgEntry2.FIELDERROR("Shipped Qty. Not Returned",Text004); // Assert - should never happen
        ItemLedgEntry2.MODIFY;

        // If cost application we need to insert a 0 application instead if there is none before
        if Application.Quantity > 0 then
          if not ZeroApplication(Application."Item Ledger Entry No.") then
            InsertApplEntry(
              Application."Item Ledger Entry No.",Application."Inbound Item Entry No.",
              0,0,Application."Posting Date",
              Application.Quantity,true);
      end;

      if Item."Costing Method" = Item."Costing Method"::Average then
        if Application.Fixed then
          UpdateValuedByAverageCost(CostItemLedgEntry."Entry No.",true);

      Application.InsertHistory;
      TouchEntry(Application."Inbound Item Entry No.");
      SaveTouchedEntry(Application."Inbound Item Entry No.",true);
      if Application."Outbound Item Entry No." <> 0 then begin
        TouchEntry(Application."Outbound Item Entry No.");
        SaveTouchedEntry(Application."Inbound Item Entry No.",false);
      end;
      Application.DELETE;

      Valuationdate := GetMaxAppliedValuationdate(CostItemLedgEntry);
      if Valuationdate = 0D then
        Valuationdate := CostItemLedgEntry."Posting Date"
      else
        Valuationdate := Max(CostItemLedgEntry."Posting Date",Valuationdate);

      SetValuationDateAllValueEntrie(CostItemLedgEntry."Entry No.",Valuationdate,false);

      UpdateLinkedValuationUnapply(Valuationdate,CostItemLedgEntry."Entry No.",CostItemLedgEntry.Positive);
    END;

    [Internal]
    PROCEDURE ReApply@74(ItemLedgEntry@1000 : Record "Item Ledger Entry";ApplyWith@1001 : Integer);
    VAR
      ItemLedgEntry2@1002 : Record "Item Ledger Entry";
      ValueEntry@1003 : Record "Value Entry";
      InventoryPeriod@1004 : Record "Inventory Period";
      SNInfoRequired@1006 : Boolean;
      LotInfoRequired@1007 : Boolean;
      CostApplication@1009 : Boolean;
    BEGIN
      Item.GET(ItemLedgEntry."Item No.");

      if not InventoryPeriod.IsValidDate(ItemLedgEntry."Posting Date") then
        InventoryPeriod.ShowError(ItemLedgEntry."Posting Date");

      ItemTrackingCode.Code := Item."Item Tracking Code";
      ItemTrackingMgt.GetItemTrackingSettings(
        ItemTrackingCode,ItemJnlLine."Entry Type",ItemJnlLine.Signed(ItemJnlLine."Quantity (Base)") > 0,
        SNRequired,LotRequired,SNInfoRequired,LotInfoRequired);

      TotalAppliedQty := 0;
      CostApplication := false;
      if ApplyWith <> 0 then begin
        ItemLedgEntry2.GET(ApplyWith);
        if ItemLedgEntry2.Quantity > 0 then begin
          // Switch around so ItemLedgEntry is positive and ItemLedgEntry2 is negative
          OldItemLedgEntry := ItemLedgEntry;
          ItemLedgEntry := ItemLedgEntry2;
          ItemLedgEntry2 := OldItemLedgEntry;
        end;
        if not ((ItemLedgEntry.Quantity > 0) and // not(Costprovider(ItemLedgEntry))
                ((ItemLedgEntry."Entry Type" = ItemLedgEntry2."Entry Type"::Purchase) or
                 (ItemLedgEntry."Entry Type" = ItemLedgEntry2."Entry Type"::"Positive Adjmt.") or
                 (ItemLedgEntry."Entry Type" = ItemLedgEntry2."Entry Type"::Output) or
                 (ItemLedgEntry."Entry Type" = ItemLedgEntry2."Entry Type"::"Assembly Output"))
                )
        then
          CostApplication := true;
        if (ItemLedgEntry."Remaining Quantity" <> 0) and (ItemLedgEntry2."Remaining Quantity" <> 0) then
          CostApplication := false;
        if CostApplication then
          CostApply(ItemLedgEntry,ItemLedgEntry2)
        else begin
          CreateItemJNLLinefromEntry(ItemLedgEntry2,ItemLedgEntry2."Remaining Quantity",ItemJnlLine);
          if ApplyWith = ItemLedgEntry2."Entry No." then
            ItemLedgEntry2."Applies-to Entry" := ItemLedgEntry."Entry No."
          else
            ItemLedgEntry2."Applies-to Entry" := ApplyWith;
          ItemJnlLine."Applies-to Entry" := ItemLedgEntry2."Applies-to Entry";
          GlobalItemLedgEntry := ItemLedgEntry2;
          ApplyItemLedgEntry(ItemLedgEntry2,OldItemLedgEntry,ValueEntry,false);
          TouchItemEntryCost(ItemLedgEntry2,false);
          ItemLedgEntry2.MODIFY;
          EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry2);
          GetValuationDate(ValueEntry,ItemLedgEntry);
          UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
        end;

        if ItemApplnEntry.Fixed and (ItemApplnEntry.CostReceiver <> 0) then
          if Item.GET(ItemLedgEntry."Item No.") then
            if Item."Costing Method" = Item."Costing Method"::Average then
              UpdateValuedByAverageCost(ItemApplnEntry.CostReceiver,false);
      end else begin  // ApplyWith is 0
        ItemLedgEntry."Applies-to Entry" := ApplyWith;
        CreateItemJNLLinefromEntry(ItemLedgEntry,ItemLedgEntry."Remaining Quantity",ItemJnlLine);
        ItemJnlLine."Applies-to Entry" := ItemLedgEntry."Applies-to Entry";
        GlobalItemLedgEntry := ItemLedgEntry;
        ApplyItemLedgEntry(ItemLedgEntry,OldItemLedgEntry,ValueEntry,false);
        TouchItemEntryCost(ItemLedgEntry,false);
        ItemLedgEntry.MODIFY;
        EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry);
        GetValuationDate(ValueEntry,ItemLedgEntry);
        UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
      end;
    END;

    LOCAL PROCEDURE CostApply@72(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry";ItemLedgEntry2@1001 : Record "Item Ledger Entry");
    VAR
      ApplyWithItemLedgEntry@1002 : Record "Item Ledger Entry";
      ValueEntry@1004 : Record "Value Entry";
    BEGIN
      if ItemLedgEntry.Quantity > 0 then begin
        GlobalItemLedgEntry := ItemLedgEntry;
        ApplyWithItemLedgEntry := ItemLedgEntry2;
      end
      else begin
        GlobalItemLedgEntry := ItemLedgEntry2;
        ApplyWithItemLedgEntry := ItemLedgEntry;
      end;
      if not ItemApplnEntry.CheckIsCyclicalLoop(ApplyWithItemLedgEntry,GlobalItemLedgEntry) then begin
        CreateItemJNLLinefromEntry(GlobalItemLedgEntry,GlobalItemLedgEntry.Quantity,ItemJnlLine);
        InsertApplEntry(
          GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry."Entry No.",
          ApplyWithItemLedgEntry."Entry No.",0,GlobalItemLedgEntry."Posting Date",
          GlobalItemLedgEntry.Quantity,true);
        UpdateOutboundItemLedgEntry(ApplyWithItemLedgEntry."Entry No.");
        OldItemLedgEntry.GET(ApplyWithItemLedgEntry."Entry No.");
        EnsureValueEntryLoaded(ValueEntry,GlobalItemLedgEntry);
        ItemJnlLine."Applies-from Entry" := ApplyWithItemLedgEntry."Entry No.";
        GetAppliedFromValues(ValueEntry);
        SetValuationDateAllValueEntrie(GlobalItemLedgEntry."Entry No.",ValueEntry."Valuation Date",false);
        UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
        TouchItemEntryCost(ItemLedgEntry2,false);
      end;
    END;

    LOCAL PROCEDURE ZeroApplication@75(EntryNo@1000 : Integer) : Boolean;
    VAR
      Application@1001 : Record "Item Application Entry";
    BEGIN
      Application.SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.");
      Application.SETRANGE("Item Ledger Entry No.",EntryNo);
      Application.SETRANGE("Inbound Item Entry No.",EntryNo);
      Application.SETRANGE("Outbound Item Entry No.",0);
      exit(not Application.ISEMPTY);
    END;

    LOCAL PROCEDURE ApplyItemLedgEntry@1(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry";VAR OldItemLedgEntry@1001 : Record "Item Ledger Entry";VAR ValueEntry@1002 : Record "Value Entry";CausedByTransfer@1003 : Boolean);
    VAR
      ItemLedgEntry2@1004 : Record "Item Ledger Entry";
      OldValueEntry@1015 : Record "Value Entry";
      ReservEntry@1005 : Record "Reservation Entry";
      ReservEntry2@1006 : Record "Reservation Entry";
      AppliesFromItemLedgEntry@1013 : Record "Item Ledger Entry";
      EntryFindMethod@1007 : Text[1];
      AppliedQty@1008 : Decimal;
      FirstReservation@1009 : Boolean;
      FirstApplication@1010 : Boolean;
      StartApplication@1011 : Boolean;
      UseReservationApplication@1014 : Boolean;
    BEGIN
      if (ItemLedgEntry."Remaining Quantity" = 0) or
         (ItemLedgEntry."Drop Shipment" and (ItemLedgEntry."Applies-to Entry" = 0)) or
         ((Item."Costing Method" = Item."Costing Method"::Specific) and ItemLedgEntry.Positive)
      then
        exit;

      CLEAR(OldItemLedgEntry);
      FirstReservation := true;
      FirstApplication := true;
      StartApplication := false;
      repeat
        if ItemJnlLine."Assemble to Order" then
          VerifyItemJnlLineAsembleToOrder(ItemJnlLine)
        else
          VerifyItemJnlLineApplication(ItemJnlLine,ItemLedgEntry);

        if not CausedByTransfer and not PostponeReservationHandling then begin
          if Item."Costing Method" = Item."Costing Method"::Specific then
            ItemJnlLine.TESTFIELD("Serial No.");

          if FirstReservation then begin
            FirstReservation := false;
            ReservEntry.RESET;
            ReservEntry.SETCURRENTKEY(
              "Source ID","Source Ref. No.","Source Type","Source Subtype",
              "Source Batch Name","Source Prod. Order Line","Reservation Status");
            ReservEntry.SETRANGE("Reservation Status",ReservEntry."Reservation Status"::Reservation);
            ReserveItemJnlLine.FilterReservFor(ReservEntry,ItemJnlLine);
          end;

          UseReservationApplication := ReservEntry.FINDFIRST;

          if not UseReservationApplication then begin // No reservations exist
            ReservEntry.SETRANGE(
              "Reservation Status",ReservEntry."Reservation Status"::Tracking,
              ReservEntry."Reservation Status"::Prospect);
            if ReservEntry.FINDSET then
              repeat
                ReservEngineMgt.CloseSurplusTrackingEntry(ReservEntry);
              until ReservEntry.NEXT = 0;
            StartApplication := true;
          end;

          if UseReservationApplication then begin
            ReservEntry2.GET(ReservEntry."Entry No.",not ReservEntry.Positive);
            if ReservEntry2."Source Type" <> DATABASE::"Item Ledger Entry" then
              if ItemLedgEntry.Quantity < 0 then
                ERROR(Text003,ReservEntry."Item No.");
            OldItemLedgEntry.GET(ReservEntry2."Source Ref. No.");
            if ItemLedgEntry.Quantity < 0 then
              if OldItemLedgEntry."Remaining Quantity" < ReservEntry2."Quantity (Base)" then
                ERROR(Text003,ReservEntry2."Item No.");

            OldItemLedgEntry.TESTFIELD("Item No.",ItemJnlLine."Item No.");
            OldItemLedgEntry.TESTFIELD("Variant Code",ItemJnlLine."Variant Code");
            OldItemLedgEntry.TESTFIELD("Location Code",ItemJnlLine."Location Code");
            ReservEngineMgt.CloseReservEntry(ReservEntry,false,false);
            OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
            AppliedQty := -ABS(ReservEntry."Quantity (Base)");
          end;
        end else
          StartApplication := true;

        if StartApplication then begin
          ItemLedgEntry.CALCFIELDS("Reserved Quantity");
          if ItemLedgEntry."Applies-to Entry" <> 0 then begin
            if FirstApplication then begin
              FirstApplication := false;
              OldItemLedgEntry.GET(ItemLedgEntry."Applies-to Entry");
              OldItemLedgEntry.TESTFIELD("Item No.",ItemLedgEntry."Item No.");
              OldItemLedgEntry.TESTFIELD("Variant Code",ItemLedgEntry."Variant Code");

              OldItemLedgEntry.TESTFIELD(Positive,not ItemLedgEntry.Positive);
              OldItemLedgEntry.TESTFIELD("Location Code",ItemLedgEntry."Location Code");
              if Location.GET(ItemLedgEntry."Location Code") then
                if Location."Use As In-Transit" then begin
                  OldItemLedgEntry.TESTFIELD("Order Type",OldItemLedgEntry."Order Type"::Transfer);
                  OldItemLedgEntry.TESTFIELD("Order No.",ItemLedgEntry."Order No.");
                end;

              if ItemTrackingCode."SN Specific Tracking" or ItemLedgEntry."Drop Shipment" then
                OldItemLedgEntry.TESTFIELD("Serial No.",ItemLedgEntry."Serial No.");
              if ItemTrackingCode."Lot Specific Tracking" or ItemLedgEntry."Drop Shipment" then
                OldItemLedgEntry.TESTFIELD("Lot No.",ItemLedgEntry."Lot No.");

              if  not (OldItemLedgEntry.Open and
                       (ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >=
                        ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity")))
              then begin
                if  (ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") <=
                     ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity"))
                then begin
                  if not MoveApplication(ItemLedgEntry,OldItemLedgEntry) then
                    OldItemLedgEntry.FIELDERROR("Remaining Quantity",Text004);
                end
                else
                  OldItemLedgEntry.TESTFIELD(Open,true);
              end;

              OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
              CheckApplication(ItemLedgEntry,OldItemLedgEntry);

              if ABS(OldItemLedgEntry."Remaining Quantity") <= ABS(OldItemLedgEntry."Reserved Quantity") then
                ReservationPreventsApplication(ItemLedgEntry."Applies-to Entry",ItemLedgEntry."Item No.",OldItemLedgEntry);

              if (OldItemLedgEntry."Order Type" = OldItemLedgEntry."Order Type"::Production) and
                 (OldItemLedgEntry."Order No." <> '')
              then
                if not AllowProdApplication(OldItemLedgEntry,ItemLedgEntry) then
                  ERROR(
                    Text022,
                    ItemLedgEntry."Entry Type",
                    OldItemLedgEntry."Entry Type",
                    OldItemLedgEntry."Item No.",
                    OldItemLedgEntry."Order No.")
            end else
              exit;
          end else begin
            if FirstApplication then begin
              FirstApplication := false;
              ItemLedgEntry2.SETCURRENTKEY(
                "Item No.",Open,"Variant Code",Positive,"Location Code","Posting Date");
              ItemLedgEntry2.SETRANGE("Item No.",ItemLedgEntry."Item No.");
              ItemLedgEntry2.SETRANGE(Open,true);
              ItemLedgEntry2.SETRANGE("Variant Code",ItemLedgEntry."Variant Code");
              ItemLedgEntry2.SETRANGE(Positive,not ItemLedgEntry.Positive);
              ItemLedgEntry2.SETRANGE("Location Code",ItemLedgEntry."Location Code");

              if ItemLedgEntry."Job Purchase" then begin
                ItemLedgEntry2.SETRANGE("Job No.",ItemLedgEntry."Job No.");
                ItemLedgEntry2.SETRANGE("Job Task No.",ItemLedgEntry."Job Task No.");
                ItemLedgEntry2.SETRANGE("Document Type",ItemLedgEntry."Document Type");
                ItemLedgEntry2.SETRANGE("Document No.",ItemLedgEntry."Document No.");
              end;

              if ItemTrackingCode."SN Specific Tracking" then
                ItemLedgEntry2.SETRANGE("Serial No.",ItemLedgEntry."Serial No.");
              if ItemTrackingCode."Lot Specific Tracking" then
                ItemLedgEntry2.SETRANGE("Lot No.",ItemLedgEntry."Lot No.");

              if Location.GET(ItemLedgEntry."Location Code") then
                if Location."Use As In-Transit" then begin
                  ItemLedgEntry2.SETRANGE("Order Type",ItemLedgEntry."Order Type"::Transfer);
                  ItemLedgEntry2.SETRANGE("Order No.",ItemLedgEntry."Order No.");
                end;

              if Item."Costing Method" = Item."Costing Method"::LIFO then
                EntryFindMethod := '+'
              else
                EntryFindMethod := '-';
              if not ItemLedgEntry2.FIND(EntryFindMethod) then
                exit;
            end else
              case EntryFindMethod of
                '-':
                  if ItemLedgEntry2.NEXT = 0 then
                    exit;
                '+':
                  if ItemLedgEntry2.NEXT(-1) = 0 then
                    exit;
              end;
            OldItemLedgEntry.COPY(ItemLedgEntry2)
          end;

          OldItemLedgEntry.CALCFIELDS("Reserved Quantity");

          if ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >
             ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity")
          then
            AppliedQty := ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity"
          else
            AppliedQty := -(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity");

          if ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Transfer then
            if (OldItemLedgEntry."Entry No." > ItemLedgEntry."Entry No.") and not ItemLedgEntry.Positive then
              AppliedQty := 0;
          if (OldItemLedgEntry."Order Type" = OldItemLedgEntry."Order Type"::Production) and
             (OldItemLedgEntry."Order No." <> '')
          then
            if not AllowProdApplication(OldItemLedgEntry,ItemLedgEntry) then
              AppliedQty := 0;
          if ItemJnlLine."Applies-from Entry" <> 0 then begin
            AppliesFromItemLedgEntry.GET(ItemJnlLine."Applies-from Entry");
            if ItemApplnEntry.CheckIsCyclicalLoop(AppliesFromItemLedgEntry,OldItemLedgEntry) then
              AppliedQty := 0;
          end;
        end;

        CheckIsCyclicalLoop(ItemLedgEntry,OldItemLedgEntry,PrevAppliedItemLedgEntry,AppliedQty);

        if AppliedQty <> 0 then begin
          if not OldItemLedgEntry.Positive and
             (OldItemLedgEntry."Remaining Quantity" = -AppliedQty) and
             (OldItemLedgEntry."Entry No." = ItemLedgEntry."Applies-to Entry")
          then begin
            OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
            OldValueEntry.SETRANGE("Item Ledger Entry No.",OldItemLedgEntry."Entry No.");
            if OldValueEntry.FIND('-') then
              repeat
                if OldValueEntry."Valued By Average Cost" then begin
                  OldValueEntry."Valued By Average Cost" := false;
                  OldValueEntry.MODIFY;
                end;
              until OldValueEntry.NEXT = 0;
          end;

          OldItemLedgEntry."Remaining Quantity" := OldItemLedgEntry."Remaining Quantity" + AppliedQty;
          OldItemLedgEntry.Open := OldItemLedgEntry."Remaining Quantity" <> 0;

          if ItemLedgEntry.Positive then begin
            if ItemLedgEntry."Posting Date" >= OldItemLedgEntry."Posting Date" then
              InsertApplEntry(
                OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
                OldItemLedgEntry."Entry No.",0,ItemLedgEntry."Posting Date",-AppliedQty,false)
            else
              InsertApplEntry(
                OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
                OldItemLedgEntry."Entry No.",0,OldItemLedgEntry."Posting Date",-AppliedQty,false);

            if ItemApplnEntry."Cost Application" then
              ItemLedgEntry."Applied Entry to Adjust" := true;
          end else begin
            if ItemTrackingCode."Strict Expiration Posting" and (OldItemLedgEntry."Expiration Date" <> 0D) and
               not ItemLedgEntry.Correction and
               not (ItemLedgEntry."Document Type" in
                    [ItemLedgEntry."Document Type"::"Purchase Return Shipment",ItemLedgEntry."Document Type"::"Purchase Credit Memo"])
            then
              if ItemLedgEntry."Posting Date" > OldItemLedgEntry."Expiration Date" then
                if (ItemLedgEntry."Entry Type" <> ItemLedgEntry."Entry Type"::"Negative Adjmt.") and
                   not ItemJnlLine.IsReclass(ItemJnlLine)
                then
                  OldItemLedgEntry.FIELDERROR("Expiration Date",Text017);

            InsertApplEntry(
              ItemLedgEntry."Entry No.",OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",0,
              ItemLedgEntry."Posting Date",AppliedQty,true);

            if ItemApplnEntry."Cost Application" then
              OldItemLedgEntry."Applied Entry to Adjust" := true;
          end;

          OldItemLedgEntry.MODIFY;
          AutoTrack(OldItemLedgEntry,true);

          EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry);
          GetValuationDate(ValueEntry,OldItemLedgEntry);

          if (ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Transfer) and
             (AppliedQty < 0) and
             not CausedByTransfer
          then begin
            if ItemLedgEntry."Completely Invoiced" then
              ItemLedgEntry."Completely Invoiced" := OldItemLedgEntry."Completely Invoiced";
            if AverageTransfer then
              TotalAppliedQty := TotalAppliedQty + AppliedQty
            else
              InsertTransferEntry(ItemLedgEntry,OldItemLedgEntry,AppliedQty);
          end;

          ItemLedgEntry."Remaining Quantity" := ItemLedgEntry."Remaining Quantity" - AppliedQty;
          ItemLedgEntry.Open := ItemLedgEntry."Remaining Quantity" <> 0;

          ItemLedgEntry.CALCFIELDS("Reserved Quantity");
          if ItemLedgEntry."Remaining Quantity" + ItemLedgEntry."Reserved Quantity" = 0 then
            exit;
        end;
      until false;
    END;

    LOCAL PROCEDURE EnsureValueEntryLoaded@76(VAR ValueEntry@1000 : Record "Value Entry";ItemLedgEntry@1001 : Record "Item Ledger Entry");
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntry."Entry No.");
      if ValueEntry.FIND('-') then;
    END;

    LOCAL PROCEDURE AllowProdApplication@48(OldItemLedgEntry@1000 : Record "Item Ledger Entry";ItemLedgEntry@1001 : Record "Item Ledger Entry") : Boolean;
    BEGIN
      exit(
        (OldItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type") or
        (OldItemLedgEntry."Order No." <> ItemLedgEntry."Order No.") or
        ((OldItemLedgEntry."Order No." = ItemLedgEntry."Order No.") and
         (OldItemLedgEntry."Order Line No." <> ItemLedgEntry."Order Line No.")));
    END;

    LOCAL PROCEDURE InitValueEntryNo@146();
    BEGIN
      if ValueEntryNo > 0 then
        exit;

      GlobalValueEntry.LOCKTABLE;
      if GlobalValueEntry.FINDLAST then
        ValueEntryNo := GlobalValueEntry."Entry No.";
    END;

    LOCAL PROCEDURE InsertTransferEntry@6(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry";VAR OldItemLedgEntry@1001 : Record "Item Ledger Entry";AppliedQty@1002 : Decimal);
    VAR
      NewItemLedgEntry@1003 : Record "Item Ledger Entry";
      NewValueEntry@1004 : Record "Value Entry";
      ItemLedgEntry2@1005 : Record "Item Ledger Entry";
      IsReserved@1006 : Boolean;
    BEGIN
      with ItemJnlLine do begin
        InitItemLedgEntry(NewItemLedgEntry);
        NewItemLedgEntry."Applies-to Entry" := 0;

        NewItemLedgEntry.Quantity := -AppliedQty;
        NewItemLedgEntry."Invoiced Quantity" := NewItemLedgEntry.Quantity;

        NewItemLedgEntry."Remaining Quantity" := NewItemLedgEntry.Quantity;
        NewItemLedgEntry.Open := NewItemLedgEntry."Remaining Quantity" <> 0;
        NewItemLedgEntry.Positive := NewItemLedgEntry."Remaining Quantity" > 0;

        NewItemLedgEntry."Location Code" := "New Location Code";
        NewItemLedgEntry."Country/Region Code" := "Country/Region Code";
        InsertCountryCode(NewItemLedgEntry,ItemLedgEntry);

        NewItemLedgEntry."Serial No." := "New Serial No.";
        NewItemLedgEntry."Lot No." := "New Lot No.";

        NewItemLedgEntry."Expiration Date" := "New Item Expiration Date";

        if Item."Item Tracking Code" <> '' then begin
          TempItemEntryRelation."Item Entry No." := NewItemLedgEntry."Entry No."; // Save Entry No. in a global variable
          TempItemEntryRelation."Serial No." := NewItemLedgEntry."Serial No.";
          TempItemEntryRelation."Lot No." := NewItemLedgEntry."Lot No.";
          TempItemEntryRelation.INSERT;
        end;
        InitTransValueEntry(NewValueEntry,NewItemLedgEntry);

        if AverageTransfer then begin
          InsertApplEntry(
            NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
            0,NewItemLedgEntry."Posting Date",NewItemLedgEntry.Quantity,true);
          NewItemLedgEntry."Completely Invoiced" := ItemLedgEntry."Completely Invoiced";
        end else begin
          InsertApplEntry(
            NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
            OldItemLedgEntry."Entry No.",NewItemLedgEntry."Posting Date",NewItemLedgEntry.Quantity,true);
          NewItemLedgEntry."Completely Invoiced" := OldItemLedgEntry."Completely Invoiced";
        end;

        if NewItemLedgEntry.Quantity > 0 then
          IsReserved :=
            ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(
              ItemJnlLine,NewItemLedgEntry,NewItemLedgEntry."Remaining Quantity",true);

        ApplyItemLedgEntry(NewItemLedgEntry,ItemLedgEntry2,NewValueEntry,true);
        AutoTrack(NewItemLedgEntry,IsReserved);

        OnBeforeInsertTransferEntry(NewItemLedgEntry,OldItemLedgEntry,ItemJnlLine);

        InsertItemLedgEntry(NewItemLedgEntry,true);
        InsertValueEntry(NewValueEntry,NewItemLedgEntry,true);

        UpdateUnitCost(NewValueEntry);
      end;
    END;

    LOCAL PROCEDURE InitItemLedgEntry@4(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry");
    BEGIN
      ItemLedgEntryNo := ItemLedgEntryNo + 1;

      with ItemJnlLine do begin
        ItemLedgEntry.INIT;
        ItemLedgEntry."Entry No." := ItemLedgEntryNo;
        ItemLedgEntry."Item No." := "Item No.";
        ItemLedgEntry."Posting Date" := "Posting Date";
        ItemLedgEntry."Document Date" := "Document Date";
        ItemLedgEntry."Entry Type" := "Entry Type";
        ItemLedgEntry."Source No." := "Source No.";
        ItemLedgEntry."Document No." := "Document No.";
        ItemLedgEntry."Document Type" := "Document Type";
        ItemLedgEntry."Document Line No." := "Document Line No.";
        ItemLedgEntry."Order Type" := "Order Type";
        ItemLedgEntry."Order No." := "Order No.";
        ItemLedgEntry."Order Line No." := "Order Line No.";
        ItemLedgEntry."External Document No." := "External Document No.";
        ItemLedgEntry.Description := Description;
        ItemLedgEntry."Location Code" := "Location Code";
        ItemLedgEntry."Applies-to Entry" := "Applies-to Entry";
        ItemLedgEntry."Source Type" := "Source Type";
        ItemLedgEntry."Transaction Type" := "Transaction Type";
        ItemLedgEntry."Transport Method" := "Transport Method";
        ItemLedgEntry."Country/Region Code" := "Country/Region Code";
        if ("Entry Type" = "Entry Type"::Transfer) and ("New Location Code" <> '') then begin
          if NewLocation.Code <> "New Location Code" then
            NewLocation.GET("New Location Code");
          ItemLedgEntry."Country/Region Code" := NewLocation."Country/Region Code";
        end;
        ItemLedgEntry."Entry/Exit Point" := "Entry/Exit Point";
        ItemLedgEntry.Area := Area;
        ItemLedgEntry."Transaction Specification" := "Transaction Specification";
        ItemLedgEntry."Drop Shipment" := "Drop Shipment";
        ItemLedgEntry."Assemble to Order" := "Assemble to Order";
        ItemLedgEntry."No. Series" := "Posting No. Series";
        if ItemLedgEntry.Description = Item.Description then
          ItemLedgEntry.Description := '';
        ItemLedgEntry."Prod. Order Comp. Line No." := "Prod. Order Comp. Line No.";
        ItemLedgEntry."Variant Code" := "Variant Code";
        ItemLedgEntry."Unit of Measure Code" := "Unit of Measure Code";
        ItemLedgEntry."Qty. per Unit of Measure" := "Qty. per Unit of Measure";
        ItemLedgEntry."Derived from Blanket Order" := "Derived from Blanket Order";

        ItemLedgEntry."Cross-Reference No." := "Cross-Reference No.";
        ItemLedgEntry."Originally Ordered No." := "Originally Ordered No.";
        ItemLedgEntry."Originally Ordered Var. Code" := "Originally Ordered Var. Code";
        ItemLedgEntry."Out-of-Stock Substitution" := "Out-of-Stock Substitution";
        ItemLedgEntry."Item Category Code" := "Item Category Code";
        ItemLedgEntry.Nonstock := Nonstock;
        ItemLedgEntry."Purchasing Code" := "Purchasing Code";
        ItemLedgEntry."Return Reason Code" := "Return Reason Code";
        ItemLedgEntry."Product Group Code" := "Product Group Code";
        ItemLedgEntry."Job No." := "Job No.";
        ItemLedgEntry."Job Task No." := "Job Task No.";
        ItemLedgEntry."Job Purchase" := "Job Purchase";
        ItemLedgEntry."Serial No." := "Serial No.";
        ItemLedgEntry."Lot No." := "Lot No.";
        ItemLedgEntry."Warranty Date" := "Warranty Date";
        ItemLedgEntry."Expiration Date" := "Item Expiration Date";

        ItemLedgEntry.Correction := Correction;

        if "Entry Type" in
           ["Entry Type"::Sale,
            "Entry Type"::"Negative Adjmt.",
            "Entry Type"::Transfer,
            "Entry Type"::Consumption,
            "Entry Type"::"Assembly Consumption"]
        then begin
          ItemLedgEntry.Quantity := -Quantity;
          ItemLedgEntry."Invoiced Quantity" := -"Invoiced Quantity";
        end else begin
          ItemLedgEntry.Quantity := Quantity;
          ItemLedgEntry."Invoiced Quantity" := "Invoiced Quantity";
        end;
        if (ItemLedgEntry.Quantity < 0) and ("Entry Type" <> "Entry Type"::Transfer) then
          ItemLedgEntry."Shipped Qty. Not Returned" := ItemLedgEntry.Quantity;
      end;

      OnAfterInitItemLedgEntry(ItemLedgEntry,ItemJnlLine);
    END;

    LOCAL PROCEDURE InsertItemLedgEntry@5(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry";TransferItem@1002 : Boolean);
    BEGIN
      with ItemJnlLine do begin
        if ItemLedgEntry.Open then begin
          ItemLedgEntry.VerifyOnInventory;
          if not (("Document Type" in ["Document Type"::"Purchase Return Shipment","Document Type"::"Purchase Receipt"]) and
                  ("Job No." <> ''))
          then
            if (ItemLedgEntry.Quantity < 0) and
               (ItemTrackingCode."SN Specific Tracking" or ItemTrackingCode."Lot Specific Tracking")
            then
              ERROR(Text018,"Serial No.","Lot No.","Item No.","Variant Code");

          if ItemTrackingCode."SN Specific Tracking" then begin
            if ItemLedgEntry.Quantity > 0 then
              if "Entry Type" = "Entry Type"::Transfer then begin
                if ItemTrackingMgt.FindInInventory("Item No.","Variant Code","New Serial No.") then
                  ERROR(Text014,"New Serial No.");
              end else begin
                if ItemTrackingMgt.FindInInventory("Item No.","Variant Code","Serial No.") then
                  ERROR(Text014,"Serial No.");
              end;

            if not (ItemLedgEntry.Quantity in [-1,0,1]) then
              ERROR(Text033);
          end;

          if ("Document Type" <> "Document Type"::"Purchase Return Shipment") and ("Job No." = '') then begin
            if (Item.Reserve = Item.Reserve::Always) and
               (ItemLedgEntry.Quantity < 0)
            then
              ERROR(Text012,ItemLedgEntry."Item No.");
          end;
        end;

        if TransferItem then begin
          ItemLedgEntry."Global Dimension 1 Code" := "New Shortcut Dimension 1 Code";
          ItemLedgEntry."Global Dimension 2 Code" := "New Shortcut Dimension 2 Code";
          ItemLedgEntry."Dimension Set ID" := "New Dimension Set ID";
        end else begin
          ItemLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
          ItemLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
          ItemLedgEntry."Dimension Set ID" := "Dimension Set ID";
        end;

        if not ("Entry Type" in ["Entry Type"::Transfer,"Entry Type"::Output]) and
           (ItemLedgEntry.Quantity = ItemLedgEntry."Invoiced Quantity")
        then
          ItemLedgEntry."Completely Invoiced" := true;

        if ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and ("Item Charge No." = '') and
           ("Invoiced Quantity" <> 0) and ("Posting Date" > ItemLedgEntry."Last Invoice Date")
        then
          ItemLedgEntry."Last Invoice Date" := "Posting Date";

        if "Entry Type" = "Entry Type"::Consumption then
          ItemLedgEntry."Applied Entry to Adjust" := true;

        if "Job No." <> '' then begin
          ItemLedgEntry."Job No." := "Job No.";
          ItemLedgEntry."Job Task No." := "Job Task No.";
        end;

        ItemLedgEntry.UpdateItemTracking;

        OnBeforeInsertItemLedgEntry(ItemLedgEntry,ItemJnlLine);

        ItemLedgEntry.INSERT(true);

        OnAfterInsertItemLedgEntry(ItemLedgEntry,ItemJnlLine);

        InsertItemReg(ItemLedgEntry."Entry No.",0,0,0);
      end;
    END;

    LOCAL PROCEDURE InsertItemReg@7(ItemLedgEntryNo@1000 : Integer;PhysInvtEntryNo@1001 : Integer;ValueEntryNo@1002 : Integer;CapLedgEntryNo@1004 : Integer);
    BEGIN
      with ItemJnlLine do begin
        if ItemReg."No." = 0 then begin
          ItemReg.LOCKTABLE;
          if ItemReg.FINDLAST then
            ItemReg."No." := ItemReg."No." + 1
          else
            ItemReg."No." := 1;
          ItemReg.INIT;
          ItemReg."From Entry No." := ItemLedgEntryNo;
          ItemReg."To Entry No." := ItemLedgEntryNo;
          ItemReg."From Phys. Inventory Entry No." := PhysInvtEntryNo;
          ItemReg."To Phys. Inventory Entry No." := PhysInvtEntryNo;
          ItemReg."From Value Entry No." := ValueEntryNo;
          ItemReg."To Value Entry No." := ValueEntryNo;
          ItemReg."From Capacity Entry No." := CapLedgEntryNo;
          ItemReg."To Capacity Entry No." := CapLedgEntryNo;
          ItemReg."Creation Date" := TODAY;
          ItemReg."Source Code" := "Source Code";
          ItemReg."Journal Batch Name" := "Journal Batch Name";
          ItemReg."User ID" := USERID;
          ItemReg.INSERT;
        end else begin
          if ((ItemLedgEntryNo < ItemReg."From Entry No.") and (ItemLedgEntryNo <> 0)) or
             ((ItemReg."From Entry No." = 0) and (ItemLedgEntryNo > 0))
          then
            ItemReg."From Entry No." := ItemLedgEntryNo;
          if ItemLedgEntryNo > ItemReg."To Entry No." then
            ItemReg."To Entry No." := ItemLedgEntryNo;

          if ((PhysInvtEntryNo < ItemReg."From Phys. Inventory Entry No.") and (PhysInvtEntryNo <> 0)) or
             ((ItemReg."From Phys. Inventory Entry No." = 0) and (PhysInvtEntryNo > 0))
          then
            ItemReg."From Phys. Inventory Entry No." := PhysInvtEntryNo;
          if PhysInvtEntryNo > ItemReg."To Phys. Inventory Entry No." then
            ItemReg."To Phys. Inventory Entry No." := PhysInvtEntryNo;

          if ((ValueEntryNo < ItemReg."From Value Entry No.") and (ValueEntryNo <> 0)) or
             ((ItemReg."From Value Entry No." = 0) and (ValueEntryNo > 0))
          then
            ItemReg."From Value Entry No." := ValueEntryNo;
          if ValueEntryNo > ItemReg."To Value Entry No." then
            ItemReg."To Value Entry No." := ValueEntryNo;
          if ((CapLedgEntryNo < ItemReg."From Capacity Entry No.") and (CapLedgEntryNo <> 0)) or
             ((ItemReg."From Capacity Entry No." = 0) and (CapLedgEntryNo > 0))
          then
            ItemReg."From Capacity Entry No." := CapLedgEntryNo;
          if CapLedgEntryNo > ItemReg."To Capacity Entry No." then
            ItemReg."To Capacity Entry No." := CapLedgEntryNo;

          ItemReg.MODIFY;
        end;
      end;
    END;

    LOCAL PROCEDURE InsertPhysInventoryEntry@8();
    VAR
      PhysInvtLedgEntry@1000 : Record "Phys. Inventory Ledger Entry";
    BEGIN
      with ItemJnlLineOrigin do begin
        if PhysInvtEntryNo = 0 then begin
          PhysInvtLedgEntry.LOCKTABLE;
          if PhysInvtLedgEntry.FINDLAST then
            PhysInvtEntryNo := PhysInvtLedgEntry."Entry No.";
        end;

        PhysInvtEntryNo := PhysInvtEntryNo + 1;

        PhysInvtLedgEntry.INIT;
        PhysInvtLedgEntry."Entry No." := PhysInvtEntryNo;
        PhysInvtLedgEntry."Item No." := "Item No.";
        PhysInvtLedgEntry."Posting Date" := "Posting Date";
        PhysInvtLedgEntry."Document Date" := "Document Date";
        PhysInvtLedgEntry."Entry Type" := "Entry Type";
        PhysInvtLedgEntry."Document No." := "Document No.";
        PhysInvtLedgEntry."External Document No." := "External Document No.";
        PhysInvtLedgEntry.Description := Description;
        PhysInvtLedgEntry."Location Code" := "Location Code";
        PhysInvtLedgEntry."Inventory Posting Group" := "Inventory Posting Group";
        PhysInvtLedgEntry."Unit Cost" := "Unit Cost";
        PhysInvtLedgEntry.Amount := Amount;
        PhysInvtLedgEntry."Salespers./Purch. Code" := "Salespers./Purch. Code";
        PhysInvtLedgEntry."Source Code" := "Source Code";
        PhysInvtLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        PhysInvtLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        PhysInvtLedgEntry."Dimension Set ID" := "Dimension Set ID";
        PhysInvtLedgEntry."Journal Batch Name" := "Journal Batch Name";
        PhysInvtLedgEntry."Reason Code" := "Reason Code";
        PhysInvtLedgEntry."User ID" := USERID;
        PhysInvtLedgEntry."No. Series" := "Posting No. Series";
        if PhysInvtLedgEntry.Description = Item.Description then
          PhysInvtLedgEntry.Description := '';
        PhysInvtLedgEntry."Variant Code" := "Variant Code";
        PhysInvtLedgEntry."Unit of Measure Code" := "Unit of Measure Code";

        PhysInvtLedgEntry.Quantity := Quantity;
        PhysInvtLedgEntry."Unit Amount" := "Unit Amount";
        PhysInvtLedgEntry."Qty. (Calculated)" := "Qty. (Calculated)";
        PhysInvtLedgEntry."Qty. (Phys. Inventory)" := "Qty. (Phys. Inventory)";
        PhysInvtLedgEntry."Last Item Ledger Entry No." := "Last Item Ledger Entry No.";

        PhysInvtLedgEntry."Phys Invt Counting Period Code" :=
          "Phys Invt Counting Period Code";
        PhysInvtLedgEntry."Phys Invt Counting Period Type" :=
          "Phys Invt Counting Period Type";

        OnBeforeInsertPhysInvtLedgEntry(PhysInvtLedgEntry,ItemJnlLine);
        PhysInvtLedgEntry.INSERT;

        InsertItemReg(0,PhysInvtLedgEntry."Entry No.",0,0);
      end;
    END;

    LOCAL PROCEDURE PostInventoryToGL@11(VAR ValueEntry@1000 : Record "Value Entry");
    BEGIN
      with ValueEntry do begin
        if CalledFromAdjustment and not PostToGL then
          exit;
        InvtPost.SetRunOnlyCheck(true,not PostToGL,false);
        if InvtPost.BufferInvtPosting(ValueEntry) then
          InvtPost.PostInvtPostBufPerEntry(ValueEntry);

        if "Expected Cost" then begin
          SetValueEntry(ValueEntry,"Cost Amount (Expected)","Cost Amount (Expected) (ACY)",false);
          InvtPost.SetRunOnlyCheck(true,true,false);
          if InvtPost.BufferInvtPosting(ValueEntry) then
            InvtPost.PostInvtPostBufPerEntry(ValueEntry);
          SetValueEntry(ValueEntry,0,0,true);
        end else
          if ("Cost Amount (Actual)" = 0) and ("Cost Amount (Actual) (ACY)" = 0) then begin
            SetValueEntry(ValueEntry,1,1,false);
            InvtPost.SetRunOnlyCheck(true,true,false);
            if InvtPost.BufferInvtPosting(ValueEntry) then
              InvtPost.PostInvtPostBufPerEntry(ValueEntry);
            SetValueEntry(ValueEntry,0,0,false);
          end;
      end;
    END;

    LOCAL PROCEDURE SetValueEntry@65(VAR ValueEntry@1000 : Record "Value Entry";CostAmtActual@1001 : Decimal;CostAmtActACY@1002 : Decimal;ExpectedCost@1003 : Boolean);
    BEGIN
      ValueEntry."Cost Amount (Actual)" := CostAmtActual;
      ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtActACY;
      ValueEntry."Expected Cost" := ExpectedCost;
    END;

    LOCAL PROCEDURE InsertApplEntry@12(ItemLedgEntryNo@1001 : Integer;InboundItemEntry@1002 : Integer;OutboundItemEntry@1003 : Integer;TransferedFromEntryNo@1004 : Integer;PostingDate@1005 : Date;Quantity@1006 : Decimal;CostToApply@1007 : Boolean);
    VAR
      ApplItemLedgEntry@1009 : Record "Item Ledger Entry";
      OldItemApplnEntry@1008 : Record "Item Application Entry";
      ItemApplHistoryEntry@1010 : Record "Item Application Entry History";
      ItemApplnEntryExists@1000 : Boolean;
    BEGIN
      if Item.Type = Item.Type::Service then
        exit;

      if ItemApplnEntryNo = 0 then begin
        ItemApplnEntry.RESET;
        ItemApplnEntry.LOCKTABLE;
        if ItemApplnEntry.FINDLAST then begin
          ItemApplnEntryNo := ItemApplnEntry."Entry No.";
          ItemApplHistoryEntry.RESET;
          ItemApplHistoryEntry.LOCKTABLE;
          ItemApplHistoryEntry.SETCURRENTKEY("Entry No.");
          if ItemApplHistoryEntry.FINDLAST then
            if ItemApplHistoryEntry."Entry No." > ItemApplnEntryNo then
              ItemApplnEntryNo := ItemApplHistoryEntry."Entry No.";
        end
        else
          ItemApplnEntryNo := 0;
      end;

      if Quantity < 0 then begin
        OldItemApplnEntry.SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
        OldItemApplnEntry.SETRANGE("Inbound Item Entry No.",InboundItemEntry);
        OldItemApplnEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        OldItemApplnEntry.SETRANGE("Outbound Item Entry No.",OutboundItemEntry);
        if OldItemApplnEntry.FINDFIRST then begin
          ItemApplnEntry := OldItemApplnEntry;
          ItemApplnEntry.Quantity := ItemApplnEntry.Quantity + Quantity;
          ItemApplnEntry."Last Modified Date" := CURRENTDATETIME;
          ItemApplnEntry."Last Modified By User" := USERID;
          ItemApplnEntry.MODIFY;
          ItemApplnEntryExists := true;
        end;
      end;

      if not ItemApplnEntryExists then begin
        ItemApplnEntryNo := ItemApplnEntryNo + 1;
        ItemApplnEntry.INIT;
        ItemApplnEntry."Entry No." := ItemApplnEntryNo;
        ItemApplnEntry."Item Ledger Entry No." := ItemLedgEntryNo;
        ItemApplnEntry."Inbound Item Entry No." := InboundItemEntry;
        ItemApplnEntry."Outbound Item Entry No." := OutboundItemEntry;
        ItemApplnEntry."Transferred-from Entry No." := TransferedFromEntryNo;
        ItemApplnEntry.Quantity := Quantity;
        ItemApplnEntry."Posting Date" := PostingDate;
        ItemApplnEntry."Output Completely Invd. Date" := GetOutputComplInvcdDate(ItemApplnEntry);

        if AverageTransfer then begin
          if (Quantity > 0) or (ItemJnlLine."Document Type" = ItemJnlLine."Document Type"::"Transfer Receipt") then
            ItemApplnEntry."Cost Application" := true;
        end else
          case true of
            Item."Costing Method" <> Item."Costing Method"::Average,
            ItemJnlLine.Correction and (ItemJnlLine."Document Type" = ItemJnlLine."Document Type"::"Posted Assembly"):
              ItemApplnEntry."Cost Application" := true;
            ItemJnlLine.Correction:
              begin
                ApplItemLedgEntry.GET(ItemApplnEntry."Item Ledger Entry No.");
                ItemApplnEntry."Cost Application" :=
                  (ApplItemLedgEntry.Quantity > 0) or (ApplItemLedgEntry."Applies-to Entry" <> 0);
              end;
            else
              if (ItemJnlLine."Applies-to Entry" <> 0) or
                 (CostToApply and ItemJnlLine.IsInbound)
              then
                ItemApplnEntry."Cost Application" := true;
          end;

        ItemApplnEntry."Creation Date" := CURRENTDATETIME;
        ItemApplnEntry."Created By User" := USERID;
        ItemApplnEntry.INSERT(true);
      end;
    END;

    LOCAL PROCEDURE UpdateItemApplnEntry@42(ItemLedgEntryNo@1000 : Integer;PostingDate@1002 : Date);
    VAR
      ItemApplnEntry@1001 : Record "Item Application Entry";
    BEGIN
      with ItemApplnEntry do begin
        SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        SETRANGE("Output Completely Invd. Date",0D);
        if not ISEMPTY then
          MODIFYALL("Output Completely Invd. Date",PostingDate);
      end;
    END;

    LOCAL PROCEDURE GetOutputComplInvcdDate@57(ItemApplnEntry@1000 : Record "Item Application Entry") : Date;
    VAR
      OutbndItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with ItemApplnEntry do begin
        if Quantity > 0 then
          exit("Posting Date");
        if OutbndItemLedgEntry.GET("Outbound Item Entry No.") then
          if OutbndItemLedgEntry."Completely Invoiced" then
            exit(OutbndItemLedgEntry."Last Invoice Date");
      end;
    END;

    LOCAL PROCEDURE InitValueEntry@5800(VAR ValueEntry@1000 : Record "Value Entry";ItemLedgEntry@1001 : Record "Item Ledger Entry");
    VAR
      CalcUnitCost@1003 : Boolean;
      CostAmt@1004 : Decimal;
      CostAmtACY@1005 : Decimal;
    BEGIN
      ValueEntryNo := ValueEntryNo + 1;

      with ItemJnlLine do begin
        ValueEntry.INIT;
        ValueEntry."Entry No." := ValueEntryNo;
        if "Value Entry Type" = "Value Entry Type"::Variance then
          ValueEntry."Variance Type" := "Variance Type";
        ValueEntry."Item Ledger Entry No." := ItemLedgEntry."Entry No.";
        ValueEntry."Item No." := "Item No.";
        ValueEntry."Item Charge No." := "Item Charge No.";
        ValueEntry."Order Type" := ItemLedgEntry."Order Type";
        ValueEntry."Order No." := ItemLedgEntry."Order No.";
        ValueEntry."Order Line No." := ItemLedgEntry."Order Line No.";
        ValueEntry."Item Ledger Entry Type" := "Entry Type";
        ValueEntry.Type := Type;
        ValueEntry."Posting Date" := "Posting Date";
        if "Partial Revaluation" then
          ValueEntry."Partial Revaluation" := true;

        if (ItemLedgEntry.Quantity > 0) or
           (ItemLedgEntry."Invoiced Quantity" > 0) or
           (("Value Entry Type" = "Value Entry Type"::"Direct Cost") and ("Item Charge No." = '')) or
           ("Entry Type" in ["Entry Type"::Output,"Entry Type"::"Assembly Output"]) or
           Adjustment
        then
          ValueEntry.Inventoriable := Item.Type = Item.Type::Inventory;

        if ((Quantity = 0) and ("Invoiced Quantity" <> 0)) or
           ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") or
           ("Item Charge No." <> '') or Adjustment
        then begin
          GetLastDirectCostValEntry(ValueEntry."Item Ledger Entry No.");
          if ValueEntry.Inventoriable and ("Item Charge No." = '') then
            ValueEntry."Valued By Average Cost" := DirCostValueEntry."Valued By Average Cost";
        end;

        case true of
          ((Quantity = 0) and ("Invoiced Quantity" <> 0)) or
          (("Value Entry Type" = "Value Entry Type"::"Direct Cost") and ("Item Charge No." <> '')) or
          Adjustment or ("Value Entry Type" = "Value Entry Type"::Rounding):
            ValueEntry."Valuation Date" := DirCostValueEntry."Valuation Date";
          ("Value Entry Type" = "Value Entry Type"::Revaluation):
            if "Posting Date" < DirCostValueEntry."Valuation Date" then
              ValueEntry."Valuation Date" := DirCostValueEntry."Valuation Date"
            else
              ValueEntry."Valuation Date" := "Posting Date";
          (ItemLedgEntry.Quantity > 0) and ("Applies-from Entry" <> 0):
            GetAppliedFromValues(ValueEntry);
          else
            ValueEntry."Valuation Date" := "Posting Date";
        end;

        if Description = Item.Description then
          ValueEntry.Description := ''
        else
          ValueEntry.Description := Description;
        ValueEntry."Source Code" := "Source Code";
        ValueEntry."Source Type" := "Source Type";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        if ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and ("Item Charge No." = '') then
          ValueEntry."Inventory Posting Group" := "Inventory Posting Group"
        else
          ValueEntry."Inventory Posting Group" := DirCostValueEntry."Inventory Posting Group";
        ValueEntry."Source Posting Group" := "Source Posting Group";
        ValueEntry."Salespers./Purch. Code" := "Salespers./Purch. Code";
        ValueEntry."Location Code" := ItemLedgEntry."Location Code";
        ValueEntry."Variant Code" := ItemLedgEntry."Variant Code";
        ValueEntry."Journal Batch Name" := "Journal Batch Name";
        ValueEntry."User ID" := USERID;
        ValueEntry."Drop Shipment" := "Drop Shipment";
        ValueEntry."Reason Code" := "Reason Code";
        ValueEntry."Return Reason Code" := "Return Reason Code";
        ValueEntry."External Document No." := "External Document No.";
        ValueEntry."Document Date" := "Document Date";
        ValueEntry."Gen. Bus. Posting Group" := "Gen. Bus. Posting Group";
        ValueEntry."Gen. Prod. Posting Group" := "Gen. Prod. Posting Group";
        ValueEntry."Discount Amount" := "Discount Amount";
        ValueEntry."Entry Type" := "Value Entry Type";
        if "Job No." <> '' then begin
          ValueEntry."Job No." := "Job No.";
          ValueEntry."Job Task No." := "Job Task No.";
        end;
        if "Invoiced Quantity" <> 0 then begin
          ValueEntry."Valued Quantity" := "Invoiced Quantity";
          if ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and
             ("Item Charge No." = '')
          then
            if ("Entry Type" <> "Entry Type"::Output) or
               (ItemLedgEntry."Invoiced Quantity" = 0)
            then
              ValueEntry."Invoiced Quantity" := "Invoiced Quantity";
          ValueEntry."Expected Cost" := false;
        end else begin
          ValueEntry."Valued Quantity" := Quantity;
          ValueEntry."Expected Cost" := "Value Entry Type" <> "Value Entry Type"::Revaluation;
        end;

        ValueEntry."Document Type" := "Document Type";
        if ValueEntry."Expected Cost" or ("Invoice No." = '') then
          ValueEntry."Document No." := "Document No."
        else begin
          ValueEntry."Document No." := "Invoice No.";
          if "Document Type" in [
                                 "Document Type"::"Purchase Receipt","Document Type"::"Purchase Return Shipment",
                                 "Document Type"::"Sales Shipment","Document Type"::"Sales Return Receipt",
                                 "Document Type"::"Service Shipment"]
          then
            ValueEntry."Document Type" := "Document Type" + 1;
        end;
        ValueEntry."Document Line No." := "Document Line No.";

        if Adjustment then begin
          ValueEntry."Invoiced Quantity" := 0;
          ValueEntry."Applies-to Entry" := "Applies-to Value Entry";
          ValueEntry.Adjustment := true;
        end;

        if "Value Entry Type" <> "Value Entry Type"::Rounding then begin
          if ("Entry Type" = "Entry Type"::Output) and
             ("Value Entry Type" <> "Value Entry Type"::Revaluation)
          then begin
            CostAmt := Amount;
            CostAmtACY := "Amount (ACY)";
          end else begin
            ValueEntry."Cost per Unit" := RetrieveCostPerUnit;
            if GLSetup."Additional Reporting Currency" <> '' then
              ValueEntry."Cost per Unit (ACY)" := RetrieveCostPerUnitACY(ValueEntry."Cost per Unit");

            if (ValueEntry."Valued Quantity" > 0) and
               (ValueEntry."Item Ledger Entry Type" in [ValueEntry."Item Ledger Entry Type"::Purchase,
                                                        ValueEntry."Item Ledger Entry Type"::"Assembly Output"]) and
               (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost") and
               not Adjustment
            then begin
              if Item."Costing Method" = Item."Costing Method"::Standard then
                "Unit Cost" := ValueEntry."Cost per Unit";
              CalcPosShares(
                CostAmt,OverheadAmount,VarianceAmount,CostAmtACY,OverheadAmountACY,VarianceAmountACY,
                CalcUnitCost,(Item."Costing Method" = Item."Costing Method"::Standard) and
                (not ValueEntry."Expected Cost"),ValueEntry."Expected Cost");
              if (OverheadAmount <> 0) or
                 (ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") <> 0) or
                 CalcUnitCost or ValueEntry."Expected Cost"
              then begin
                ValueEntry."Cost per Unit" :=
                  CalcCostPerUnit(CostAmt,ValueEntry."Valued Quantity",false);

                if GLSetup."Additional Reporting Currency" <> '' then
                  ValueEntry."Cost per Unit (ACY)" :=
                    CalcCostPerUnit(CostAmtACY,ValueEntry."Valued Quantity",true);
              end;
            end else
              if not Adjustment then
                CalcOutboundCostAmt(ValueEntry,CostAmt,CostAmtACY)
              else begin
                CostAmt := Amount;
                CostAmtACY := "Amount (ACY)";
              end;

            if ("Invoiced Quantity" < 0) and ("Applies-to Entry" <> 0) and
               ("Entry Type" = "Entry Type"::Purchase) and ("Item Charge No." = '') and
               (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost")
            then
              CalcPurchCorrShares(OverheadAmount,OverheadAmountACY,VarianceAmount,VarianceAmountACY);
          end
        end else begin
          CostAmt := "Unit Cost";
          CostAmtACY := "Unit Cost (ACY)";
        end;

        if (ValueEntry."Entry Type" <> ValueEntry."Entry Type"::Revaluation) and not Adjustment then
          if (ValueEntry."Item Ledger Entry Type" in
              [ValueEntry."Item Ledger Entry Type"::Sale,
               ValueEntry."Item Ledger Entry Type"::"Negative Adjmt.",
               ValueEntry."Item Ledger Entry Type"::Consumption,
               ValueEntry."Item Ledger Entry Type"::"Assembly Consumption"]) or
             ((ValueEntry."Item Ledger Entry Type" = ValueEntry."Item Ledger Entry Type"::Transfer) and
              ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and ("Item Charge No." = ''))
          then begin
            ValueEntry."Valued Quantity" := -ValueEntry."Valued Quantity";
            ValueEntry."Invoiced Quantity" := -ValueEntry."Invoiced Quantity";
            if ValueEntry."Item Ledger Entry Type" = ValueEntry."Item Ledger Entry Type"::Transfer then
              ValueEntry."Discount Amount" := 0
            else
              ValueEntry."Discount Amount" := -ValueEntry."Discount Amount";

            if "Value Entry Type" <> "Value Entry Type"::Rounding then begin
              CostAmt := -CostAmt;
              CostAmtACY := -CostAmtACY;
            end;
          end;
        if not Adjustment then
          if Item."Inventory Value Zero" or
             (("Entry Type" = "Entry Type"::Transfer) and
              (ValueEntry."Valued Quantity" < 0) and not AverageTransfer) or
             (("Entry Type" = "Entry Type"::Sale) and
              ("Item Charge No." <> ''))
          then begin
            CostAmt := 0;
            CostAmtACY := 0;
            ValueEntry."Cost per Unit" := 0;
            ValueEntry."Cost per Unit (ACY)" := 0;
          end;

        case true of
          (not ValueEntry."Expected Cost") and ValueEntry.Inventoriable and
          IsInterimRevaluation:
            begin
              ValueEntry."Cost Amount (Expected)" := ROUND(CostAmt * "Applied Amount" / Amount);
              ValueEntry."Cost Amount (Expected) (ACY)" := ROUND(CostAmtACY * "Applied Amount" / Amount,
                  Currency."Amount Rounding Precision");

              CostAmt := ROUND(CostAmt);
              CostAmtACY := ROUND(CostAmtACY,Currency."Amount Rounding Precision");
              ValueEntry."Cost Amount (Actual)" := CostAmt - ValueEntry."Cost Amount (Expected)" ;
              ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtACY - ValueEntry."Cost Amount (Expected) (ACY)";
            end;
          (not ValueEntry."Expected Cost") and ValueEntry.Inventoriable:
            begin
              if not Adjustment and ("Value Entry Type" = "Value Entry Type"::"Direct Cost") then
                case "Entry Type" of
                  "Entry Type"::Sale:
                    ValueEntry."Sales Amount (Actual)" := Amount;
                  "Entry Type"::Purchase:
                    ValueEntry."Purchase Amount (Actual)" := Amount;
                end;
              ValueEntry."Cost Amount (Actual)" := CostAmt;
              ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtACY;
            end;
          ValueEntry."Expected Cost" and ValueEntry.Inventoriable:
            begin
              if not Adjustment then
                case "Entry Type" of
                  "Entry Type"::Sale:
                    ValueEntry."Sales Amount (Expected)" := Amount;
                  "Entry Type"::Purchase:
                    ValueEntry."Purchase Amount (Expected)" := Amount;
                end;
              ValueEntry."Cost Amount (Expected)" := CostAmt;
              ValueEntry."Cost Amount (Expected) (ACY)" := CostAmtACY;
            end;
          (not ValueEntry."Expected Cost") and (not ValueEntry.Inventoriable):
            if "Entry Type" = "Entry Type"::Sale then begin
              ValueEntry."Sales Amount (Actual)" := Amount;
              if Item.Type = Item.Type::Service then begin
                ValueEntry."Cost Amount (Non-Invtbl.)" := CostAmt;
                ValueEntry."Cost Amount (Non-Invtbl.)(ACY)" := CostAmtACY;
              end else begin
                ValueEntry."Cost per Unit" := 0;
                ValueEntry."Cost per Unit (ACY)" := 0;
              end;
            end else begin
              if "Entry Type" = "Entry Type"::Purchase then
                ValueEntry."Purchase Amount (Actual)" := Amount;
              ValueEntry."Cost Amount (Non-Invtbl.)" := CostAmt;
              ValueEntry."Cost Amount (Non-Invtbl.)(ACY)" := CostAmtACY;
            end;
        end;

        RoundAmtValueEntry(ValueEntry);

        OnAfterInitValueEntry(ValueEntry,ItemJnlLine);
      end;
    END;

    LOCAL PROCEDURE CalcOutboundCostAmt@99(ValueEntry@1000 : Record "Value Entry";VAR CostAmt@1001 : Decimal;VAR CostAmtACY@1002 : Decimal);
    BEGIN
      if ItemJnlLine."Item Charge No." <> '' then begin
        CostAmt := ItemJnlLine.Amount;
        if GLSetup."Additional Reporting Currency" <> '' then
          CostAmtACY := ACYMgt.CalcACYAmt(CostAmt,ValueEntry."Posting Date",false);
      end else begin
        CostAmt :=
          ValueEntry."Cost per Unit" * ValueEntry."Valued Quantity";
        CostAmtACY :=
          ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity";

        if (ValueEntry."Entry Type" = ValueEntry."Entry Type"::Revaluation) and
           (Item."Costing Method" = Item."Costing Method"::Average)
        then begin
          CostAmt += RoundingResidualAmount;
          CostAmtACY += RoundingResidualAmountACY;
        end;
      end;
    END;

    LOCAL PROCEDURE InsertValueEntry@5801(VAR ValueEntry@1000 : Record "Value Entry";VAR ItemLedgEntry@1001 : Record "Item Ledger Entry";TransferItem@1002 : Boolean);
    VAR
      InvdValueEntry@1005 : Record "Value Entry";
      InvoicedQty@1004 : Decimal;
    BEGIN
      with ItemJnlLine do begin
        if TransferItem then begin
          ValueEntry."Global Dimension 1 Code" := "New Shortcut Dimension 1 Code";
          ValueEntry."Global Dimension 2 Code" := "New Shortcut Dimension 2 Code";
          ValueEntry."Dimension Set ID" := "New Dimension Set ID";
        end else begin
          if (GlobalValueEntry."Entry Type" = GlobalValueEntry."Entry Type"::"Direct Cost") and
             (GlobalValueEntry."Item Charge No." <> '') and
             (ValueEntry."Entry Type" = ValueEntry."Entry Type"::Variance)
          then begin
            GetLastDirectCostValEntry(ValueEntry."Item Ledger Entry No.");
            ValueEntry."Gen. Prod. Posting Group" := DirCostValueEntry."Gen. Prod. Posting Group";
            MoveValEntryDimToValEntryDim(ValueEntry,DirCostValueEntry);
          end else begin
            ValueEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
            ValueEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
            ValueEntry."Dimension Set ID" := "Dimension Set ID";
          end;
        end;
        RoundAmtValueEntry(ValueEntry);

        if ValueEntry."Entry Type" = ValueEntry."Entry Type"::Rounding then begin
          ValueEntry."Valued Quantity" := ItemLedgEntry.Quantity;
          ValueEntry."Invoiced Quantity" := 0;
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Sales Amount (Actual)" := 0;
          ValueEntry."Purchase Amount (Actual)" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;
          ValueEntry."Item Ledger Entry Quantity" := 0;
        end else begin
          if IsFirstValueEntry(ValueEntry."Item Ledger Entry No.") then
            ValueEntry."Item Ledger Entry Quantity" := ValueEntry."Valued Quantity"
          else
            ValueEntry."Item Ledger Entry Quantity" := 0;
          if ValueEntry."Cost per Unit" = 0 then begin
            ValueEntry."Cost per Unit" :=
              CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",false);
            ValueEntry."Cost per Unit (ACY)" :=
              CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",true);
          end else begin
            ValueEntry."Cost per Unit" := ROUND(
                ValueEntry."Cost per Unit",GLSetup."Unit-Amount Rounding Precision");
            ValueEntry."Cost per Unit (ACY)" := ROUND(
                ValueEntry."Cost per Unit (ACY)",Currency."Unit-Amount Rounding Precision");
            if "Source Currency Code" = GLSetup."Additional Reporting Currency" then
              if ValueEntry."Expected Cost" then
                ValueEntry."Cost per Unit" :=
                  CalcCostPerUnit(ValueEntry."Cost Amount (Expected)",ValueEntry."Valued Quantity",false)
              else
                if ValueEntry."Entry Type" = ValueEntry."Entry Type"::Revaluation then
                  ValueEntry."Cost per Unit" :=
                    CalcCostPerUnit(ValueEntry."Cost Amount (Actual)" + ValueEntry."Cost Amount (Expected)",
                      ValueEntry."Valued Quantity",false)
                else
                  ValueEntry."Cost per Unit" :=
                    CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",false);
          end;
          if UpdateItemLedgEntry(ValueEntry,ItemLedgEntry) then
            ItemLedgEntry.MODIFY;
        end;

        if ((ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost") and
            (ValueEntry."Item Charge No." = '')) and
           (((Quantity = 0) and ("Invoiced Quantity" <> 0)) or
            (Adjustment and not ValueEntry."Expected Cost"))
        then begin
          if ValueEntry."Invoiced Quantity" = 0 then begin
            if InvdValueEntry.GET(ValueEntry."Applies-to Entry") then
              InvoicedQty := InvdValueEntry."Invoiced Quantity"
            else
              InvoicedQty := ValueEntry."Valued Quantity";
          end else
            InvoicedQty := ValueEntry."Invoiced Quantity";
          CalcExpectedCost(
            ValueEntry,
            ItemLedgEntry."Entry No.",
            InvoicedQty,
            ItemLedgEntry.Quantity,
            ValueEntry."Cost Amount (Expected)",
            ValueEntry."Cost Amount (Expected) (ACY)",
            ValueEntry."Sales Amount (Expected)",
            ValueEntry."Purchase Amount (Expected)",
            ItemLedgEntry.Quantity = ItemLedgEntry."Invoiced Quantity");
        end;

        OnBeforeInsertValueEntry(ValueEntry,ItemJnlLine);

        if ValueEntry.Inventoriable then
          PostInventoryToGL(ValueEntry);

        ValueEntry.INSERT;

        OnAfterInsertValueEntry(ValueEntry,ItemJnlLine);

        ItemApplnEntry.SetOutboundsNotUpdated(ItemLedgEntry);

        UpdateAdjmtProp(ValueEntry,ItemLedgEntry."Posting Date");

        InsertItemReg(0,0,ValueEntry."Entry No.",0);
        InsertPostValueEntryToGL(ValueEntry);
        if Item."Item Tracking Code" <> '' then begin
          TempValueEntryRelation.INIT;
          TempValueEntryRelation."Value Entry No." := ValueEntry."Entry No.";
          TempValueEntryRelation.INSERT;
        end;
      end;
    END;

    LOCAL PROCEDURE InsertOHValueEntry@5812(ValueEntry@1000 : Record "Value Entry";OverheadAmount@1001 : Decimal;OverheadAmountACY@1002 : Decimal);
    BEGIN
      if Item."Inventory Value Zero" then
        exit;

      ValueEntryNo := ValueEntryNo + 1;

      ValueEntry."Entry No." := ValueEntryNo;
      ValueEntry."Item Charge No." := '';
      ValueEntry."Entry Type" := ValueEntry."Entry Type"::"Indirect Cost";
      ValueEntry.Description := '';
      ValueEntry."Cost per Unit" := 0;
      ValueEntry."Cost per Unit (ACY)" := 0;
      ValueEntry."Cost Posted to G/L" := 0;
      ValueEntry."Cost Posted to G/L (ACY)" := 0;
      ValueEntry."Invoiced Quantity" := 0;
      ValueEntry."Sales Amount (Actual)" := 0;
      ValueEntry."Sales Amount (Expected)" := 0;
      ValueEntry."Purchase Amount (Actual)" := 0;
      ValueEntry."Purchase Amount (Expected)" := 0;
      ValueEntry."Discount Amount" := 0;
      ValueEntry."Cost Amount (Actual)" := OverheadAmount;
      ValueEntry."Cost Amount (Expected)" := 0;
      ValueEntry."Cost Amount (Expected) (ACY)" := 0;

      if GLSetup."Additional Reporting Currency" <> '' then
        ValueEntry."Cost Amount (Actual) (ACY)" :=
          ROUND(OverheadAmountACY,Currency."Amount Rounding Precision");

      InsertValueEntry(ValueEntry,GlobalItemLedgEntry,false);
    END;

    LOCAL PROCEDURE InsertVarValueEntry@5808(ValueEntry@1000 : Record "Value Entry";VarianceAmount@1001 : Decimal;VarianceAmountACY@1002 : Decimal);
    BEGIN
      if (not ValueEntry.Inventoriable) or Item."Inventory Value Zero" then
        exit;
      if (VarianceAmount = 0) and (VarianceAmountACY = 0) then
        exit;

      ValueEntryNo := ValueEntryNo + 1;

      ValueEntry."Entry No." := ValueEntryNo;
      ValueEntry."Item Charge No." := '';
      ValueEntry."Entry Type" := ValueEntry."Entry Type"::Variance;
      ValueEntry.Description := '';
      ValueEntry."Cost Posted to G/L" := 0;
      ValueEntry."Cost Posted to G/L (ACY)" := 0;
      ValueEntry."Invoiced Quantity" := 0;
      ValueEntry."Sales Amount (Actual)" := 0;
      ValueEntry."Sales Amount (Expected)" := 0;
      ValueEntry."Purchase Amount (Actual)" := 0;
      ValueEntry."Purchase Amount (Expected)" := 0;
      ValueEntry."Discount Amount" := 0;
      ValueEntry."Cost Amount (Actual)" := VarianceAmount;
      ValueEntry."Cost Amount (Expected)" := 0;
      ValueEntry."Cost Amount (Expected) (ACY)" := 0;
      ValueEntry."Variance Type" := ValueEntry."Variance Type"::Purchase;

      if GLSetup."Additional Reporting Currency" <> '' then begin
        if ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") =
           ROUND(-GlobalValueEntry."Cost Amount (Actual)",GLSetup."Amount Rounding Precision")
        then
          ValueEntry."Cost Amount (Actual) (ACY)" := -GlobalValueEntry."Cost Amount (Actual) (ACY)"
        else
          ValueEntry."Cost Amount (Actual) (ACY)" :=
            ROUND(VarianceAmountACY,Currency."Amount Rounding Precision");
      end;

      ValueEntry."Cost per Unit" :=
        CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",false);
      ValueEntry."Cost per Unit (ACY)" :=
        CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",true);

      InsertValueEntry(ValueEntry,GlobalItemLedgEntry,false);
    END;

    LOCAL PROCEDURE UpdateItemLedgEntry@5805(ValueEntry@1000 : Record "Value Entry";VAR ItemLedgEntry@1001 : Record "Item Ledger Entry") ModifyEntry : Boolean;
    BEGIN
      with ItemLedgEntry do
        if not (ValueEntry."Entry Type" in
                [ValueEntry."Entry Type"::Variance,
                 ValueEntry."Entry Type"::"Indirect Cost",
                 ValueEntry."Entry Type"::Rounding])
        then begin
          if ValueEntry.Inventoriable and (not ItemJnlLine.Adjustment or ("Entry Type" = "Entry Type"::"Assembly Output")) then
            UpdateAvgCostAdjmtEntryPoint(ItemLedgEntry,ValueEntry."Valuation Date");

          if (Positive or "Job Purchase") and
             (Quantity <> "Remaining Quantity") and not "Applied Entry to Adjust" and
             (Item.Type = Item.Type::Inventory) and
             (not CalledFromAdjustment or AppliedEntriesToReadjust(ItemLedgEntry))
          then begin
            "Applied Entry to Adjust" := true;
            ModifyEntry := true;
          end;

          if (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost") and
             (ItemJnlLine."Item Charge No." = '') and
             (ItemJnlLine.Quantity = 0) and (ValueEntry."Invoiced Quantity" <> 0)
          then begin
            if ValueEntry."Invoiced Quantity" <> 0 then begin
              "Invoiced Quantity" := "Invoiced Quantity" + ValueEntry."Invoiced Quantity";
              if ABS("Invoiced Quantity") > ABS(Quantity) then
                ERROR(Text030,"Entry No.");
              VerifyInvoicedQty(ItemLedgEntry);
              ModifyEntry := true;
            end;

            if ("Entry Type" <> "Entry Type"::Output) and
               ("Invoiced Quantity" = Quantity) and
               not "Completely Invoiced"
            then begin
              "Completely Invoiced" := true;
              ModifyEntry := true;
            end;

            if "Last Invoice Date" < ValueEntry."Posting Date" then begin
              "Last Invoice Date" := ValueEntry."Posting Date";
              ModifyEntry := true;
            end;
          end;
          if ItemJnlLine."Applies-from Entry" <> 0 then
            UpdateOutboundItemLedgEntry(ItemJnlLine."Applies-from Entry");
        end;

      exit(ModifyEntry);
    END;

    LOCAL PROCEDURE UpdateAvgCostAdjmtEntryPoint@5820(OldItemLedgEntry@1000 : Record "Item Ledger Entry";ValuationDate@1001 : Date);
    VAR
      AvgCostAdjmtEntryPoint@1002 : Record "Avg. Cost Adjmt. Entry Point";
      ValueEntry@1004 : Record "Value Entry";
    BEGIN
      with AvgCostAdjmtEntryPoint do begin
        ValueEntry.INIT;
        ValueEntry."Item No." := OldItemLedgEntry."Item No.";
        ValueEntry."Valuation Date" := ValuationDate;
        ValueEntry."Location Code" := OldItemLedgEntry."Location Code";
        ValueEntry."Variant Code" := OldItemLedgEntry."Variant Code";

        LOCKTABLE;
        UpdateValuationDate(ValueEntry);
      end;
    END;

    LOCAL PROCEDURE UpdateOutboundItemLedgEntry@5825(OutboundItemEntryNo@1000 : Integer);
    VAR
      OutboundItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with OutboundItemLedgEntry do begin
        GET(OutboundItemEntryNo);
        if Quantity > 0 then
          FIELDERROR(Quantity);
        if GlobalItemLedgEntry.Quantity < 0 then
          GlobalItemLedgEntry.FIELDERROR(Quantity);

        "Shipped Qty. Not Returned" := "Shipped Qty. Not Returned" + ABS(ItemJnlLine.Quantity);
        if "Shipped Qty. Not Returned" > 0 then
          FIELDERROR("Shipped Qty. Not Returned",Text004);
        "Applied Entry to Adjust" := true;
        MODIFY;
      end;
    END;

    LOCAL PROCEDURE InitTransValueEntry@5803(VAR ValueEntry@1000 : Record "Value Entry";ItemLedgEntry@1001 : Record "Item Ledger Entry");
    VAR
      AdjCostInvoicedLCY@1002 : Decimal;
      AdjCostInvoicedACY@1003 : Decimal;
      DiscountAmount@1004 : Decimal;
    BEGIN
      with GlobalValueEntry do begin
        InitValueEntry(ValueEntry,ItemLedgEntry);
        ValueEntry."Valued Quantity" := ItemLedgEntry.Quantity;
        ValueEntry."Invoiced Quantity" := ValueEntry."Valued Quantity";
        ValueEntry."Location Code" := ItemLedgEntry."Location Code";
        ValueEntry."Valuation Date" := "Valuation Date";
        if AverageTransfer then begin
          ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          ValueEntry."Cost Amount (Actual)" := -"Cost Amount (Actual)";
          ValueEntry."Cost Amount (Actual) (ACY)" := -"Cost Amount (Actual) (ACY)";
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;
          ValueEntry."Valued By Average Cost" :=
            not (ItemLedgEntry.Positive or
                 (ValueEntry."Document Type" = ValueEntry."Document Type"::"Transfer Receipt"));
        end else begin
          CalcAdjustedCost(
            OldItemLedgEntry,ValueEntry."Valued Quantity",
            AdjCostInvoicedLCY,AdjCostInvoicedACY,DiscountAmount);
          ValueEntry."Cost Amount (Actual)" := AdjCostInvoicedLCY;
          ValueEntry."Cost Amount (Actual) (ACY)" := AdjCostInvoicedACY;
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;

          "Cost Amount (Actual)" := "Cost Amount (Actual)" - ValueEntry."Cost Amount (Actual)";
          if GLSetup."Additional Reporting Currency" <> '' then
            "Cost Amount (Actual) (ACY)" :=
              CurrExchRate.ExchangeAmtLCYToFCY(
                ValueEntry."Posting Date",GLSetup."Additional Reporting Currency",
                ROUND("Cost Amount (Actual)",GLSetup."Amount Rounding Precision"),
                CurrExchRate.ExchangeRate(
                  ValueEntry."Posting Date",GLSetup."Additional Reporting Currency"));
        end;

        "Discount Amount" := 0;
        ValueEntry."Discount Amount" := 0;
        "Cost per Unit" := 0;
        "Cost per Unit (ACY)" := 0;
      end;
    END;

    LOCAL PROCEDURE ValuateAppliedAvgEntry@5807(VAR ValueEntry@1000 : Record "Value Entry";Item@1001 : Record Item);
    BEGIN
      with ValueEntry do begin
        if (ItemJnlLine."Applies-to Entry" = 0) and
           ("Item Ledger Entry Type" <> "Item Ledger Entry Type"::Output)
        then begin
          if (ItemJnlLine.Quantity = 0) and (ItemJnlLine."Invoiced Quantity" <> 0) then begin
            GetLastDirectCostValEntry("Item Ledger Entry No.");
            "Valued By Average Cost" := DirCostValueEntry."Valued By Average Cost";
          end else
            "Valued By Average Cost" := not ("Document Type" = "Document Type"::"Transfer Receipt");

          if Item."Inventory Value Zero" then begin
            "Cost per Unit" := 0;
            "Cost per Unit (ACY)" := 0;
          end else begin
            if "Item Ledger Entry Type" = "Item Ledger Entry Type"::Transfer then begin
              if SKUExists and (InvtSetup."Average Cost Calc. Type" <> InvtSetup."Average Cost Calc. Type"::Item) then
                "Cost per Unit" := SKU."Unit Cost"
              else
                "Cost per Unit" := Item."Unit Cost";
            end else
              "Cost per Unit" := ItemJnlLine."Unit Cost";

            if GLSetup."Additional Reporting Currency" <> '' then begin
              if (ItemJnlLine."Source Currency Code" = GLSetup."Additional Reporting Currency") and
                 ("Item Ledger Entry Type" <> "Item Ledger Entry Type"::Transfer)
              then
                "Cost per Unit (ACY)" := ItemJnlLine."Unit Cost (ACY)"
              else
                "Cost per Unit (ACY)" :=
                  ROUND(
                    CurrExchRate.ExchangeAmtLCYToFCY(
                      "Posting Date",GLSetup."Additional Reporting Currency","Cost per Unit",
                      CurrExchRate.ExchangeRate(
                        "Posting Date",GLSetup."Additional Reporting Currency")),
                    Currency."Unit-Amount Rounding Precision");
            end;
          end;
          if "Expected Cost" then begin
            "Cost Amount (Expected)" := "Valued Quantity" * "Cost per Unit";
            "Cost Amount (Expected) (ACY)" := "Valued Quantity" * "Cost per Unit (ACY)";
          end else begin
            "Cost Amount (Actual)" := "Valued Quantity" * "Cost per Unit";
            "Cost Amount (Actual) (ACY)" := "Valued Quantity" * "Cost per Unit (ACY)";
          end;
        end;
      end;
    END;

    LOCAL PROCEDURE CalcAdjustedCost@5804(PosItemLedgEntry@1000 : Record "Item Ledger Entry";AppliedQty@1001 : Decimal;VAR AdjustedCostLCY@1002 : Decimal;VAR AdjustedCostACY@1003 : Decimal;VAR DiscountAmount@1004 : Decimal);
    VAR
      PosValueEntry@1005 : Record "Value Entry";
    BEGIN
      AdjustedCostLCY := 0;
      AdjustedCostACY := 0;
      DiscountAmount := 0;
      with PosValueEntry do begin
        SETCURRENTKEY("Item Ledger Entry No.");
        SETRANGE("Item Ledger Entry No.",PosItemLedgEntry."Entry No.");
        FINDSET;
        repeat
          if "Partial Revaluation" then begin
            AdjustedCostLCY := AdjustedCostLCY +
              "Cost Amount (Actual)" / "Valued Quantity" * PosItemLedgEntry.Quantity;
            AdjustedCostACY := AdjustedCostACY +
              "Cost Amount (Actual) (ACY)" / "Valued Quantity" * PosItemLedgEntry.Quantity;
          end else begin
            AdjustedCostLCY := AdjustedCostLCY + "Cost Amount (Actual)" + "Cost Amount (Expected)";
            AdjustedCostACY := AdjustedCostACY + "Cost Amount (Actual) (ACY)" + "Cost Amount (Expected) (ACY)";
            DiscountAmount := DiscountAmount - "Discount Amount";
          end;
        until NEXT = 0;

        AdjustedCostLCY := AdjustedCostLCY * AppliedQty / PosItemLedgEntry.Quantity;
        AdjustedCostACY := AdjustedCostACY * AppliedQty / PosItemLedgEntry.Quantity;
        DiscountAmount := DiscountAmount * AppliedQty / PosItemLedgEntry.Quantity;
      end;
    END;

    LOCAL PROCEDURE GetMaxValuationDate@70(ItemLedgerEntry@1000 : Record "Item Ledger Entry") : Date;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Revaluation);
      if not ValueEntry.FINDLAST then begin
        ValueEntry.SETRANGE("Entry Type");
        ValueEntry.FINDLAST;
      end;
      exit(ValueEntry."Valuation Date");
    END;

    LOCAL PROCEDURE GetValuationDate@5813(VAR ValueEntry@1000 : Record "Value Entry";OldItemLedgEntry@1001 : Record "Item Ledger Entry");
    VAR
      OldValueEntry@1002 : Record "Value Entry";
    BEGIN
      with OldItemLedgEntry do begin
        OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        OldValueEntry.SETRANGE("Item Ledger Entry No.","Entry No.");
        OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::Revaluation);
        if not OldValueEntry.FINDLAST then begin
          OldValueEntry.SETRANGE("Entry Type");
          OldValueEntry.FINDLAST;
        end;
        if Positive then begin
          if (ValueEntry."Posting Date" < OldValueEntry."Valuation Date") or
             (ItemJnlLine."Applies-to Entry" <> 0)
          then begin
            ValueEntry."Valuation Date" := OldValueEntry."Valuation Date";
            SetValuationDateAllValueEntrie(
              ValueEntry."Item Ledger Entry No.",
              OldValueEntry."Valuation Date",
              ItemJnlLine."Applies-to Entry" <> 0)
          end else begin
            ValueEntry."Valuation Date" := ValueEntry."Posting Date";
            SetValuationDateAllValueEntrie(
              ValueEntry."Item Ledger Entry No.",
              ValueEntry."Posting Date",
              ItemJnlLine."Applies-to Entry" <> 0)
          end
        end else
          if OldValueEntry."Valuation Date" < ValueEntry."Valuation Date" then begin
            UpdateAvgCostAdjmtEntryPoint(OldItemLedgEntry,OldValueEntry."Valuation Date");
            OldValueEntry.MODIFYALL("Valuation Date",ValueEntry."Valuation Date");
            UpdateLinkedValuationDate(ValueEntry."Valuation Date","Entry No.",Positive);
          end;
      end;
    END;

    LOCAL PROCEDURE UpdateLinkedValuationDate@52(FromValuationDate@1000 : Date;FromItemledgEntryNo@1003 : Integer;FromInbound@1001 : Boolean);
    VAR
      ToItemApplnEntry@1004 : Record "Item Application Entry";
    BEGIN
      with ToItemApplnEntry do begin
        if FromInbound then begin
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
        end else begin
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemledgEntryNo);
        end;
        SETFILTER("Item Ledger Entry No.",'<>%1',FromItemledgEntryNo);
        if FINDSET then
          repeat
            if FromInbound or ("Inbound Item Entry No." <> 0) then begin
              GetLastDirectCostValEntry("Inbound Item Entry No.");
              if DirCostValueEntry."Valuation Date" < FromValuationDate then begin
                UpdateValuationDate(FromValuationDate,"Item Ledger Entry No.",FromInbound);
                UpdateLinkedValuationDate(FromValuationDate,"Item Ledger Entry No.",not FromInbound);
              end;
            end;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE UpdateLinkedValuationUnapply@77(FromValuationDate@1000 : Date;FromItemLedgEntryNo@1001 : Integer;FromInbound@1002 : Boolean);
    VAR
      ToItemApplnEntry@1003 : Record "Item Application Entry";
      ItemLedgerEntry@1006 : Record "Item Ledger Entry";
    BEGIN
      with ToItemApplnEntry do begin
        if FromInbound then begin
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemLedgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
        end else begin
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemLedgEntryNo);
        end;
        SETFILTER("Item Ledger Entry No.",'<>%1',FromItemLedgEntryNo);
        if FIND('-') then
          repeat
            if FromInbound or ("Inbound Item Entry No." <> 0) then begin
              GetLastDirectCostValEntry("Inbound Item Entry No.");
              if DirCostValueEntry."Valuation Date" < FromValuationDate then begin
                UpdateValuationDate(FromValuationDate,"Item Ledger Entry No.",FromInbound);
                UpdateLinkedValuationUnapply(FromValuationDate,"Item Ledger Entry No.",not FromInbound);
              end
              else begin
                ItemLedgerEntry.GET("Inbound Item Entry No.");
                FromValuationDate := GetMaxAppliedValuationdate(ItemLedgerEntry);
                if FromValuationDate < DirCostValueEntry."Valuation Date" then begin
                  UpdateValuationDate(FromValuationDate,ItemLedgerEntry."Entry No.",FromInbound);
                  UpdateLinkedValuationUnapply(FromValuationDate,ItemLedgerEntry."Entry No.",not FromInbound);
                end;
              end;
            end;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE UpdateValuationDate@79(FromValuationDate@1002 : Date;FromItemLedgEntryNo@1001 : Integer;FromInbound@1000 : Boolean);
    VAR
      ToValueEntry2@1003 : Record "Value Entry";
    BEGIN
      ToValueEntry2.SETCURRENTKEY("Item Ledger Entry No.");
      ToValueEntry2.SETRANGE("Item Ledger Entry No.",FromItemLedgEntryNo);
      ToValueEntry2.FIND('-');
      if FromInbound then begin
        if ToValueEntry2."Valuation Date" < FromValuationDate then
          ToValueEntry2.MODIFYALL("Valuation Date",FromValuationDate);
      end else
        repeat
          if ToValueEntry2."Entry Type" = ToValueEntry2."Entry Type"::Revaluation then begin
            if ToValueEntry2."Valuation Date" < FromValuationDate then begin
              ToValueEntry2."Valuation Date" := FromValuationDate;
              ToValueEntry2.MODIFY;
            end;
          end else begin
            ToValueEntry2."Valuation Date" := FromValuationDate;
            ToValueEntry2.MODIFY;
          end;
        until ToValueEntry2.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateItemJNLLinefromEntry@78(ItemLedgEntry@1000 : Record "Item Ledger Entry";NewQuantity@1002 : Decimal;VAR ItemJnlLine@1001 : Record "Item Journal Line");
    BEGIN
      CLEAR(ItemJnlLine);
      with ItemJnlLine do begin
        "Entry Type" := ItemLedgEntry."Entry Type"; // no mapping needed
        Quantity := Signed(NewQuantity);
        "Item No." := ItemLedgEntry."Item No.";
        "Serial No." := ItemLedgEntry."Serial No.";
        "Lot No." := ItemLedgEntry."Lot No.";
      end;
    END;

    LOCAL PROCEDURE GetAppliedFromValues@53(VAR ValueEntry@1000 : Record "Value Entry");
    VAR
      NegValueEntry@1002 : Record "Value Entry";
    BEGIN
      with NegValueEntry do begin
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ItemJnlLine."Applies-from Entry");
        SETRANGE("Entry Type","Entry Type"::Revaluation);
        if not FINDLAST then begin
          SETRANGE("Entry Type");
          FINDLAST;
        end;

        if "Valuation Date" > ValueEntry."Posting Date" then
          ValueEntry."Valuation Date" := "Valuation Date"
        else
          ValueEntry."Valuation Date" := ItemJnlLine."Posting Date";
      end;
    END;

    LOCAL PROCEDURE RoundAmtValueEntry@5806(VAR ValueEntry@1000 : Record "Value Entry");
    BEGIN
      with ValueEntry do begin
        "Sales Amount (Actual)" := ROUND("Sales Amount (Actual)");
        "Sales Amount (Expected)" := ROUND("Sales Amount (Expected)");
        "Purchase Amount (Actual)" := ROUND("Purchase Amount (Actual)");
        "Purchase Amount (Expected)" := ROUND("Purchase Amount (Expected)");
        "Discount Amount" := ROUND("Discount Amount");
        "Cost Amount (Actual)" := ROUND("Cost Amount (Actual)");
        "Cost Amount (Expected)" := ROUND("Cost Amount (Expected)");
        "Cost Amount (Non-Invtbl.)" := ROUND("Cost Amount (Non-Invtbl.)");
        "Cost Amount (Actual) (ACY)" := ROUND("Cost Amount (Actual) (ACY)",Currency."Amount Rounding Precision");
        "Cost Amount (Expected) (ACY)" := ROUND("Cost Amount (Expected) (ACY)",Currency."Amount Rounding Precision");
        "Cost Amount (Non-Invtbl.)(ACY)" := ROUND("Cost Amount (Non-Invtbl.)(ACY)",Currency."Amount Rounding Precision");
      end;
    END;

    LOCAL PROCEDURE RetrieveCostPerUnit@5819() : Decimal;
    BEGIN
      with ItemJnlLine do begin
        if (Item."Costing Method" = Item."Costing Method"::Standard) and
           ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and
           ("Item Charge No." = '') and
           ("Applies-from Entry" = 0) and
           not Adjustment
        then begin
          if SKUExists then
            exit(SKU."Unit Cost");
          exit(Item."Unit Cost");
        end;
        exit("Unit Cost");
      end;
    END;

    LOCAL PROCEDURE RetrieveCostPerUnitACY@5824(CostPerUnit@1000 : Decimal) : Decimal;
    VAR
      ItemLedgerEntry@1003 : Record "Item Ledger Entry";
      PostingDate@1001 : Date;
    BEGIN
      with ItemJnlLine do begin
        if Adjustment or ("Source Currency Code" = GLSetup."Additional Reporting Currency") and
           ((Item."Costing Method" <> Item."Costing Method"::Standard) or
            (("Discount Amount" = 0) and ("Indirect Cost %" = 0) and ("Overhead Rate" = 0)))
        then
          exit("Unit Cost (ACY)");
        if ("Value Entry Type" = "Value Entry Type"::Revaluation) and ItemLedgerEntry.GET("Applies-to Entry") then
          PostingDate := ItemLedgerEntry."Posting Date"
        else
          PostingDate := "Posting Date";
        exit(ROUND(CurrExchRate.ExchangeAmtLCYToFCY(
              PostingDate,GLSetup."Additional Reporting Currency",
              CostPerUnit,CurrExchRate.ExchangeRate(
                PostingDate,GLSetup."Additional Reporting Currency")),
            Currency."Unit-Amount Rounding Precision"));
      end;
    END;

    LOCAL PROCEDURE CalcCostPerUnit@5815(Cost@1000 : Decimal;Quantity@1001 : Decimal;IsACY@1002 : Boolean) : Decimal;
    VAR
      RndgPrec@1003 : Decimal;
    BEGIN
      GetGLSetup;

      if IsACY then
        RndgPrec := Currency."Unit-Amount Rounding Precision"
      else
        RndgPrec := GLSetup."Unit-Amount Rounding Precision";

      if Quantity <> 0 then
        exit(ROUND(Cost / Quantity,RndgPrec));
      exit(0);
    END;

    LOCAL PROCEDURE CalcPosShares@5823(VAR DirCost@1000 : Decimal;VAR OvhdCost@1001 : Decimal;VAR PurchVar@1002 : Decimal;VAR DirCostACY@1008 : Decimal;VAR OvhdCostACY@1003 : Decimal;VAR PurchVarACY@1004 : Decimal;VAR CalcUnitCost@1005 : Boolean;CalcPurchVar@1006 : Boolean;Expected@1007 : Boolean);
    VAR
      CostCalcMgt@1009 : Codeunit "Cost Calculation Management";
    BEGIN
      with ItemJnlLine do begin
        if Expected then begin
          DirCost := "Unit Cost" * Quantity;
          PurchVar := 0;
          PurchVarACY := 0;
          OvhdCost := 0;
          OvhdCostACY := 0;
        end else begin
          OvhdCost :=
            ROUND(
              CostCalcMgt.CalcOvhdCost(
                Amount,"Indirect Cost %","Overhead Rate","Invoiced Quantity"),
              GLSetup."Amount Rounding Precision");
          DirCost := Amount;
          if CalcPurchVar then
            PurchVar := "Unit Cost" * "Invoiced Quantity" - DirCost - OvhdCost
          else begin
            PurchVar := 0;
            PurchVarACY := 0;
          end;
        end;

        if GLSetup."Additional Reporting Currency" <> '' then begin
          DirCostACY := ACYMgt.CalcACYAmt(DirCost,"Posting Date",false);
          OvhdCostACY := ACYMgt.CalcACYAmt(OvhdCost,"Posting Date",false);
          "Unit Cost (ACY)" :=
            ROUND(
              CurrExchRate.ExchangeAmtLCYToFCY(
                "Posting Date",GLSetup."Additional Reporting Currency","Unit Cost",
                CurrExchRate.ExchangeRate(
                  "Posting Date",GLSetup."Additional Reporting Currency")),
              Currency."Unit-Amount Rounding Precision");
          PurchVarACY := "Unit Cost (ACY)" * "Invoiced Quantity" - DirCostACY - OvhdCostACY;
        end;
        CalcUnitCost := (DirCost <> 0) and ("Unit Cost" = 0);
      end;
    END;

    LOCAL PROCEDURE CalcPurchCorrShares@5826(VAR OverheadAmount@1001 : Decimal;VAR OverheadAmountACY@1002 : Decimal;VAR VarianceAmount@1003 : Decimal;VAR VarianceAmountACY@1004 : Decimal);
    VAR
      OldItemLedgEntry@1000 : Record "Item Ledger Entry";
      OldValueEntry@1005 : Record "Value Entry";
      CostAmt@1007 : Decimal;
      CostAmtACY@1006 : Decimal;
    BEGIN
      with ItemJnlLine do begin
        OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        OldValueEntry.SETRANGE("Item Ledger Entry No.","Applies-to Entry");
        OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::"Indirect Cost");
        if OldValueEntry.FINDSET then
          repeat
            if not OldValueEntry."Partial Revaluation" then begin
              CostAmt := CostAmt + OldValueEntry."Cost Amount (Actual)";
              CostAmtACY := CostAmtACY + OldValueEntry."Cost Amount (Actual) (ACY)";
            end;
          until OldValueEntry.NEXT = 0;
        if (CostAmt <> 0) or (CostAmtACY <> 0) then begin
          OldItemLedgEntry.GET("Applies-to Entry");
          OverheadAmount := ROUND(
              CostAmt / OldItemLedgEntry."Invoiced Quantity" * "Invoiced Quantity",
              GLSetup."Amount Rounding Precision");
          OverheadAmountACY := ROUND(
              CostAmtACY / OldItemLedgEntry."Invoiced Quantity" * "Invoiced Quantity",
              Currency."Unit-Amount Rounding Precision");
          if Item."Costing Method" = Item."Costing Method"::Standard then begin
            VarianceAmount := -OverheadAmount;
            VarianceAmountACY := -OverheadAmountACY;
          end else begin
            VarianceAmount := 0;
            VarianceAmountACY := 0;
          end;
        end else
          if Item."Costing Method" = Item."Costing Method"::Standard then begin
            OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::Variance);
            VarianceRequired := OldValueEntry.FINDFIRST;
          end;
      end;
    END;

    LOCAL PROCEDURE GetLastDirectCostValEntry@5817(ItemLedgEntryNo@1000 : Decimal);
    VAR
      Found@1001 : Boolean;
    BEGIN
      if ItemLedgEntryNo = DirCostValueEntry."Item Ledger Entry No." then
        exit;
      DirCostValueEntry.RESET;
      DirCostValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      DirCostValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
      DirCostValueEntry.SETRANGE("Entry Type",DirCostValueEntry."Entry Type"::"Direct Cost");
      DirCostValueEntry.SETFILTER("Item Charge No.",'%1','');
      Found := DirCostValueEntry.FINDLAST;
      DirCostValueEntry.SETRANGE("Item Charge No.");
      if not Found then
        DirCostValueEntry.FINDLAST;
    END;

    LOCAL PROCEDURE IsFirstValueEntry@54(ItemLedgEntryNo@1001 : Integer) : Boolean;
    VAR
      ValueEntry@1000 : Record "Value Entry";
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
      exit(ValueEntry.ISEMPTY);
    END;

    LOCAL PROCEDURE CalcExpectedCost@60(VAR InvdValueEntry@1009 : Record "Value Entry";ItemLedgEntryNo@1003 : Integer;InvoicedQty@1006 : Decimal;Quantity@1005 : Decimal;VAR ExpectedCost@1001 : Decimal;VAR ExpectedCostACY@1002 : Decimal;VAR ExpectedSalesAmt@1007 : Decimal;VAR ExpectedPurchAmt@1008 : Decimal;CalcReminder@1004 : Boolean);
    VAR
      ValueEntry@1000 : Record "Value Entry";
    BEGIN
      ExpectedCost := 0;
      ExpectedCostACY := 0;
      ExpectedSalesAmt := 0;
      ExpectedPurchAmt := 0;

      with ValueEntry do begin
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        SETFILTER("Entry Type",'<>%1',"Entry Type"::Revaluation);
        if FINDSET and "Expected Cost" then
          if CalcReminder then begin
            CALCSUMS(
              "Cost Amount (Expected)","Cost Amount (Expected) (ACY)",
              "Sales Amount (Expected)","Purchase Amount (Expected)");
            ExpectedCost := -"Cost Amount (Expected)";
            ExpectedCostACY := -"Cost Amount (Expected) (ACY)";
            if not CalledFromAdjustment then begin
              ExpectedSalesAmt := -"Sales Amount (Expected)";
              ExpectedPurchAmt := -"Purchase Amount (Expected)";
            end
          end else
            if InvdValueEntry.Adjustment and
               (InvdValueEntry."Entry Type" = InvdValueEntry."Entry Type"::"Direct Cost")
            then begin
              ExpectedCost := -InvdValueEntry."Cost Amount (Actual)";
              ExpectedCostACY := -InvdValueEntry."Cost Amount (Actual) (ACY)";
              if not CalledFromAdjustment then begin
                ExpectedSalesAmt := -InvdValueEntry."Sales Amount (Actual)";
                ExpectedPurchAmt := -InvdValueEntry."Purchase Amount (Actual)";
              end
            end else begin
              repeat
                if "Expected Cost" and not Adjustment then begin
                  ExpectedCost := ExpectedCost + "Cost Amount (Expected)";
                  ExpectedCostACY := ExpectedCostACY + "Cost Amount (Expected) (ACY)";
                  if not CalledFromAdjustment then begin
                    ExpectedSalesAmt := ExpectedSalesAmt + "Sales Amount (Expected)";
                    ExpectedPurchAmt := ExpectedPurchAmt + "Purchase Amount (Expected)";
                  end;
                end;
              until NEXT = 0;
              ExpectedCost :=
                CalcExpCostToBalance(ExpectedCost,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
              ExpectedCostACY :=
                CalcExpCostToBalance(ExpectedCostACY,InvoicedQty,Quantity,Currency."Amount Rounding Precision");
              if not CalledFromAdjustment then begin
                ExpectedSalesAmt :=
                  CalcExpCostToBalance(ExpectedSalesAmt,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
                ExpectedPurchAmt :=
                  CalcExpCostToBalance(ExpectedPurchAmt,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
              end;
            end;
      end;
    END;

    LOCAL PROCEDURE CalcExpCostToBalance@55(ExpectedCost@1000 : Decimal;InvoicedQty@1001 : Decimal;Quantity@1002 : Decimal;RoundPrecision@1003 : Decimal) : Decimal;
    BEGIN
      exit(-ROUND(InvoicedQty / Quantity * ExpectedCost,RoundPrecision));
    END;

    LOCAL PROCEDURE MoveValEntryDimToValEntryDim@5818(VAR ToValueEntry@1000 : Record "Value Entry";FromValueEntry@1001 : Record "Value Entry");
    BEGIN
      ToValueEntry."Global Dimension 1 Code" := FromValueEntry."Global Dimension 1 Code";
      ToValueEntry."Global Dimension 2 Code" := FromValueEntry."Global Dimension 2 Code";
      ToValueEntry."Dimension Set ID" := FromValueEntry."Dimension Set ID";
    END;

    LOCAL PROCEDURE AutoTrack@5850(VAR ItemLedgEntryRec@1000 : Record "Item Ledger Entry";IsReserved@1002 : Boolean);
    VAR
      ReservMgt@1001 : Codeunit "Reservation Management";
    BEGIN
      if Item."Order Tracking Policy" = Item."Order Tracking Policy"::None then begin
        if not IsReserved then
          exit;

        // Ensure that Item Tracking is not left on the item ledger entry:
        ReservMgt.SetItemLedgEntry(ItemLedgEntryRec);
        ReservMgt.SetItemTrackingHandling(1);
        ReservMgt.ClearSurplus;
        exit;
      end;

      ReservMgt.SetItemLedgEntry(ItemLedgEntryRec);
      ReservMgt.SetItemTrackingHandling(1);
      ReservMgt.DeleteReservEntries(false,ItemLedgEntryRec."Remaining Quantity");
      ReservMgt.ClearSurplus;
      ReservMgt.AutoTrack(ItemLedgEntryRec."Remaining Quantity");
    END;

    [External]
    PROCEDURE SetPostponeReservationHandling@2(Postpone@1000 : Boolean);
    BEGIN
      // Used when posting Transfer Order receipts
      PostponeReservationHandling := Postpone;
    END;

    LOCAL PROCEDURE SetupSplitJnlLine@20(VAR ItemJnlLine2@1000 : Record "Item Journal Line";TrackingSpecExists@1001 : Boolean) : Boolean;
    VAR
      LateBindingMgt@1013 : Codeunit "Late Binding Management";
      NonDistrQuantity@1006 : Decimal;
      NonDistrAmount@1012 : Decimal;
      NonDistrAmountACY@1011 : Decimal;
      NonDistrDiscountAmount@1005 : Decimal;
      SignFactor@1002 : Integer;
      CalcWarrantyDate@1014 : Date;
      CalcExpirationDate@1015 : Date;
      Invoice@1004 : Boolean;
      SNInfoRequired@1008 : Boolean;
      LotInfoRequired@1009 : Boolean;
      ExpirationDateChecked@1016 : Boolean;
      PostItemJnlLine@1003 : Boolean;
    BEGIN
      ItemJnlLineOrigin := ItemJnlLine2;
      TempSplitItemJnlLine.RESET;
      TempSplitItemJnlLine.DELETEALL;

      DisableItemTracking := not ItemJnlLine2.ItemPosting;
      Invoice := ItemJnlLine2."Invoiced Qty. (Base)" <> 0;

      if (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) and
         PostponeReservationHandling
      then
        SignFactor := 1
      else
        SignFactor := ItemJnlLine2.Signed(1);

      ItemTrackingCode.Code := Item."Item Tracking Code";
      ItemTrackingMgt.GetItemTrackingSettings(
        ItemTrackingCode,ItemJnlLine."Entry Type",ItemJnlLine.Signed(ItemJnlLine."Quantity (Base)") > 0,
        SNRequired,LotRequired,SNInfoRequired,LotInfoRequired);

      if Item."Costing Method" = Item."Costing Method"::Specific then begin
        Item.TESTFIELD("Item Tracking Code");
        ItemTrackingCode.TESTFIELD("SN Specific Tracking",true);
      end;

      if not ItemJnlLine2.Correction and (ItemJnlLine2."Quantity (Base)" <> 0) and TrackingSpecExists then begin
        if DisableItemTracking then begin
          if not TempTrackingSpecification.ISEMPTY then
            ERROR(Text021,ItemJnlLine2.FIELDCAPTION("Operation No."),ItemJnlLine2."Operation No.");
        end else begin
          if TempTrackingSpecification.ISEMPTY then
            ERROR(Text100);

          ItemJnlLine2.TESTFIELD("Serial No.",'');
          ItemJnlLine2.TESTFIELD("Lot No.",'');
          ItemJnlLine2.TESTFIELD("New Serial No.",'');
          ItemJnlLine2.TESTFIELD("New Lot No.",'');

          if FORMAT(ItemTrackingCode."Warranty Date Formula") <> '' then
            CalcWarrantyDate := CALCDATE(ItemTrackingCode."Warranty Date Formula",ItemJnlLine2."Document Date");
          if FORMAT(Item."Expiration Calculation") <> '' then
            CalcExpirationDate := CALCDATE(Item."Expiration Calculation",ItemJnlLine2."Document Date");

          if SignFactor * ItemJnlLine2.Quantity < 0 then // Demand
            if ItemTrackingCode."SN Specific Tracking" or ItemTrackingCode."Lot Specific Tracking" then
              LateBindingMgt.ReallocateTrkgSpecification(TempTrackingSpecification);

          TempTrackingSpecification.CALCSUMS(
            "Qty. to Handle (Base)","Qty. to Invoice (Base)","Qty. to Handle","Qty. to Invoice");
          TempTrackingSpecification.TestFieldError(TempTrackingSpecification.FIELDCAPTION("Qty. to Handle (Base)"),
            TempTrackingSpecification."Qty. to Handle (Base)",SignFactor * ItemJnlLine2."Quantity (Base)");

          if Invoice then
            TempTrackingSpecification.TestFieldError(TempTrackingSpecification.FIELDCAPTION("Qty. to Invoice (Base)"),
              TempTrackingSpecification."Qty. to Invoice (Base)",SignFactor * ItemJnlLine2."Invoiced Qty. (Base)");

          NonDistrQuantity := ItemJnlLine2.Quantity;
          NonDistrAmount := ItemJnlLine2.Amount;
          NonDistrAmountACY := ItemJnlLine2."Amount (ACY)";
          NonDistrDiscountAmount := ItemJnlLine2."Discount Amount";

          TempTrackingSpecification.FINDSET;
          repeat
            if ItemTrackingCode."Man. Warranty Date Entry Reqd." then
              TempTrackingSpecification.TESTFIELD("Warranty Date");

            CheckExpirationDate(ItemJnlLine2,SignFactor,CalcExpirationDate,ExpirationDateChecked);
            CheckItemTrackingInfo(ItemJnlLine2,TempTrackingSpecification,SNInfoRequired,LotInfoRequired);

            if TempTrackingSpecification."Warranty Date" = 0D then
              TempTrackingSpecification."Warranty Date" := CalcWarrantyDate;

            TempTrackingSpecification.MODIFY;
            TempSplitItemJnlLine := ItemJnlLine2;
            PostItemJnlLine :=
              PostItemJnlLine or
              SetupTempSplitItemJnlLine(
                ItemJnlLine2,SignFactor,NonDistrQuantity,NonDistrAmount,
                NonDistrAmountACY,NonDistrDiscountAmount,Invoice);
          until TempTrackingSpecification.NEXT = 0;
        end;
      end else begin
        TempSplitItemJnlLine := ItemJnlLine2;
        TempSplitItemJnlLine.INSERT;
      end;

      exit(PostItemJnlLine);
    END;

    LOCAL PROCEDURE SplitJnlLine@15(VAR ItemJnlLine2@1000 : Record "Item Journal Line";PostItemJnlLine@1003 : Boolean) : Boolean;
    VAR
      FreeEntryNo@1005 : Integer;
      JnlLineNo@1001 : Integer;
      SignFactor@1002 : Integer;
    BEGIN
      if (ItemJnlLine2."Quantity (Base)" <> 0) and ItemJnlLine2.TrackingExists then begin
        if (ItemJnlLine2."Entry Type" in
            [ItemJnlLine2."Entry Type"::Sale,
             ItemJnlLine2."Entry Type"::"Negative Adjmt.",
             ItemJnlLine2."Entry Type"::Consumption,
             ItemJnlLine2."Entry Type"::"Assembly Consumption"]) or
           ((ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) and
            not PostponeReservationHandling)
        then
          SignFactor := -1
        else
          SignFactor := 1;

        TempTrackingSpecification.SETRANGE("Serial No.",ItemJnlLine2."Serial No.");
        TempTrackingSpecification.SETRANGE("Lot No.",ItemJnlLine2."Lot No.");
        if TempTrackingSpecification.FINDFIRST then begin
          FreeEntryNo := TempTrackingSpecification."Entry No.";
          TempTrackingSpecification.DELETE;
          ItemJnlLine2.TESTFIELD("Serial No.",TempTrackingSpecification."Serial No.");
          ItemJnlLine2.TESTFIELD("Lot No.",TempTrackingSpecification."Lot No.");
          TempTrackingSpecification."Quantity (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity Handled (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity actual Handled (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity Invoiced (Base)" := SignFactor * ItemJnlLine2."Invoiced Qty. (Base)";
          TempTrackingSpecification."Qty. to Invoice (Base)" :=
            SignFactor * (ItemJnlLine2."Quantity (Base)" - ItemJnlLine2."Invoiced Qty. (Base)");
          TempTrackingSpecification."Qty. to Handle (Base)" := 0;
          TempTrackingSpecification."Qty. to Handle" := 0;
          TempTrackingSpecification."Qty. to Invoice" :=
            SignFactor * (ItemJnlLine2.Quantity - ItemJnlLine2."Invoiced Quantity");
          TempTrackingSpecification."Item Ledger Entry No." := GlobalItemLedgEntry."Entry No.";
          TempTrackingSpecification."Transfer Item Entry No." := TempItemEntryRelation."Item Entry No.";
          if PostItemJnlLine then
            TempTrackingSpecification."Entry No." := TempTrackingSpecification."Item Ledger Entry No.";
          InsertTempTrkgSpecification(FreeEntryNo);
        end else
          if (ItemJnlLine2."Item Charge No." = '') and (ItemJnlLine2."Job No." = '') then
            if not ItemJnlLine2.Correction then // Undo quantity posting.
              ERROR(Text011);
      end;

      if TempSplitItemJnlLine.FINDFIRST then begin
        JnlLineNo := ItemJnlLine2."Line No.";
        ItemJnlLine2 := TempSplitItemJnlLine;
        ItemJnlLine2."Line No." := JnlLineNo;
        TempSplitItemJnlLine.DELETE;
        exit(true);
      end;
      if ItemJnlLine."Phys. Inventory" then
        InsertPhysInventoryEntry;
      exit(false);
    END;

    [External]
    PROCEDURE CollectTrackingSpecification@16(VAR TargetTrackingSpecification@1001 : TEMPORARY Record "Tracking Specification") : Boolean;
    BEGIN
      TempTrackingSpecification.RESET;
      TargetTrackingSpecification.RESET;
      TargetTrackingSpecification.DELETEALL;

      if TempTrackingSpecification.FINDSET then
        repeat
          TargetTrackingSpecification := TempTrackingSpecification;
          TargetTrackingSpecification.INSERT;
        until TempTrackingSpecification.NEXT = 0
      else
        exit(false);

      TempTrackingSpecification.DELETEALL;

      exit(true);
    END;

    [External]
    PROCEDURE CollectValueEntryRelation@10(VAR TargetValueEntryRelation@1001 : TEMPORARY Record "Value Entry Relation";RowId@1002 : Text[250]) : Boolean;
    BEGIN
      TempValueEntryRelation.RESET;
      TargetValueEntryRelation.RESET;

      if TempValueEntryRelation.FINDSET then
        repeat
          TargetValueEntryRelation := TempValueEntryRelation;
          TargetValueEntryRelation."Source RowId" := RowId;
          TargetValueEntryRelation.INSERT;
        until TempValueEntryRelation.NEXT = 0
      else
        exit(false);

      TempValueEntryRelation.DELETEALL;

      exit(true);
    END;

    [External]
    PROCEDURE CollectItemEntryRelation@19(VAR TargetItemEntryRelation@1001 : TEMPORARY Record "Item Entry Relation") : Boolean;
    BEGIN
      TempItemEntryRelation.RESET;
      TargetItemEntryRelation.RESET;

      if TempItemEntryRelation.FINDSET then
        repeat
          TargetItemEntryRelation := TempItemEntryRelation;
          TargetItemEntryRelation.INSERT;
        until TempItemEntryRelation.NEXT = 0
      else
        exit(false);

      TempItemEntryRelation.DELETEALL;

      exit(true);
    END;

    LOCAL PROCEDURE CheckExpirationDate@80(VAR ItemJnlLine2@1002 : Record "Item Journal Line";SignFactor@1004 : Integer;CalcExpirationDate@1003 : Date;VAR ExpirationDateChecked@1007 : Boolean);
    VAR
      ExistingExpirationDate@1000 : Date;
      EntriesExist@1001 : Boolean;
      SumOfEntries@1005 : Decimal;
      SumLot@1006 : Decimal;
    BEGIN
      ExistingExpirationDate :=
        ItemTrackingMgt.ExistingExpirationDate(
          TempTrackingSpecification."Item No.",
          TempTrackingSpecification."Variant Code",
          TempTrackingSpecification."Lot No.",
          TempTrackingSpecification."Serial No.",
          true,
          EntriesExist);

      if not (EntriesExist or ExpirationDateChecked) then begin
        ItemTrackingMgt.TestExpDateOnTrackingSpec(TempTrackingSpecification);
        ExpirationDateChecked := true;
      end;
      if ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer then
        if TempTrackingSpecification."Expiration Date" = 0D then
          TempTrackingSpecification."Expiration Date" := ExistingExpirationDate;

      // Supply
      if SignFactor * ItemJnlLine2.Quantity > 0 then begin        // Only expiration dates on supply.
        if not (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) then
          if ItemTrackingCode."Man. Expir. Date Entry Reqd." then
            if not TempTrackingSpecification.Correction then
              TempTrackingSpecification.TESTFIELD("Expiration Date");

        if CalcExpirationDate <> 0D then
          if ExistingExpirationDate <> 0D then
            CalcExpirationDate := ExistingExpirationDate;

        if ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer then
          if TempTrackingSpecification."New Expiration Date" = 0D then
            TempTrackingSpecification."New Expiration Date" := ExistingExpirationDate;

        if TempTrackingSpecification."Expiration Date" = 0D then
          TempTrackingSpecification."Expiration Date" := CalcExpirationDate;

        if EntriesExist then
          TempTrackingSpecification.TESTFIELD("Expiration Date",ExistingExpirationDate);
      end else begin  // Demand
        if ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer then begin
          ExistingExpirationDate :=
            ItemTrackingMgt.ExistingExpirationDateAndQty(
              TempTrackingSpecification."Item No.",
              TempTrackingSpecification."Variant Code",
              TempTrackingSpecification."New Lot No.",
              TempTrackingSpecification."New Serial No.",
              SumOfEntries);

          if (ItemJnlLine2."Order Type" = ItemJnlLine2."Order Type"::Transfer) and
             (ItemJnlLine2."Order No." <> '')
          then
            if TempTrackingSpecification."New Expiration Date" = 0D then
              TempTrackingSpecification."New Expiration Date" := ExistingExpirationDate;

          if (TempTrackingSpecification."New Lot No." <> '') and
             ((ItemJnlLine2."Order Type" <> ItemJnlLine2."Order Type"::Transfer) or
              (ItemJnlLine2."Order No." = ''))
          then begin
            if TempTrackingSpecification."New Serial No." <> '' then
              SumLot := SignFactor * ItemTrackingMgt.SumNewLotOnTrackingSpec(TempTrackingSpecification)
            else
              SumLot := SignFactor * TempTrackingSpecification."Quantity (Base)";
            if (SumOfEntries > 0) and
               ((SumOfEntries <> SumLot) or (TempTrackingSpecification."New Lot No." <> TempTrackingSpecification."Lot No."))
            then
              TempTrackingSpecification.TESTFIELD("New Expiration Date",ExistingExpirationDate);
            ItemTrackingMgt.TestExpDateOnTrackingSpecNew(TempTrackingSpecification);
          end;
        end;
      end;

      if (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) and
         ((ItemJnlLine2."Order Type" <> ItemJnlLine2."Order Type"::Transfer) or
          (ItemJnlLine2."Order No." = ''))
      then
        if ItemTrackingCode."Man. Expir. Date Entry Reqd." then
          TempTrackingSpecification.TESTFIELD("New Expiration Date");
    END;

    LOCAL PROCEDURE GetGLSetup@14();
    BEGIN
      if not GLSetupRead then begin
        GLSetup.GET;
        if GLSetup."Additional Reporting Currency" <> '' then begin
          Currency.GET(GLSetup."Additional Reporting Currency");
          Currency.TESTFIELD("Unit-Amount Rounding Precision");
          Currency.TESTFIELD("Amount Rounding Precision");
        end;
      end;
      GLSetupRead := true;
    END;

    LOCAL PROCEDURE GetMfgSetup@35();
    BEGIN
      if not MfgSetupRead then
        MfgSetup.GET;
      MfgSetupRead := true;
    END;

    LOCAL PROCEDURE GetInvtSetup@36();
    BEGIN
      if not InvtSetupRead then begin
        InvtSetup.GET;
        SourceCodeSetup.GET;
      end;
      InvtSetupRead := true;
    END;

    LOCAL PROCEDURE UndoQuantityPosting@18();
    VAR
      OldItemLedgEntry@1001 : Record "Item Ledger Entry";
      OldItemLedgEntry2@1004 : Record "Item Ledger Entry";
      NewItemLedgEntry@1002 : Record "Item Ledger Entry";
      OldValueEntry@1003 : Record "Value Entry";
      NewValueEntry@1000 : Record "Value Entry";
      IsReserved@1006 : Boolean;
    BEGIN
      if ItemJnlLine."Entry Type" in [ItemJnlLine."Entry Type"::"Assembly Consumption",
                                      ItemJnlLine."Entry Type"::"Assembly Output"]
      then
        exit;

      if ItemJnlLine."Applies-to Entry" <> 0 then begin
        OldItemLedgEntry.GET(ItemJnlLine."Applies-to Entry");
        if not OldItemLedgEntry.Positive then
          ItemJnlLine."Applies-from Entry" := ItemJnlLine."Applies-to Entry";
      end else
        OldItemLedgEntry.GET(ItemJnlLine."Applies-from Entry");

      if Item.GET(OldItemLedgEntry."Item No.") then begin
        Item.TESTFIELD(Blocked,false);
        Item.CheckBlockedByApplWorksheet;
      end;

      ItemJnlLine."Item No." := OldItemLedgEntry."Item No.";

      InitCorrItemLedgEntry(OldItemLedgEntry,NewItemLedgEntry);

      if Item.Type = Item.Type::Service then begin
        NewItemLedgEntry."Remaining Quantity" := 0;
        NewItemLedgEntry.Open := false;
      end;

      InsertItemReg(NewItemLedgEntry."Entry No.",0,0,0);
      GlobalItemLedgEntry := NewItemLedgEntry;

      CalcILEExpectedAmount(OldValueEntry,OldItemLedgEntry."Entry No.");
      if OldItemLedgEntry."Invoiced Quantity" = 0 then begin
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,OldItemLedgEntry,OldValueEntry."Document Line No.",1,
          0,OldItemLedgEntry.Quantity);
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,NewItemLedgEntry,ItemJnlLine."Document Line No.",-1,
          NewItemLedgEntry.Quantity,0);
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,NewItemLedgEntry,ItemJnlLine."Document Line No.",-1,
          0,NewItemLedgEntry.Quantity);
      end else
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,NewItemLedgEntry,ItemJnlLine."Document Line No.",-1,
          NewItemLedgEntry.Quantity,NewItemLedgEntry.Quantity);

      UpdateOldItemLedgEntry(OldItemLedgEntry,NewItemLedgEntry."Posting Date");
      UpdateItemApplnEntry(OldItemLedgEntry."Entry No.",NewItemLedgEntry."Posting Date");

      if GlobalItemLedgEntry.Quantity > 0 then
        IsReserved :=
          ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(
            ItemJnlLine,GlobalItemLedgEntry,ItemJnlLine."Quantity (Base)",true);

      if not ItemJnlLine.IsATOCorrection then begin
        ApplyItemLedgEntry(NewItemLedgEntry,OldItemLedgEntry2,NewValueEntry,false);
        AutoTrack(NewItemLedgEntry,IsReserved);
      end;

      NewItemLedgEntry.MODIFY;
      UpdateAdjmtProp(NewValueEntry,NewItemLedgEntry."Posting Date");

      if NewItemLedgEntry.Positive then begin
        UpdateOrigAppliedFromEntry(OldItemLedgEntry."Entry No.");
        InsertApplEntry(
          NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",
          OldItemLedgEntry."Entry No.",0,NewItemLedgEntry."Posting Date",
          -OldItemLedgEntry.Quantity,false);
      end;
    END;

    PROCEDURE UndoValuePostingWithJob@138(OldItemLedgEntryNo@1008 : Integer;NewItemLedgEntryNo@1007 : Integer);
    VAR
      OldItemLedgEntry@1001 : Record "Item Ledger Entry";
      NewItemLedgEntry@1002 : Record "Item Ledger Entry";
      OldValueEntry@1003 : Record "Value Entry";
      NewValueEntry@1000 : Record "Value Entry";
    BEGIN
      OldItemLedgEntry.GET(OldItemLedgEntryNo);
      NewItemLedgEntry.GET(NewItemLedgEntryNo);
      InitValueEntryNo;

      if OldItemLedgEntry."Invoiced Quantity" = 0 then begin
        CalcILEExpectedAmount(OldValueEntry,OldItemLedgEntry."Entry No.");
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,OldItemLedgEntry,OldValueEntry."Document Line No.",1,
          0,OldItemLedgEntry.Quantity);

        CalcILEExpectedAmount(OldValueEntry,NewItemLedgEntry."Entry No.");
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,NewItemLedgEntry,NewItemLedgEntry."Document Line No.",1,
          0,NewItemLedgEntry.Quantity);
      end else
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,NewItemLedgEntry,NewItemLedgEntry."Document Line No.",-1,
          NewItemLedgEntry.Quantity,NewItemLedgEntry.Quantity);

      UpdateOldItemLedgEntry(OldItemLedgEntry,NewItemLedgEntry."Posting Date");
      UpdateOldItemLedgEntry(NewItemLedgEntry,NewItemLedgEntry."Posting Date");
      UpdateItemApplnEntry(OldItemLedgEntry."Entry No.",NewItemLedgEntry."Posting Date");

      NewItemLedgEntry.MODIFY;
      UpdateAdjmtProp(NewValueEntry,NewItemLedgEntry."Posting Date");

      if NewItemLedgEntry.Positive then
        UpdateOrigAppliedFromEntry(OldItemLedgEntry."Entry No.");
    END;

    LOCAL PROCEDURE InitCorrItemLedgEntry@37(OldItemLedgEntry@1001 : Record "Item Ledger Entry";VAR NewItemLedgEntry@1002 : Record "Item Ledger Entry");
    VAR
      EntriesExist@1000 : Boolean;
    BEGIN
      if ItemLedgEntryNo = 0 then
        ItemLedgEntryNo := GlobalItemLedgEntry."Entry No.";

      ItemLedgEntryNo := ItemLedgEntryNo + 1;
      NewItemLedgEntry := OldItemLedgEntry;
      ItemTrackingMgt.RetrieveAppliedExpirationDate(NewItemLedgEntry);
      NewItemLedgEntry."Entry No." := ItemLedgEntryNo;
      NewItemLedgEntry.Quantity := -OldItemLedgEntry.Quantity;
      NewItemLedgEntry."Remaining Quantity" := -OldItemLedgEntry.Quantity;
      if NewItemLedgEntry.Quantity > 0 then
        NewItemLedgEntry."Shipped Qty. Not Returned" := 0
      else
        NewItemLedgEntry."Shipped Qty. Not Returned" := NewItemLedgEntry.Quantity;
      NewItemLedgEntry."Invoiced Quantity" := NewItemLedgEntry.Quantity;
      NewItemLedgEntry.Positive := NewItemLedgEntry."Remaining Quantity" > 0;
      NewItemLedgEntry.Open := NewItemLedgEntry."Remaining Quantity" <> 0;
      NewItemLedgEntry."Completely Invoiced" := true;
      NewItemLedgEntry."Last Invoice Date" := NewItemLedgEntry."Posting Date";
      NewItemLedgEntry.Correction := true;
      NewItemLedgEntry."Document Line No." := ItemJnlLine."Document Line No.";
      if OldItemLedgEntry.Positive then
        NewItemLedgEntry."Applies-to Entry" := OldItemLedgEntry."Entry No."
      else
        NewItemLedgEntry."Applies-to Entry" := 0;

      OnBeforeInsertCorrItemLedgEntry(NewItemLedgEntry,OldItemLedgEntry,ItemJnlLine);

      NewItemLedgEntry.INSERT;

      OnAfterInsertCorrItemLedgEntry(NewItemLedgEntry,ItemJnlLine);

      if NewItemLedgEntry."Item Tracking" <> NewItemLedgEntry."Item Tracking"::None then
        ItemTrackingMgt.ExistingExpirationDate(
          NewItemLedgEntry."Item No.",
          NewItemLedgEntry."Variant Code",
          NewItemLedgEntry."Lot No.",
          NewItemLedgEntry."Serial No.",
          true,
          EntriesExist);
    END;

    LOCAL PROCEDURE UpdateOldItemLedgEntry@40(VAR OldItemLedgEntry@1000 : Record "Item Ledger Entry";LastInvoiceDate@1001 : Date);
    BEGIN
      OldItemLedgEntry."Completely Invoiced" := true;
      OldItemLedgEntry."Last Invoice Date" := LastInvoiceDate;
      OldItemLedgEntry."Invoiced Quantity" := OldItemLedgEntry.Quantity;
      OldItemLedgEntry."Shipped Qty. Not Returned" := 0;
      OldItemLedgEntry.MODIFY;
    END;

    LOCAL PROCEDURE InsertCorrValueEntry@34(OldValueEntry@1005 : Record "Value Entry";VAR NewValueEntry@1000 : Record "Value Entry";ItemLedgEntry@1003 : Record "Item Ledger Entry";DocumentLineNo@1006 : Integer;Sign@1001 : Integer;QtyToShip@1002 : Decimal;QtyToInvoice@1004 : Decimal);
    BEGIN
      ValueEntryNo := ValueEntryNo + 1;

      NewValueEntry := OldValueEntry;
      NewValueEntry."Entry No." := ValueEntryNo;
      NewValueEntry."Item Ledger Entry No." := ItemLedgEntry."Entry No.";
      NewValueEntry."User ID" := USERID;
      NewValueEntry."Valued Quantity" := Sign * OldValueEntry."Valued Quantity";
      NewValueEntry."Document Line No." := DocumentLineNo;
      NewValueEntry."Item Ledger Entry Quantity" := QtyToShip;
      NewValueEntry."Invoiced Quantity" := QtyToInvoice;
      NewValueEntry."Expected Cost" := QtyToInvoice = 0;
      if not NewValueEntry."Expected Cost" then begin
        NewValueEntry."Cost Amount (Expected)" := -Sign * OldValueEntry."Cost Amount (Expected)";
        NewValueEntry."Cost Amount (Expected) (ACY)" := -Sign * OldValueEntry."Cost Amount (Expected) (ACY)";
        if QtyToShip = 0 then begin
          NewValueEntry."Cost Amount (Actual)" := Sign * OldValueEntry."Cost Amount (Expected)";
          NewValueEntry."Cost Amount (Actual) (ACY)" := Sign * OldValueEntry."Cost Amount (Expected) (ACY)";
        end else begin
          NewValueEntry."Cost Amount (Actual)" := -NewValueEntry."Cost Amount (Actual)";
          NewValueEntry."Cost Amount (Actual) (ACY)" := -NewValueEntry."Cost Amount (Actual) (ACY)";
        end;
        NewValueEntry."Purchase Amount (Expected)" := -Sign * OldValueEntry."Purchase Amount (Expected)";
        NewValueEntry."Sales Amount (Expected)" := -Sign * OldValueEntry."Sales Amount (Expected)";
      end else begin
        NewValueEntry."Cost Amount (Expected)" := -OldValueEntry."Cost Amount (Expected)";
        NewValueEntry."Cost Amount (Expected) (ACY)" := -OldValueEntry."Cost Amount (Expected) (ACY)";
        NewValueEntry."Cost Amount (Actual)" := 0;
        NewValueEntry."Cost Amount (Actual) (ACY)" := 0;
        NewValueEntry."Sales Amount (Expected)" := -OldValueEntry."Sales Amount (Expected)";
        NewValueEntry."Purchase Amount (Expected)" := -OldValueEntry."Purchase Amount (Expected)";
      end;

      NewValueEntry."Purchase Amount (Actual)" := 0;
      NewValueEntry."Sales Amount (Actual)" := 0;
      NewValueEntry."Cost Amount (Non-Invtbl.)" := Sign * OldValueEntry."Cost Amount (Non-Invtbl.)";
      NewValueEntry."Cost Amount (Non-Invtbl.)(ACY)" := Sign * OldValueEntry."Cost Amount (Non-Invtbl.)(ACY)";
      NewValueEntry."Cost Posted to G/L" := 0;
      NewValueEntry."Cost Posted to G/L (ACY)" := 0;
      NewValueEntry."Expected Cost Posted to G/L" := 0;
      NewValueEntry."Exp. Cost Posted to G/L (ACY)" := 0;

      OnBeforeInsertCorrValueEntry(NewValueEntry,OldValueEntry,ItemJnlLine);

      if NewValueEntry.Inventoriable then
        PostInventoryToGL(NewValueEntry);

      NewValueEntry.INSERT;

      OnAfterInsertCorrValueEntry(NewValueEntry,ItemJnlLine);

      ItemApplnEntry.SetOutboundsNotUpdated(ItemLedgEntry);

      UpdateAdjmtProp(NewValueEntry,ItemLedgEntry."Posting Date");

      InsertItemReg(0,0,NewValueEntry."Entry No.",0);
      InsertPostValueEntryToGL(NewValueEntry);
    END;

    LOCAL PROCEDURE UpdateOrigAppliedFromEntry@41(OldItemLedgEntryNo@1007 : Integer);
    VAR
      ItemApplEntry@1004 : Record "Item Application Entry";
      ItemLedgEntry@1005 : Record "Item Ledger Entry";
    BEGIN
      ItemApplEntry.SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
      ItemApplEntry.SETRANGE("Outbound Item Entry No.",OldItemLedgEntryNo);
      ItemApplEntry.SETFILTER("Item Ledger Entry No.",'<>%1',OldItemLedgEntryNo);
      if ItemApplEntry.FINDSET then
        repeat
          if ItemLedgEntry.GET(ItemApplEntry."Inbound Item Entry No.") and
             not ItemLedgEntry."Applied Entry to Adjust"
          then begin
            ItemLedgEntry."Applied Entry to Adjust" := true;
            ItemLedgEntry.MODIFY;
          end;
        until ItemApplEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE GetLocation@7300(LocationCode@1000 : Code[10]);
    BEGIN
      if LocationCode = '' then
        CLEAR(Location)
      else
        if Location.Code <> LocationCode then
          Location.GET(LocationCode);
    END;

    LOCAL PROCEDURE CheckItem@126(ItemNo@1000 : Code[20]);
    BEGIN
      if Item.GET(ItemNo) then begin
        if not CalledFromAdjustment then
          Item.TESTFIELD(Blocked,false);
      end else
        Item.INIT;
    END;

    [External]
    PROCEDURE CheckItemTracking@21();
    BEGIN
      if SNRequired and (ItemJnlLine."Serial No." = '') then
        ERROR(GetTextStringWithLineNo(SerialNoRequiredErr,ItemJnlLine."Item No.",ItemJnlLine."Line No."));
      if LotRequired and (ItemJnlLine."Lot No." = '') then
        ERROR(GetTextStringWithLineNo(LotNoRequiredErr,ItemJnlLine."Item No.",ItemJnlLine."Line No."));
      if ItemJnlLine."Entry Type" = ItemJnlLine."Entry Type"::Transfer then begin
        if SNRequired then
          ItemJnlLine.TESTFIELD("New Serial No.");
        if LotRequired then
          ItemJnlLine.TESTFIELD("New Lot No.");
      end;
    END;

    LOCAL PROCEDURE CheckItemTrackingInfo@44(VAR ItemJnlLine2@1000 : Record "Item Journal Line";VAR TrackingSpecification@1001 : Record "Tracking Specification";SNInfoRequired@1005 : Boolean;LotInfoRequired@1004 : Boolean);
    VAR
      SerialNoInfo@1003 : Record "Serial No. Information";
      LotNoInfo@1002 : Record "Lot No. Information";
    BEGIN
      if SNInfoRequired then begin
        SerialNoInfo.GET(
          ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Serial No.");
        SerialNoInfo.TESTFIELD(Blocked,false);
        if TrackingSpecification."New Serial No." <> '' then begin
          SerialNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Serial No.");
          SerialNoInfo.TESTFIELD(Blocked,false);
        end;
      end else begin
        if SerialNoInfo.GET(
             ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Serial No.")
        then
          SerialNoInfo.TESTFIELD(Blocked,false);
        if TrackingSpecification."New Serial No." <> '' then begin
          if SerialNoInfo.GET(
               ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Serial No.")
          then
            SerialNoInfo.TESTFIELD(Blocked,false);
        end;
      end;

      if LotInfoRequired then begin
        LotNoInfo.GET(
          ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Lot No.");
        LotNoInfo.TESTFIELD(Blocked,false);
        if TrackingSpecification."New Lot No." <> '' then begin
          LotNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Lot No.");
          LotNoInfo.TESTFIELD(Blocked,false);
        end;
      end else begin
        if LotNoInfo.GET(
             ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Lot No.")
        then
          LotNoInfo.TESTFIELD(Blocked,false);
        if TrackingSpecification."New Lot No." <> '' then begin
          if LotNoInfo.GET(
               ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Lot No.")
          then
            LotNoInfo.TESTFIELD(Blocked,false);
        end;
      end;
    END;

    LOCAL PROCEDURE InsertTempTrkgSpecification@46(FreeEntryNo@1000 : Integer);
    VAR
      TempTrackingSpecification2@1001 : TEMPORARY Record "Tracking Specification";
    BEGIN
      if not TempTrackingSpecification.INSERT then begin
        TempTrackingSpecification2 := TempTrackingSpecification;
        TempTrackingSpecification.GET(TempTrackingSpecification2."Item Ledger Entry No.");
        TempTrackingSpecification.DELETE;
        TempTrackingSpecification."Entry No." := FreeEntryNo;
        TempTrackingSpecification.INSERT;
        TempTrackingSpecification := TempTrackingSpecification2;
        TempTrackingSpecification.INSERT;
      end;
    END;

    LOCAL PROCEDURE IsNotInternalWhseMovement@43(ItemJnlLine@1000 : Record "Item Journal Line") : Boolean;
    BEGIN
      with ItemJnlLine do begin
        if ("Entry Type" = "Entry Type"::Transfer) and
           ("Location Code" = "New Location Code") and
           ("Dimension Set ID" = "New Dimension Set ID") and
           ("Value Entry Type" = "Value Entry Type"::"Direct Cost") and
           not Adjustment
        then
          exit(false);
        exit(true)
      end;
    END;

    [External]
    PROCEDURE SetCalledFromInvtPutawayPick@47(NewCalledFromInvtPutawayPick@1000 : Boolean);
    BEGIN
      CalledFromInvtPutawayPick := NewCalledFromInvtPutawayPick;
    END;

    [External]
    PROCEDURE SetCalledFromAdjustment@49(NewCalledFromAdjustment@1000 : Boolean;NewPostToGL@1001 : Boolean);
    BEGIN
      CalledFromAdjustment := NewCalledFromAdjustment;
      PostToGL := NewPostToGL;
    END;

    [External]
    PROCEDURE NextOperationExist@50(ProdOrderRtngLine@1000 : Record "Prod. Order Routing Line") : Boolean;
    BEGIN
      exit(ProdOrderRtngLine."Next Operation No." <> '');
    END;

    LOCAL PROCEDURE UpdateAdjmtProp@58(ValueEntry@1000 : Record "Value Entry";OriginalPostingDate@1003 : Date);
    BEGIN
      with ValueEntry do
        SetAdjmtProp("Item No.","Item Ledger Entry Type",Adjustment,
          "Order Type","Order No.","Order Line No.",OriginalPostingDate,"Valuation Date");
    END;

    LOCAL PROCEDURE SetAdjmtProp@64(ItemNo@1001 : Code[20];ItemLedgEntryType@1005 : Option;Adjustment@1000 : Boolean;OrderType@1007 : Option;OrderNo@1004 : Code[20];OrderLineNo@1006 : Integer;OriginalPostingDate@1002 : Date;ValuationDate@1003 : Date);
    BEGIN
      SetItemAdjmtProp(ItemNo,ItemLedgEntryType,Adjustment,OriginalPostingDate,ValuationDate);
      SetOrderAdjmtProp(ItemLedgEntryType,OrderType,OrderNo,OrderLineNo,OriginalPostingDate,ValuationDate);
    END;

    LOCAL PROCEDURE SetItemAdjmtProp@39(ItemNo@1001 : Code[20];ItemLedgEntryType@1005 : Option;Adjustment@1000 : Boolean;OriginalPostingDate@1002 : Date;ValuationDate@1003 : Date);
    VAR
      Item@1010 : Record Item;
      ValueEntry@1011 : Record "Value Entry";
      ModifyItem@1008 : Boolean;
    BEGIN
      if ItemLedgEntryType = ValueEntry."Item Ledger Entry Type"::" " then
        exit;
      if Adjustment then
        if not (ItemLedgEntryType in [ValueEntry."Item Ledger Entry Type"::Output,
                                      ValueEntry."Item Ledger Entry Type"::"Assembly Output"])
        then
          exit;

      with Item do
        if GET(ItemNo) and ("Allow Online Adjustment" or "Cost is Adjusted") and (Type = Type::Inventory) then begin
          LOCKTABLE;
          if "Cost is Adjusted" then begin
            "Cost is Adjusted" := false;
            ModifyItem := true;
          end;
          if "Allow Online Adjustment" then begin
            if "Costing Method" = "Costing Method"::Average then
              "Allow Online Adjustment" := AllowAdjmtOnPosting(ValuationDate)
            else
              "Allow Online Adjustment" := AllowAdjmtOnPosting(OriginalPostingDate);
            ModifyItem := ModifyItem or not "Allow Online Adjustment";
          end;
          if ModifyItem then
            MODIFY;
        end;
    END;

    LOCAL PROCEDURE SetOrderAdjmtProp@86(ItemLedgEntryType@1001 : Option;OrderType@1002 : Option;OrderNo@1003 : Code[20];OrderLineNo@1004 : Integer;OriginalPostingDate@1005 : Date;ValuationDate@1006 : Date);
    VAR
      ValueEntry@1007 : Record "Value Entry";
      InvtAdjmtEntryOrder@1008 : Record "Inventory Adjmt. Entry (Order)";
      ProdOrderLine@1009 : Record "Prod. Order Line";
      AssemblyHeader@1010 : Record "Assembly Header";
      ModifyOrderAdjmt@1011 : Boolean;
    BEGIN
      if not (OrderType in [ValueEntry."Order Type"::Production,
                            ValueEntry."Order Type"::Assembly])
      then
        exit;

      if ItemLedgEntryType in [ValueEntry."Item Ledger Entry Type"::Output,
                               ValueEntry."Item Ledger Entry Type"::"Assembly Output"]
      then
        exit;

      with InvtAdjmtEntryOrder do
        if GET(OrderType,OrderNo,OrderLineNo) then begin
          if "Allow Online Adjustment" or "Cost is Adjusted" then begin
            LOCKTABLE;
            if "Cost is Adjusted" then begin
              "Cost is Adjusted" := false;
              ModifyOrderAdjmt := true;
            end;
            if "Allow Online Adjustment" then begin
              "Allow Online Adjustment" := AllowAdjmtOnPosting(OriginalPostingDate);
              ModifyOrderAdjmt := ModifyOrderAdjmt or not "Allow Online Adjustment";
            end;
            if ModifyOrderAdjmt then
              MODIFY;
          end;
        end else
          case OrderType of
            "Order Type"::Production:
              begin
                ProdOrderLine.GET(ProdOrderLine.Status::Released,OrderNo,OrderLineNo);
                SetProdOrderLine(ProdOrderLine);
                SetOrderAdjmtProp(ItemLedgEntryType,OrderType,OrderNo,OrderLineNo,OriginalPostingDate,ValuationDate);
              end;
            "Order Type"::Assembly:
              begin
                if OrderLineNo = 0 then begin
                  AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,OrderNo);
                  SetAsmOrder(AssemblyHeader);
                end;
                SetOrderAdjmtProp(ItemLedgEntryType,OrderType,OrderNo,0,OriginalPostingDate,ValuationDate);
              end;
          end;
    END;

    LOCAL PROCEDURE AllowAdjmtOnPosting@56(TheDate@1000 : Date) : Boolean;
    BEGIN
      GetInvtSetup;

      with InvtSetup do
        case "Automatic Cost Adjustment" of
          "Automatic Cost Adjustment"::Never:
            exit(false);
          "Automatic Cost Adjustment"::Day:
            exit(TheDate >= CALCDATE('<-1D>',WORKDATE));
          "Automatic Cost Adjustment"::Week:
            exit(TheDate >= CALCDATE('<-1W>',WORKDATE));
          "Automatic Cost Adjustment"::Month:
            exit(TheDate >= CALCDATE('<-1M>',WORKDATE));
          "Automatic Cost Adjustment"::Quarter:
            exit(TheDate >= CALCDATE('<-1Q>',WORKDATE));
          "Automatic Cost Adjustment"::Year:
            exit(TheDate >= CALCDATE('<-1Y>',WORKDATE));
          else
            exit(true);
        end;
    END;

    LOCAL PROCEDURE InsertBalanceExpCostRevEntry@62(ValueEntry@1000 : Record "Value Entry");
    VAR
      ValueEntry2@1001 : Record "Value Entry";
      ValueEntry3@1004 : Record "Value Entry";
      RevExpCostToBalance@1002 : Decimal;
      RevExpCostToBalanceACY@1003 : Decimal;
    BEGIN
      if GlobalItemLedgEntry.Quantity - (GlobalItemLedgEntry."Invoiced Quantity" - ValueEntry."Invoiced Quantity") = 0 then
        exit;
      with ValueEntry2 do begin
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ValueEntry."Item Ledger Entry No.");
        SETRANGE("Entry Type","Entry Type"::Revaluation);
        SETRANGE("Applies-to Entry",0);
        if FINDSET then
          repeat
            CalcRevExpCostToBalance(ValueEntry2,ValueEntry."Invoiced Quantity",RevExpCostToBalance,RevExpCostToBalanceACY);
            if (RevExpCostToBalance <> 0) or (RevExpCostToBalanceACY <> 0) then begin
              ValueEntryNo := ValueEntryNo + 1;
              ValueEntry3 := ValueEntry;
              ValueEntry3."Entry No." := ValueEntryNo;
              ValueEntry3."Item Charge No." := '';
              ValueEntry3."Entry Type" := ValueEntry."Entry Type"::Revaluation;
              ValueEntry3."Valuation Date" := "Valuation Date";
              ValueEntry3.Description := '';
              ValueEntry3."Applies-to Entry" := "Entry No.";
              ValueEntry3."Cost Amount (Expected)" := RevExpCostToBalance;
              ValueEntry3."Cost Amount (Expected) (ACY)" := RevExpCostToBalanceACY;
              ValueEntry3."Valued Quantity" := "Valued Quantity";
              ValueEntry3."Cost per Unit" := CalcCostPerUnit(RevExpCostToBalance,ValueEntry."Valued Quantity",false);
              ValueEntry3."Cost per Unit (ACY)" := CalcCostPerUnit(RevExpCostToBalanceACY,ValueEntry."Valued Quantity",true);
              ValueEntry3."Cost Posted to G/L" := 0;
              ValueEntry3."Cost Posted to G/L (ACY)" := 0;
              ValueEntry3."Expected Cost Posted to G/L" := 0;
              ValueEntry3."Exp. Cost Posted to G/L (ACY)" := 0;
              ValueEntry3."Invoiced Quantity" := 0;
              ValueEntry3."Sales Amount (Actual)" := 0;
              ValueEntry3."Purchase Amount (Actual)" := 0;
              ValueEntry3."Discount Amount" := 0;
              ValueEntry3."Cost Amount (Actual)" := 0;
              ValueEntry3."Cost Amount (Actual) (ACY)" := 0;
              ValueEntry3."Sales Amount (Expected)" := 0;
              ValueEntry3."Purchase Amount (Expected)" := 0;
              InsertValueEntry(ValueEntry3,GlobalItemLedgEntry,false);
            end;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE IsBalanceExpectedCostFromRev@59(ItemJnlLine2@1000 : Record "Item Journal Line") : Boolean;
    BEGIN
      with ItemJnlLine2 do
        exit((Item."Costing Method" = Item."Costing Method"::Standard) and
          (((Quantity = 0) and ("Invoiced Quantity" <> 0)) or
           (Adjustment and not GlobalValueEntry."Expected Cost")));
    END;

    LOCAL PROCEDURE CalcRevExpCostToBalance@61(ValueEntry@1000 : Record "Value Entry";InvdQty@1001 : Decimal;VAR RevExpCostToBalance@1002 : Decimal;VAR RevExpCostToBalanceACY@1003 : Decimal);
    VAR
      ValueEntry2@1004 : Record "Value Entry";
      OldExpectedQty@1005 : Decimal;
    BEGIN
      with ValueEntry2 do begin
        RevExpCostToBalance := -ValueEntry."Cost Amount (Expected)";
        RevExpCostToBalanceACY := -ValueEntry."Cost Amount (Expected) (ACY)";
        OldExpectedQty := GlobalItemLedgEntry.Quantity;
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ValueEntry."Item Ledger Entry No.");
        if GlobalItemLedgEntry.Quantity <> GlobalItemLedgEntry."Invoiced Quantity" then begin
          SETRANGE("Entry Type","Entry Type"::"Direct Cost");
          SETFILTER("Entry No.",'<%1',ValueEntry."Entry No.");
          SETRANGE("Item Charge No.",'');
          if FINDSET then
            repeat
              OldExpectedQty := OldExpectedQty - "Invoiced Quantity";
            until NEXT = 0;

          RevExpCostToBalance := ROUND(RevExpCostToBalance * InvdQty / OldExpectedQty,GLSetup."Amount Rounding Precision");
          RevExpCostToBalanceACY := ROUND(RevExpCostToBalanceACY * InvdQty / OldExpectedQty,Currency."Amount Rounding Precision");
        end else begin
          SETRANGE("Entry Type","Entry Type"::Revaluation);
          SETRANGE("Applies-to Entry",ValueEntry."Entry No.");
          if FINDSET then
            repeat
              RevExpCostToBalance := RevExpCostToBalance - "Cost Amount (Expected)";
              RevExpCostToBalanceACY := RevExpCostToBalanceACY - "Cost Amount (Expected) (ACY)";
            until NEXT = 0;
        end;
      end;
    END;

    LOCAL PROCEDURE IsInterimRevaluation@63() : Boolean;
    BEGIN
      with ItemJnlLine do
        exit(("Value Entry Type" = "Value Entry Type"::Revaluation) and (Quantity <> 0));
    END;

    LOCAL PROCEDURE InsertPostValueEntryToGL@96(ValueEntry@1000 : Record "Value Entry");
    VAR
      PostValueEntryToGL@1001 : Record "Post Value Entry to G/L";
    BEGIN
      if IsPostToGL(ValueEntry) then begin
        PostValueEntryToGL.INIT;
        PostValueEntryToGL."Value Entry No." := ValueEntry."Entry No.";
        PostValueEntryToGL."Item No." := ValueEntry."Item No.";
        PostValueEntryToGL."Posting Date" := ValueEntry."Posting Date";
        PostValueEntryToGL.INSERT;
      end;
    END;

    LOCAL PROCEDURE IsPostToGL@66(ValueEntry@1000 : Record "Value Entry") : Boolean;
    BEGIN
      GetInvtSetup;
      with ValueEntry do
        exit(
          Inventoriable and not PostToGL and
          (((not "Expected Cost") and (("Cost Amount (Actual)" <> 0) or ("Cost Amount (Actual) (ACY)" <> 0))) or
           (InvtSetup."Expected Cost Posting to G/L" and (("Cost Amount (Expected)" <> 0) or ("Cost Amount (Expected) (ACY)" <> 0)))));
    END;

    LOCAL PROCEDURE MoveApplication@90(VAR ItemLedgEntry@1001 : Record "Item Ledger Entry";VAR OldItemLedgEntry@1000 : Record "Item Ledger Entry") : Boolean;
    VAR
      Application@1002 : Record "Item Application Entry";
      Enough@1004 : Boolean;
      FixedApplication@1003 : Boolean;
    BEGIN
      with ItemLedgEntry do begin
        FixedApplication := false;
        OldItemLedgEntry.TESTFIELD(Positive,true);

        if (OldItemLedgEntry."Remaining Quantity" < ABS(Quantity)) and
           (OldItemLedgEntry."Remaining Quantity" < OldItemLedgEntry.Quantity)
        then begin
          Enough := false;
          Application.RESET;
          Application.SETCURRENTKEY("Inbound Item Entry No.");
          Application.SETRANGE("Inbound Item Entry No.","Applies-to Entry");
          Application.SETFILTER("Outbound Item Entry No.",'<>0');

          if Application.FINDSET then begin
            repeat
              if not Application.Fixed then begin
                UnApply(Application);
                OldItemLedgEntry.GET(OldItemLedgEntry."Entry No.");
                OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
                Enough :=
                  ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >=
                  ABS("Remaining Quantity");
              end else
                FixedApplication := true;
            until (Application.NEXT = 0) or Enough;
          end else
            exit(false); // no applications found that could be undone
          if not Enough and FixedApplication then
            ERROR(Text027);
          exit(Enough);
        end;
        exit(true);
      end;
    END;

    LOCAL PROCEDURE CheckApplication@84(ItemLedgEntry@1001 : Record "Item Ledger Entry";OldItemLedgEntry@1000 : Record "Item Ledger Entry");
    BEGIN
      if SkipApplicationCheck then begin
        SkipApplicationCheck := false;
        exit;
      end;

      if ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") <
         ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity")
      then
        OldItemLedgEntry.FIELDERROR("Remaining Quantity",Text004)
    END;

    LOCAL PROCEDURE CheckApplFromInProduction@98(VAR GlobalItemLedgerEntry@1001 : Record "Item Ledger Entry";AppliesFRomEntryNo@1000 : Integer);
    VAR
      OldItemLedgerEntry@1002 : Record "Item Ledger Entry";
    BEGIN
      if AppliesFRomEntryNo = 0 then
        exit;

      with GlobalItemLedgerEntry do
        if ("Order Type" = "Order Type"::Production) and ("Order No." <> '') then begin
          OldItemLedgerEntry.GET(AppliesFRomEntryNo);
          if not AllowProdApplication(OldItemLedgerEntry,GlobalItemLedgEntry) then
            ERROR(
              Text022,
              OldItemLedgerEntry."Entry Type",
              "Entry Type",
              "Item No.",
              "Order No.");

          if ItemApplnEntry.CheckIsCyclicalLoop(GlobalItemLedgerEntry,OldItemLedgerEntry) then
            ERROR(
              Text022,
              OldItemLedgerEntry."Entry Type",
              "Entry Type",
              "Item No.",
              "Order No.");
        end;
    END;

    [Internal]
    PROCEDURE RedoApplications@91();
    VAR
      TouchedItemLedgEntry@1005 : Record "Item Ledger Entry";
      DialogWindow@1001 : Dialog;
      Count@1002 : Integer;
      t@1003 : Integer;
    BEGIN
      TouchedItemLedgerEntries.SETCURRENTKEY("Item No.",Open,"Variant Code",Positive,"Location Code","Posting Date");
      if TouchedItemLedgerEntries.FIND('-') then begin
        DialogWindow.OPEN(Text01 +
          '@1@@@@@@@@@@@@@@@@@@@@@@@');
        Count := TouchedItemLedgerEntries.COUNT;
        t := 0;

        repeat
          t := t + 1;
          DialogWindow.UPDATE(1,ROUND(t * 10000 / Count,1));
          TouchedItemLedgEntry.GET(TouchedItemLedgerEntries."Entry No.");
          if TouchedItemLedgEntry."Remaining Quantity" <> 0 then begin
            ReApply(TouchedItemLedgEntry,0);
            TouchedItemLedgEntry.GET(TouchedItemLedgerEntries."Entry No.");
          end;
        until TouchedItemLedgerEntries.NEXT = 0;
        if AnyTouchedEntries then
          VerifyTouchedOnInventory;
        TouchedItemLedgerEntries.DELETEALL;
        DeleteTouchedEntries;
        DialogWindow.CLOSE;
      end;
    END;

    LOCAL PROCEDURE UpdateValuedByAverageCost@393(CostItemLedgEntryNo@1000 : Integer;ValuedByAverage@1001 : Boolean);
    VAR
      ValueEntry@1002 : Record "Value Entry";
    BEGIN
      if CostItemLedgEntryNo = 0 then
        exit;

      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      ValueEntry.SETRANGE("Item Ledger Entry No.",CostItemLedgEntryNo);
      ValueEntry.SETRANGE("Valued By Average Cost",not ValuedByAverage);
      ValueEntry.MODIFYALL("Valued By Average Cost",ValuedByAverage);
    END;

    [Internal]
    PROCEDURE CostAdjust@92();
    VAR
      InvtSetup@1001 : Record "Inventory Setup";
      InventoryPeriod@1002 : Record "Inventory Period";
      InvtAdjmt@1003 : Codeunit "Inventory Adjustment";
      Opendate@1004 : Date;
    BEGIN
      InvtSetup.GET;
      InventoryPeriod.IsValidDate(Opendate);
      if InvtSetup."Automatic Cost Adjustment" <>
         InvtSetup."Automatic Cost Adjustment"::Never
      then begin
        if Opendate <> 0D then
          Opendate := CALCDATE('<+1D>',Opendate);
        InvtAdjmt.SetProperties(true,InvtSetup."Automatic Cost Posting");
        InvtAdjmt.MakeMultiLevelAdjmt;
      end;
    END;

    LOCAL PROCEDURE TouchEntry@68(EntryNo@1000 : Integer);
    VAR
      TouchedItemLedgEntry@1002 : Record "Item Ledger Entry";
    BEGIN
      TouchedItemLedgEntry.GET(EntryNo);
      TouchedItemLedgerEntries := TouchedItemLedgEntry;
      if not TouchedItemLedgerEntries.INSERT then ;
    END;

    LOCAL PROCEDURE TouchItemEntryCost@69(VAR ItemLedgerEntry@1000 : Record "Item Ledger Entry";IsAdjustment@1006 : Boolean);
    VAR
      ValueEntry@1004 : Record "Value Entry";
      AvgCostAdjmtEntryPoint@1005 : Record "Avg. Cost Adjmt. Entry Point";
    BEGIN
      ItemLedgerEntry."Applied Entry to Adjust" := true;
      with ItemLedgerEntry do
        SetAdjmtProp("Item No.","Entry Type",IsAdjustment,
          "Order Type","Order No.","Order Line No.",
          "Posting Date","Posting Date");

      if not IsAdjustment then begin
        EnsureValueEntryLoaded(ValueEntry,ItemLedgerEntry);
        AvgCostAdjmtEntryPoint.UpdateValuationDate(ValueEntry);
      end;
    END;

    [External]
    PROCEDURE AnyTouchedEntries@67() : Boolean;
    BEGIN
      exit(TouchedItemLedgerEntries.FIND('-'))
    END;

    LOCAL PROCEDURE GetMaxAppliedValuationdate@93(ItemLedgerEntry@1000 : Record "Item Ledger Entry") : Date;
    VAR
      ToItemApplnEntry@1004 : Record "Item Application Entry";
      FromItemledgEntryNo@1006 : Integer;
      FromInbound@1002 : Boolean;
      MaxDate@1003 : Date;
      NewDate@1005 : Date;
    BEGIN
      FromInbound := ItemLedgerEntry.Positive;
      FromItemledgEntryNo := ItemLedgerEntry."Entry No.";
      with ToItemApplnEntry do begin
        if FromInbound then begin
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
          SETFILTER(Quantity,'>%1',0);
        end else begin
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER(Quantity,'<%1',0);
        end;
        if FINDSET then begin
          MaxDate := 0D;
          repeat
            if FromInbound then
              ItemLedgerEntry.GET("Outbound Item Entry No.")
            else
              ItemLedgerEntry.GET("Inbound Item Entry No.");
            NewDate := GetMaxValuationDate(ItemLedgerEntry);
            MaxDate := Max(NewDate,MaxDate);
          until NEXT = 0
        end;
      end;
      exit(MaxDate);
    END;

    LOCAL PROCEDURE Max@94(Date1@1000 : Date;Date2@1001 : Date) : Date;
    BEGIN
      if Date1 > Date2 then
        exit(Date1);
      exit(Date2);
    END;

    [External]
    PROCEDURE SetValuationDateAllValueEntrie@95(ItemLedgerEntryNo@1000 : Integer;ValuationDate@1001 : Date;FixedApplication@1003 : Boolean);
    VAR
      ValueEntry@1002 : Record "Value Entry";
    BEGIN
      with ValueEntry do begin
        RESET;
        SETCURRENTKEY("Item Ledger Entry No.");
        SETRANGE("Item Ledger Entry No.",ItemLedgerEntryNo);
        if FINDSET then
          repeat
            if ("Valuation Date" <> "Posting Date") or
               ("Valuation Date" < ValuationDate) or
               (("Valuation Date" > ValuationDate) and FixedApplication)
            then begin
              "Valuation Date" := ValuationDate;
              MODIFY;
            end;
          until NEXT = 0;
      end;
    END;

    [External]
    PROCEDURE SetServUndoConsumption@71(Value@1000 : Boolean);
    BEGIN
      IsServUndoConsumption := Value;
    END;

    [External]
    PROCEDURE SetProdOrderCompModified@45(ProdOrderCompIsModified@1000 : Boolean);
    BEGIN
      ProdOrderCompModified := ProdOrderCompIsModified;
    END;

    LOCAL PROCEDURE InsertCountryCode@81(VAR NewItemLedgEntry@1000 : Record "Item Ledger Entry";ItemLedgEntry@1001 : Record "Item Ledger Entry");
    BEGIN
      if ItemLedgEntry."Location Code" = '' then
        exit;
      if NewItemLedgEntry."Location Code" = '' then begin
        Location.GET(ItemLedgEntry."Location Code");
        NewItemLedgEntry."Country/Region Code" := Location."Country/Region Code";
      end else begin
        Location.GET(NewItemLedgEntry."Location Code");
        if not Location."Use As In-Transit" then begin
          Location.GET(ItemLedgEntry."Location Code");
          if not Location."Use As In-Transit" then
            NewItemLedgEntry."Country/Region Code" := Location."Country/Region Code";
        end;
      end;
    END;

    LOCAL PROCEDURE ReservationPreventsApplication@82(ApplicationEntry@1001 : Integer;ItemNo@1002 : Code[20];ReservationsEntry@1003 : Record "Item Ledger Entry");
    VAR
      ReservationEntries@1000 : Record "Reservation Entry";
      ReservEngineMgt@1005 : Codeunit "Reservation Engine Mgt.";
      ReserveItemLedgEntry@1004 : Codeunit "Item Ledger Entry-Reserve";
    BEGIN
      ReservEngineMgt.InitFilterAndSortingLookupFor(ReservationEntries,true);
      ReserveItemLedgEntry.FilterReservFor(ReservationEntries,ReservationsEntry);
      if ReservationEntries.FINDFIRST then;
      ERROR(
        Text029,
        ReservationsEntry.FIELDCAPTION("Applies-to Entry"),
        ApplicationEntry,
        Item.FIELDCAPTION("No."),
        ItemNo,
        ReservEngineMgt.CreateForText(ReservationEntries));
    END;

    LOCAL PROCEDURE CheckItemTrackingOfComp@83(TempHandlingSpecification@1000 : Record "Tracking Specification";ItemJnlLine@1001 : Record "Item Journal Line");
    BEGIN
      if SNRequired then
        ItemJnlLine.TESTFIELD("Serial No.",TempHandlingSpecification."Serial No.");
      if LotRequired then
        ItemJnlLine.TESTFIELD("Lot No.",TempHandlingSpecification."Lot No.");
    END;

    LOCAL PROCEDURE MaxConsumptionValuationDate@85(ProdOrderNo@1000 : Code[20];ItemNo@1003 : Code[20]) : Date;
    VAR
      ValueEntry@1001 : Record "Value Entry";
      ValuationDate@1002 : Date;
    BEGIN
      with ValueEntry do begin
        SETCURRENTKEY("Order Type","Order No.");
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderNo);
        SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Consumption);
        SETRANGE("Item No.",ItemNo);
        if FINDSET then
          repeat
            if ("Valuation Date" > ValuationDate) and
               ("Entry Type" <> "Entry Type"::Revaluation)
            then
              ValuationDate := "Valuation Date";
          until NEXT = 0;
        exit(ValuationDate);
      end;
    END;

    LOCAL PROCEDURE CorrectOutputValuationDate@1139(ItemLedgerEntry@1000 : Record "Item Ledger Entry");
    VAR
      ValueEntry@1001 : Record "Value Entry";
      TempValueEntry@1002 : TEMPORARY Record "Value Entry";
      ProductionOrder@1003 : Record "Production Order";
      ValuationDate@1004 : Date;
    BEGIN
      if not (ItemLedgerEntry."Entry Type" in [ItemLedgerEntry."Entry Type"::Consumption,ItemLedgerEntry."Entry Type"::Output]) then
        exit;

      if ProductionOrder.GET(ProductionOrder.Status::Released,ItemLedgerEntry."Order No.") then
        exit;

      if not ItemUsedInConsumptionAndOutput(ItemLedgerEntry."Order No.",ItemLedgerEntry."Item No.") then
        exit;

      ValuationDate := MaxConsumptionValuationDate(ItemLedgerEntry."Order No.",ItemLedgerEntry."Item No.");

      ValueEntry.SETCURRENTKEY("Order Type","Order No.");
      ValueEntry.SETFILTER("Valuation Date",'<%1',ValuationDate);
      ValueEntry.SETRANGE("Order No.",ItemLedgerEntry."Order No.");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::Output);
      if ValueEntry.FINDSET then
        repeat
          TempValueEntry := ValueEntry;
          TempValueEntry.INSERT;
        until ValueEntry.NEXT = 0;

      UpdateOutputEntryAndChain(TempValueEntry,ValuationDate);
    END;

    LOCAL PROCEDURE UpdateOutputEntryAndChain@1086(VAR TempValueEntry@1000 : TEMPORARY Record "Value Entry";ValuationDate@1001 : Date);
    VAR
      ValueEntry@1002 : Record "Value Entry";
      ItemLedgerEntryNo@1003 : Integer;
    BEGIN
      TempValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      if TempValueEntry.FIND('-') then
        repeat
          ValueEntry.GET(TempValueEntry."Entry No.");
          if ValueEntry."Valuation Date" < ValuationDate then begin
            if ItemLedgerEntryNo <> TempValueEntry."Item Ledger Entry No." then begin
              ItemLedgerEntryNo := TempValueEntry."Item Ledger Entry No.";
              UpdateLinkedValuationDate(ValuationDate,ItemLedgerEntryNo,true);
            end;

            ValueEntry."Valuation Date" := ValuationDate;
            ValueEntry.MODIFY;
            if ValueEntry."Entry No." = DirCostValueEntry."Entry No." then
              DirCostValueEntry := ValueEntry;
          end;
        until TempValueEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE GetSourceNo@97(ItemJnlLine@1001 : Record "Item Journal Line") : Code[20];
    BEGIN
      if ItemJnlLine."Invoice-to Source No." <> '' then
        exit(ItemJnlLine."Invoice-to Source No.");
      exit(ItemJnlLine."Source No.");
    END;

    LOCAL PROCEDURE PostAssemblyResourceConsump@1085();
    VAR
      CapLedgEntry@1000 : Record "Capacity Ledger Entry";
      DirCostAmt@1003 : Decimal;
      IndirCostAmt@1004 : Decimal;
    BEGIN
      with ItemJnlLine do begin
        InsertCapLedgEntry(CapLedgEntry,Quantity,Quantity);
        CalcDirAndIndirCostAmts(DirCostAmt,IndirCostAmt,Quantity,"Unit Cost","Indirect Cost %","Overhead Rate");

        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Direct Cost",Quantity,Quantity,DirCostAmt);
        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Indirect Cost",Quantity,0,IndirCostAmt);
      end;
    END;

    LOCAL PROCEDURE InsertAsmItemEntryRelation@88(ItemLedgerEntry@1000 : Record "Item Ledger Entry");
    BEGIN
      Item.GET(ItemLedgerEntry."Item No.");
      if Item."Item Tracking Code" <> '' then begin
        TempItemEntryRelation."Item Entry No." := ItemLedgerEntry."Entry No.";
        TempItemEntryRelation."Serial No." := ItemLedgerEntry."Serial No.";
        TempItemEntryRelation."Lot No." := ItemLedgerEntry."Lot No.";
        TempItemEntryRelation.INSERT;
      end;
    END;

    LOCAL PROCEDURE VerifyInvoicedQty@89(ItemLedgerEntry@1000 : Record "Item Ledger Entry");
    VAR
      ItemLedgEntry2@1001 : Record "Item Ledger Entry";
      ItemApplnEntry@1002 : Record "Item Application Entry";
      SalesShipmentHeader@1003 : Record "Sales Shipment Header";
      TotalInvoicedQty@1004 : Decimal;
    BEGIN
      if not (ItemLedgerEntry."Drop Shipment" and (ItemLedgerEntry."Entry Type" = ItemLedgerEntry."Entry Type"::Purchase)) then
        exit;

      ItemApplnEntry.SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
      ItemApplnEntry.SETRANGE("Inbound Item Entry No.",ItemLedgerEntry."Entry No.");
      ItemApplnEntry.SETFILTER("Item Ledger Entry No.",'<>%1',ItemLedgerEntry."Entry No.");
      if ItemApplnEntry.FINDSET then begin
        repeat
          ItemLedgEntry2.GET(ItemApplnEntry."Item Ledger Entry No.");
          TotalInvoicedQty += ItemLedgEntry2."Invoiced Quantity";
        until ItemApplnEntry.NEXT = 0;
        if ItemLedgerEntry."Invoiced Quantity" > ABS(TotalInvoicedQty) then begin
          SalesShipmentHeader.GET(ItemLedgEntry2."Document No.");
          if ItemLedgerEntry."Item Tracking" = ItemLedgerEntry."Item Tracking"::None then
            ERROR(Text032,ItemLedgerEntry."Item No.",SalesShipmentHeader."Order No.");
          ERROR(
            Text031,ItemLedgerEntry."Item No.",ItemLedgerEntry."Lot No.",ItemLedgerEntry."Serial No.",SalesShipmentHeader."Order No.")
        end;
      end;
    END;

    LOCAL PROCEDURE TransReserveFromJobPlanningLine@87(FromJobContractEntryNo@1001 : Integer;ToItemJnlLine@1002 : Record "Item Journal Line");
    VAR
      JobPlanningLine@1000 : Record "Job Planning Line";
    BEGIN
      JobPlanningLine.SETCURRENTKEY("Job Contract Entry No.");
      JobPlanningLine.SETRANGE("Job Contract Entry No.",FromJobContractEntryNo);
      JobPlanningLine.FINDFIRST;

      if JobPlanningLine."Remaining Qty. (Base)" >= ToItemJnlLine."Quantity (Base)" then
        JobPlanningLine."Remaining Qty. (Base)" := JobPlanningLine."Remaining Qty. (Base)" - ToItemJnlLine."Quantity (Base)"
      else
        JobPlanningLine."Remaining Qty. (Base)" := 0;
      JobPlanningLineReserve.TransferJobLineToItemJnlLine(JobPlanningLine,ToItemJnlLine,ToItemJnlLine."Quantity (Base)");
    END;

    LOCAL PROCEDURE ItemUsedInConsumptionAndOutput@102(ProdOrderNo@1002 : Code[20];ItemNo@1003 : Code[20]) : Boolean;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with ValueEntry do begin
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderNo);
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Consumption);
        if ISEMPTY then
          exit(false);

        SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Output);
        exit(not ISEMPTY);
      end;
    END;

    [External]
    PROCEDURE SetupTempSplitItemJnlLine@101(ItemJnlLine2@1003 : Record "Item Journal Line";SignFactor@1001 : Integer;VAR NonDistrQuantity@1005 : Decimal;VAR NonDistrAmount@1006 : Decimal;VAR NonDistrAmountACY@1007 : Decimal;VAR NonDistrDiscountAmount@1008 : Decimal;Invoice@1002 : Boolean) : Boolean;
    VAR
      FloatingFactor@1004 : Decimal;
      PostItemJnlLine@1000 : Boolean;
    BEGIN
      with TempSplitItemJnlLine do begin
        "Quantity (Base)" := SignFactor * TempTrackingSpecification."Qty. to Handle (Base)";
        Quantity := SignFactor * TempTrackingSpecification."Qty. to Handle";
        if Invoice then begin
          "Invoiced Quantity" := SignFactor * TempTrackingSpecification."Qty. to Invoice";
          "Invoiced Qty. (Base)" := SignFactor * TempTrackingSpecification."Qty. to Invoice (Base)";
        end;

        if ItemJnlLine2."Output Quantity" <> 0 then begin
          "Output Quantity (Base)" := "Quantity (Base)";
          "Output Quantity" := Quantity;
        end;

        if ItemJnlLine2."Phys. Inventory" then
          "Qty. (Phys. Inventory)" := "Qty. (Calculated)" + SignFactor * "Quantity (Base)";

        FloatingFactor := Quantity / NonDistrQuantity;
        if FloatingFactor < 1 then begin
          Amount := ROUND(NonDistrAmount * FloatingFactor,GLSetup."Amount Rounding Precision");
          "Amount (ACY)" := ROUND(NonDistrAmountACY * FloatingFactor,Currency."Amount Rounding Precision");
          "Discount Amount" := ROUND(NonDistrDiscountAmount * FloatingFactor,GLSetup."Amount Rounding Precision");
          NonDistrAmount := NonDistrAmount - Amount;
          NonDistrAmountACY := NonDistrAmountACY - "Amount (ACY)";
          NonDistrDiscountAmount := NonDistrDiscountAmount - "Discount Amount";
          NonDistrQuantity := NonDistrQuantity - Quantity;
          "Setup Time" := 0;
          "Run Time" := 0;
          "Stop Time" := 0;
          "Setup Time (Base)" := 0;
          "Run Time (Base)" := 0;
          "Stop Time (Base)" := 0;
          "Starting Time" := 000000T;
          "Ending Time" := 000000T;
          "Scrap Quantity" := 0;
          "Scrap Quantity (Base)" := 0;
          "Concurrent Capacity" := 0;
        end else begin // the last record
          Amount := NonDistrAmount;
          "Amount (ACY)" := NonDistrAmountACY;
          "Discount Amount" := NonDistrDiscountAmount;
        end;

        if ROUND("Unit Amount" * Quantity,GLSetup."Amount Rounding Precision") <> Amount then
          if ("Unit Amount" = "Unit Cost") and ("Unit Cost" <> 0) then begin
            "Unit Amount" := ROUND(Amount / Quantity,0.00001);
            "Unit Cost" := ROUND(Amount / Quantity,0.00001);
            "Unit Cost (ACY)" := ROUND("Amount (ACY)" / Quantity,0.00001);
          end else
            "Unit Amount" := ROUND(Amount / Quantity,0.00001);

        "Serial No." := TempTrackingSpecification."Serial No.";
        "Lot No." := TempTrackingSpecification."Lot No.";
        "New Serial No." := TempTrackingSpecification."New Serial No.";
        "New Lot No." := TempTrackingSpecification."New Lot No.";
        "Item Expiration Date" := TempTrackingSpecification."Expiration Date";
        "New Item Expiration Date" := TempTrackingSpecification."New Expiration Date";

        PostItemJnlLine :=
          ("Serial No." <> "New Serial No.") or
          ("Lot No." <> "New Lot No.") or
          ("Item Expiration Date" <> "New Item Expiration Date");

        "Warranty Date" := TempTrackingSpecification."Warranty Date";

        "Line No." := TempTrackingSpecification."Entry No.";

        if TempTrackingSpecification.Correction or "Drop Shipment" or IsServUndoConsumption then
          "Applies-to Entry" := TempTrackingSpecification."Item Ledger Entry No."
        else
          "Applies-to Entry" := TempTrackingSpecification."Appl.-to Item Entry";
        "Applies-from Entry" := TempTrackingSpecification."Appl.-from Item Entry";
        INSERT;
      end;

      exit(PostItemJnlLine);
    END;

    LOCAL PROCEDURE ReservationExists@100(ItemJnlLine@1000 : Record "Item Journal Line") : Boolean;
    VAR
      ReservEntry@1001 : Record "Reservation Entry";
      ProductionOrder@1002 : Record "Production Order";
    BEGIN
      with ReservEntry do begin
        SETRANGE("Source ID",ItemJnlLine."Order No.");
        if ItemJnlLine."Prod. Order Comp. Line No." <> 0 then
          SETRANGE("Source Ref. No.",ItemJnlLine."Prod. Order Comp. Line No.");
        SETRANGE("Source Type",DATABASE::"Prod. Order Component");
        SETRANGE("Source Subtype",ProductionOrder.Status::Released);
        SETRANGE("Source Batch Name",'');
        SETRANGE("Source Prod. Order Line",ItemJnlLine."Order Line No.");
        SETFILTER("Qty. to Handle (Base)",'<>0');
        exit(not ISEMPTY);
      end;
    END;

    LOCAL PROCEDURE VerifyTouchedOnInventory@103();
    VAR
      ItemLedgEntryApplied@1000 : Record "Item Ledger Entry";
    BEGIN
      with TouchedItemLedgerEntries do begin
        FINDSET;
        repeat
          ItemLedgEntryApplied.GET("Entry No.");
          ItemLedgEntryApplied.VerifyOnInventory;
        until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE CheckIsCyclicalLoop@115(ItemLedgEntry@1000 : Record "Item Ledger Entry";OldItemLedgEntry@1001 : Record "Item Ledger Entry";VAR PrevAppliedItemLedgEntry@1003 : Record "Item Ledger Entry";VAR AppliedQty@1002 : Decimal);
    VAR
      PrevProcessedProdOrder@1004 : Boolean;
    BEGIN
      PrevProcessedProdOrder :=
        (ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Consumption) and
        (OldItemLedgEntry."Entry Type" = OldItemLedgEntry."Entry Type"::Output) and
        (ItemLedgEntry."Order Type" = ItemLedgEntry."Order Type"::Production) and
        EntriesInTheSameOrder(OldItemLedgEntry,PrevAppliedItemLedgEntry);

      if not PrevProcessedProdOrder then
        if AppliedQty <> 0 then
          if ItemLedgEntry.Positive then begin
            if ItemApplnEntry.CheckIsCyclicalLoop(ItemLedgEntry,OldItemLedgEntry) then
              AppliedQty := 0;
          end else
            if ItemApplnEntry.CheckIsCyclicalLoop(OldItemLedgEntry,ItemLedgEntry) then
              AppliedQty := 0;

      if AppliedQty <> 0 then
        PrevAppliedItemLedgEntry := OldItemLedgEntry;
    END;

    LOCAL PROCEDURE EntriesInTheSameOrder@116(OldItemLedgEntry@1001 : Record "Item Ledger Entry";PrevAppliedItemLedgEntry@1000 : Record "Item Ledger Entry") : Boolean;
    BEGIN
      exit(
        (PrevAppliedItemLedgEntry."Order Type" = PrevAppliedItemLedgEntry."Order Type"::Production) and
        (OldItemLedgEntry."Order Type" = OldItemLedgEntry."Order Type"::Production) and
        (OldItemLedgEntry."Order No." = PrevAppliedItemLedgEntry."Order No.") and
        (OldItemLedgEntry."Order Line No." = PrevAppliedItemLedgEntry."Order Line No."));
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertTransferEntry@104(VAR NewItemLedgerEntry@1000 : Record "Item Ledger Entry";VAR OldItemLedgerEntry@1002 : Record "Item Ledger Entry";VAR ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertPhysInvtLedgEntry@51(VAR PhysInventoryLedgerEntry@1000 : Record "Phys. Inventory Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInitItemLedgEntry@105(VAR NewItemLedgEntry@1000 : Record "Item Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertItemLedgEntry@106(VAR ItemLedgerEntry@1000 : Record "Item Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertItemLedgEntry@147(VAR ItemLedgerEntry@1000 : Record "Item Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertValueEntry@108(VAR ValueEntry@1001 : Record "Value Entry";ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertValueEntry@107(VAR ValueEntry@1000 : Record "Value Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInitValueEntry@137(VAR ValueEntry@1000 : Record "Value Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertCapLedgEntry@148(VAR CapLedgEntry@1000 : Record "Capacity Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertCapLedgEntry@139(VAR CapLedgEntry@1000 : Record "Capacity Ledger Entry";ItemJournalLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertCapValueEntry@149(VAR ValueEntry@1000 : Record "Value Entry";ItemJnlLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertCapValueEntry@143(VAR ValueEntry@1000 : Record "Value Entry";ItemJnlLine@1001 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertCorrItemLedgEntry@109(VAR NewItemLedgerEntry@1000 : Record "Item Ledger Entry";OldItemLedgerEntry@1001 : Record "Item Ledger Entry";VAR ItemJournalLine@1002 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertCorrItemLedgEntry@110(VAR NewItemLedgerEntry@1002 : Record "Item Ledger Entry";ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeInsertCorrValueEntry@111(VAR NewValueEntry@1000 : Record "Value Entry";OldValueEntry@1001 : Record "Value Entry";VAR ItemJournalLine@1002 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterInsertCorrValueEntry@112(VAR NewValueEntry@1002 : Record "Value Entry";VAR ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforePostItemJnlLine@113(VAR ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterPostItemJnlLine@114(VAR ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
    END;

    LOCAL PROCEDURE PrepareItem@130(ItemJnlLineToPost@1000 : Record "Item Journal Line");
    BEGIN
      ItemJnlLine.COPY(ItemJnlLineToPost);

      GetGLSetup;
      GetInvtSetup;
      CheckItem(ItemJnlLineToPost."Item No.");
    END;

    [External]
    PROCEDURE SetSkipApplicationCheck@117(NewValue@1000 : Boolean);
    BEGIN
      SkipApplicationCheck := NewValue;
    END;

    [External]
    PROCEDURE LogApply@118(ApplyItemLedgEntry@1003 : Record "Item Ledger Entry";AppliedItemLedgEntry@1001 : Record "Item Ledger Entry");
    VAR
      ItemApplnEntry@1000 : Record "Item Application Entry";
    BEGIN
      ItemApplnEntry.INIT;
      if AppliedItemLedgEntry.Quantity > 0 then begin
        ItemApplnEntry."Item Ledger Entry No." := ApplyItemLedgEntry."Entry No.";
        ItemApplnEntry."Inbound Item Entry No." := AppliedItemLedgEntry."Entry No.";
        ItemApplnEntry."Outbound Item Entry No." := ApplyItemLedgEntry."Entry No.";
      end else begin
        ItemApplnEntry."Item Ledger Entry No." := AppliedItemLedgEntry."Entry No.";
        ItemApplnEntry."Inbound Item Entry No." := ApplyItemLedgEntry."Entry No.";
        ItemApplnEntry."Outbound Item Entry No." := AppliedItemLedgEntry."Entry No.";
      end;
      AddToApplicationLog(ItemApplnEntry,true);
    END;

    [External]
    PROCEDURE LogUnapply@119(ItemApplnEntry@1000 : Record "Item Application Entry");
    BEGIN
      AddToApplicationLog(ItemApplnEntry,false);
    END;

    LOCAL PROCEDURE AddToApplicationLog@120(ItemApplnEntry@1000 : Record "Item Application Entry";IsApplication@1002 : Boolean);
    BEGIN
      with TempItemApplnEntryHistory do begin
        if FINDLAST then;
        "Primary Entry No." += 1;

        "Item Ledger Entry No." := ItemApplnEntry."Item Ledger Entry No.";
        "Inbound Item Entry No." := ItemApplnEntry."Inbound Item Entry No.";
        "Outbound Item Entry No." := ItemApplnEntry."Outbound Item Entry No.";

        "Cost Application" := IsApplication;
        INSERT;
      end;
    END;

    [External]
    PROCEDURE ClearApplicationLog@121();
    BEGIN
      TempItemApplnEntryHistory.DELETEALL;
    END;

    [Internal]
    PROCEDURE UndoApplications@122();
    VAR
      ItemLedgEntry@1000 : Record "Item Ledger Entry";
      ItemApplnEntry@1001 : Record "Item Application Entry";
    BEGIN
      with TempItemApplnEntryHistory do begin
        ASCENDING(false);
        if FINDSET then
          repeat
            if "Cost Application" then begin
              ItemApplnEntry.SETRANGE("Inbound Item Entry No.","Inbound Item Entry No.");
              ItemApplnEntry.SETRANGE("Outbound Item Entry No.","Outbound Item Entry No.");
              ItemApplnEntry.FINDFIRST;
              UnApply(ItemApplnEntry);
            end else begin
              ItemLedgEntry.GET("Item Ledger Entry No.");
              SetSkipApplicationCheck(true);
              ReApply(ItemLedgEntry,"Inbound Item Entry No.");
            end;
          until NEXT = 0;
        ClearApplicationLog;
        ASCENDING(true);
      end;
    END;

    [External]
    PROCEDURE ApplicationLogIsEmpty@123() : Boolean;
    BEGIN
      exit(TempItemApplnEntryHistory.ISEMPTY);
    END;

    LOCAL PROCEDURE AppliedEntriesToReadjust@124(ItemLedgEntry@1000 : Record "Item Ledger Entry") : Boolean;
    BEGIN
      with ItemLedgEntry do
        exit("Entry Type" in ["Entry Type"::Output,"Entry Type"::"Assembly Output"]);
    END;

    LOCAL PROCEDURE GetTextStringWithLineNo@125(BasicTextString@1000 : Text;ItemNo@1002 : Code[20];LineNo@1001 : Integer) : Text;
    BEGIN
      if LineNo = 0 then
        exit(STRSUBSTNO(BasicTextString,ItemNo));
      exit(STRSUBSTNO(BasicTextString,ItemNo) + STRSUBSTNO(LineNoTxt,LineNo));
    END;

    [External]
    PROCEDURE SetCalledFromApplicationWorksheet@134(IsCalledFromApplicationWorksheet@1000 : Boolean);
    BEGIN
      CalledFromApplicationWorksheet := IsCalledFromApplicationWorksheet;
    END;

    LOCAL PROCEDURE SaveTouchedEntry@133(ItemLedgerEntryNo@1003 : Integer;IsInbound@1002 : Boolean);
    VAR
      ItemApplicationEntryHistory@1000 : Record "Item Application Entry History";
      NextEntryNo@1001 : Integer;
    BEGIN
      if not CalledFromApplicationWorksheet then
        exit;

      with ItemApplicationEntryHistory do begin
        if FINDLAST then
          NextEntryNo := "Primary Entry No." + 1
        else
          NextEntryNo := 1;

        INIT;
        "Primary Entry No." := NextEntryNo;
        "Entry No." := 0;
        "Item Ledger Entry No." := ItemLedgerEntryNo;
        if IsInbound then
          "Inbound Item Entry No." := ItemLedgerEntryNo
        else
          "Outbound Item Entry No." := ItemLedgerEntryNo;
        "Creation Date" := CURRENTDATETIME;
        "Created By User" := USERID;
        INSERT;
      end;
    END;

    [External]
    PROCEDURE RestoreTouchedEntries@135(VAR TempItem@1000 : TEMPORARY Record Item);
    VAR
      ItemApplicationEntryHistory@1001 : Record "Item Application Entry History";
      ItemLedgerEntry@1003 : Record "Item Ledger Entry";
    BEGIN
      with ItemApplicationEntryHistory do begin
        SETRANGE("Entry No.",0);
        SETRANGE("Created By User",UPPERCASE(USERID));
        if FINDSET then
          repeat
            TouchEntry("Item Ledger Entry No.");

            ItemLedgerEntry.GET("Item Ledger Entry No.");
            TempItem."No." := ItemLedgerEntry."Item No.";
            if TempItem.INSERT then;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE DeleteTouchedEntries@132();
    VAR
      ItemApplicationEntryHistory@1001 : Record "Item Application Entry History";
    BEGIN
      if not CalledFromApplicationWorksheet then
        exit;

      with ItemApplicationEntryHistory do begin
        SETRANGE("Entry No.",0);
        SETRANGE("Created By User",UPPERCASE(USERID));
        DELETEALL;
      end;
    END;

    LOCAL PROCEDURE VerifyItemJnlLineAsembleToOrder@127(VAR ItemJournalLine@1000 : Record "Item Journal Line");
    BEGIN
      ItemJournalLine.TESTFIELD("Applies-to Entry");

      ItemJournalLine.CALCFIELDS("Reserved Qty. (Base)");
      ItemJournalLine.TESTFIELD("Reserved Qty. (Base)");
    END;

    LOCAL PROCEDURE VerifyItemJnlLineApplication@129(VAR ItemJournalLine@1000 : Record "Item Journal Line";ItemLedgerEntry@1001 : Record "Item Ledger Entry");
    BEGIN
      if ItemJournalLine."Applies-to Entry" = 0 then
        exit;

      ItemJournalLine.CALCFIELDS("Reserved Qty. (Base)");
      if ItemJournalLine."Reserved Qty. (Base)" <> 0 then
        ItemLedgerEntry.FIELDERROR("Applies-to Entry",Text99000000);
    END;

    LOCAL PROCEDURE GetCombinedDimSetID@136(DimSetID1@1000 : Integer;DimSetID2@1001 : Integer) : Integer;
    VAR
      DimMgt@1004 : Codeunit DimensionManagement;
      DummyGlobalDimCode@1002 : ARRAY [2] OF Code[20];
      DimID@1003 : ARRAY [10] OF Integer;
    BEGIN
      DimID[1] := DimSetID1;
      DimID[2] := DimSetID2;
      exit(DimMgt.GetCombinedDimensionSetID(DimID,DummyGlobalDimCode[1],DummyGlobalDimCode[2]));
    END;

    LOCAL PROCEDURE CalcILEExpectedAmount@144(VAR OldValueEntry@1001 : Record "Value Entry";ItemLedgerEntryNo@1002 : Integer);
    VAR
      OldValueEntry2@1000 : Record "Value Entry";
    BEGIN
      OldValueEntry.FindFirstValueEntryByItemLedgerEntryNo(ItemLedgerEntryNo);
      OldValueEntry2.COPY(OldValueEntry);
      OldValueEntry2.SETFILTER("Entry No.",'<>%1',OldValueEntry."Entry No.");
      OldValueEntry2.CALCSUMS("Cost Amount (Expected)","Cost Amount (Expected) (ACY)");
      OldValueEntry."Cost Amount (Expected)" += OldValueEntry2."Cost Amount (Expected)";
      OldValueEntry."Cost Amount (Expected) (ACY)" += OldValueEntry2."Cost Amount (Expected) (ACY)";
    END;

    BEGIN
    END.
  }
}

