OBJECT Codeunit 99000854 Inventory Profile Offsetting
{
  OBJECT-PROPERTIES
  {
    Date=20171006D;
    Time=120000T;
    Version List=NAVW111.0;
  }
  PROPERTIES
  {
    Permissions=TableData "Reservation Entry"=id;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      ReqLine@1003 : Record "Requisition Line";
      ItemLedgEntry@1004 : Record "Item Ledger Entry";
      TempSKU@1005 : TEMPORARY Record "Stockkeeping Unit";
      TempTransferSKU@1035 : TEMPORARY Record "Stockkeeping Unit";
      ManufacturingSetup@1007 : Record "Manufacturing Setup";
      InvtSetup@1008 : Record "Inventory Setup";
      ReservEntry@1009 : Record "Reservation Entry";
      TempTrkgReservEntry@1010 : TEMPORARY Record "Reservation Entry";
      TempItemTrkgEntry@1000 : TEMPORARY Record "Reservation Entry";
      ActionMsgEntry@1011 : Record "Action Message Entry";
      TempPlanningCompList@1013 : TEMPORARY Record "Planning Component";
      DummyInventoryProfileTrackBuffer@1048 : Record "Inventory Profile Track Buffer";
      CustomizedCalendarChange@1047 : Record "Customized Calendar Change";
      CalendarManagement@1012 : Codeunit "Calendar Management";
      LeadTimeMgt@1014 : Codeunit "Lead-Time Management";
      PlngLnMgt@1031 : Codeunit "Planning Line Management";
      Transparency@1034 : Codeunit "Planning Transparency";
      BucketSize@1041 : DateFormula;
      ExcludeForecastBefore@1006 : Date;
      ScheduleDirection@1025 : 'Forward,Backward';
      PlanningLineStage@1022 : '" ","Line Created","Routing Created",Exploded,Obsolete';
      SurplusType@1021 : 'None,Forecast,BlanketOrder,SafetyStock,ReorderPoint,MaxInventory,FixedOrderQty,MaxOrder,MinOrder,OrderMultiple,DampenerQty,PlanningFlexibility,Undefined,EmergencyOrder';
      CurrWorksheetType@1049 : 'Requisition,Planning';
      DampenerQty@1020 : Decimal;
      FutureSupplyWithinLeadtime@1044 : Decimal;
      LineNo@1019 : Integer;
      DampenersDays@1018 : Integer;
      BucketSizeInDays@1042 : Integer;
      CurrTemplateName@1016 : Code[10];
      CurrWorksheetName@1017 : Code[10];
      CurrForecast@1028 : Code[10];
      PlanMRP@1023 : Boolean;
      SpecificLotTracking@1001 : Boolean;
      SpecificSNTracking@1024 : Boolean;
      Text001@1029 : TextConst 'ENU=Assertion failed: %1.';
      UseParm@1030 : Boolean;
      PlanningResilicency@1002 : Boolean;
      Text002@1033 : TextConst 'ENU=The %1 from ''%2'' to ''%3'' does not exist.';
      Text003@1032 : TextConst 'ENU=The %1 for %2 %3 %4 %5 does not exist.';
      Text004@1026 : TextConst 'ENU=%1 must not be %2 in %3 %4 %5 %6 when %7 is %8.';
      Text005@1027 : TextConst 'ENU=%1 must not be %2 in %3 %4 when %5 is %6.';
      Text006@1037 : TextConst 'ENU=%1: The projected available inventory is %2 on the planning starting date %3.';
      Text007@1038 : TextConst 'ENU=%1: The projected available inventory is below %2 %3 on %4.';
      Text008@1039 : TextConst 'ENU=%1: The %2 %3 is before the work date %4.';
      Text009@1040 : TextConst 'ENU=%1: The %2 of %3 %4 is %5.';
      Text010@1043 : TextConst 'ENU=The projected inventory %1 is higher than the overflow level %2 on %3.';
      PlanToDate@1045 : Date;
      OverflowLevel@1046 : Decimal;
      ExceedROPqty@1015 : Decimal;
      NextStateTxt@1036 : TextConst 'ENU=StartOver,MatchDates,MatchQty,CreateSupply,ReduceSupply,CloseDemand,CloseSupply,CloseLoop';

    [Internal]
    PROCEDURE CalculatePlanFromWorksheet@3(VAR Item@1000 : Record Item;ManufacturingSetup2@1001 : Record "Manufacturing Setup";TemplateName@1002 : Code[10];WorksheetName@1003 : Code[10];OrderDate@1004 : Date;ToDate@1005 : Date;MRPPlanning@1006 : Boolean;RespectPlanningParm@1008 : Boolean);
    VAR
      InventoryProfile@1007 : ARRAY [2] OF TEMPORARY Record "Inventory Profile";
    BEGIN
      PlanToDate := ToDate;
      InitVariables(InventoryProfile[1],ManufacturingSetup2,Item,TemplateName,WorksheetName,MRPPlanning);
      DemandtoInvProfile(InventoryProfile[1],Item,ToDate);
      OrderDate := ForecastConsumption(InventoryProfile[1],Item,OrderDate,ToDate);
      BlanketOrderConsump(InventoryProfile[1],Item,ToDate);
      SupplytoInvProfile(InventoryProfile[1],Item,ToDate);
      UnfoldItemTracking(InventoryProfile[1],InventoryProfile[2]);
      FindCombination(InventoryProfile[1],InventoryProfile[2],Item);
      PlanItem(InventoryProfile[1],InventoryProfile[2],OrderDate,ToDate,RespectPlanningParm);
      CommitTracking;
    END;

    LOCAL PROCEDURE InitVariables@12(VAR InventoryProfile@1000 : Record "Inventory Profile";ManufacturingSetup2@1001 : Record "Manufacturing Setup";Item@1006 : Record Item;TemplateName@1002 : Code[10];WorksheetName@1003 : Code[10];MRPPlanning@1005 : Boolean);
    VAR
      ItemTrackingCode@1007 : Record "Item Tracking Code";
    BEGIN
      ManufacturingSetup := ManufacturingSetup2;
      InvtSetup.GET;
      CurrTemplateName := TemplateName;
      CurrWorksheetName := WorksheetName;
      InventoryProfile.RESET;
      InventoryProfile.DELETEALL;
      TempSKU.RESET;
      TempSKU.DELETEALL;
      CLEAR(TempSKU);
      TempTransferSKU.RESET;
      TempTransferSKU.DELETEALL;
      CLEAR(TempTransferSKU);
      TempTrkgReservEntry.RESET;
      TempTrkgReservEntry.DELETEALL;
      TempItemTrkgEntry.RESET;
      TempItemTrkgEntry.DELETEALL;
      PlanMRP := MRPPlanning;
      if Item."Item Tracking Code" <> '' then begin
        ItemTrackingCode.GET(Item."Item Tracking Code");
        SpecificLotTracking := ItemTrackingCode."Lot Specific Tracking";
        SpecificSNTracking := ItemTrackingCode."SN Specific Tracking";
      end else begin
        SpecificLotTracking := false;
        SpecificSNTracking := false;
      end;
      LineNo := 0; // Global variable
      Transparency.SetTemplAndWorksheet(CurrTemplateName,CurrWorksheetName);
    END;

    LOCAL PROCEDURE CreateTempSKUForLocation@115(ItemNo@1000 : Code[20];LocationCode@1001 : Code[10]);
    BEGIN
      TempSKU.INIT;
      TempSKU."Item No." := ItemNo;
      TransferPlanningParameters(TempSKU);
      TempSKU."Location Code" := LocationCode;
      TempSKU.INSERT;
    END;

    LOCAL PROCEDURE DemandtoInvProfile@6(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR Item@1001 : Record Item;ToDate@1003 : Date);
    VAR
      CopyOfItem@1002 : Record Item;
    BEGIN
      InventoryProfile.SETCURRENTKEY("Line No.");

      CopyOfItem.COPY(Item);
      Item.SETRANGE("Date Filter",0D,ToDate);

      TransSalesLineToProfile(InventoryProfile,Item);
      TransServLineToProfile(InventoryProfile,Item);
      TransJobPlanningLineToProfile(InventoryProfile,Item);
      TransProdOrderCompToProfile(InventoryProfile,Item);
      TransAsmLineToProfile(InventoryProfile,Item);
      TransPlanningCompToProfile(InventoryProfile,Item);
      TransTransReqLineToProfile(InventoryProfile,Item,ToDate);
      TransShptTransLineToProfile(InventoryProfile,Item);

      Item.COPY(CopyOfItem);
    END;

    LOCAL PROCEDURE SupplytoInvProfile@9(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR Item@1001 : Record Item;ToDate@1002 : Date);
    VAR
      CopyOfItem@1003 : Record Item;
    BEGIN
      InventoryProfile.RESET;
      ItemLedgEntry.RESET;
      InventoryProfile.SETCURRENTKEY("Line No.");

      CopyOfItem.COPY(Item);
      Item.SETRANGE("Date Filter");

      TransItemLedgEntryToProfile(InventoryProfile,Item);
      TransReqLineToProfile(InventoryProfile,Item,ToDate);
      TransPurchLineToProfile(InventoryProfile,Item,ToDate);
      TransProdOrderToProfile(InventoryProfile,Item,ToDate);
      TransAsmHeaderToProfile(InventoryProfile,Item,ToDate);
      TransRcptTransLineToProfile(InventoryProfile,Item,ToDate);

      Item.COPY(CopyOfItem);
    END;

    LOCAL PROCEDURE InsertSupplyProfile@22(VAR InventoryProfile@1002 : Record "Inventory Profile";ToDate@1000 : Date);
    BEGIN
      if InventoryProfile.IsSupply then begin
        if InventoryProfile."Due Date" > ToDate then
          InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
        InventoryProfile.INSERT;
      end else
        if InventoryProfile."Due Date" <= ToDate then begin
          InventoryProfile.ChangeSign;
          InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
          InventoryProfile.INSERT;
        end;
    END;

    LOCAL PROCEDURE TransSalesLineToProfile@55(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      SalesLine@1007 : Record "Sales Line";
    BEGIN
      if SalesLine.FindLinesWithItemToPlan(Item,SalesLine."Document Type"::Order) then
        repeat
          if SalesLine."Shipment Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromSalesLine(SalesLine,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            InventoryProfile."MPS Order" := true;
            InventoryProfile.INSERT;
          end;
        until SalesLine.NEXT = 0;

      if SalesLine.FindLinesWithItemToPlan(Item,SalesLine."Document Type"::"Return Order") then
        repeat
          if SalesLine."Shipment Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromSalesLine(SalesLine,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            InventoryProfile.INSERT;
          end;
        until SalesLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransServLineToProfile@56(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      ServLine@1006 : Record "Service Line";
    BEGIN
      if ServLine.FindLinesWithItemToPlan(Item) then
        repeat
          if ServLine."Needed by Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromServLine(ServLine,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            InventoryProfile.INSERT;
          end;
        until ServLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransJobPlanningLineToProfile@121(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      JobPlanningLine@1005 : Record "Job Planning Line";
    BEGIN
      if JobPlanningLine.FindLinesWithItemToPlan(Item) then
        repeat
          if JobPlanningLine."Planning Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromJobPlanningLine(JobPlanningLine,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            InventoryProfile.INSERT;
          end;
        until JobPlanningLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransProdOrderCompToProfile@70(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      ProdOrderComp@1004 : Record "Prod. Order Component";
    BEGIN
      if not PlanMRP then
        exit;
      if ProdOrderComp.FindLinesWithItemToPlan(Item,true) then
        repeat
          if ProdOrderComp."Due Date" <> 0D then begin
            ReqLine.SetRefFilter(
              ReqLine."Ref. Order Type"::"Prod. Order",ProdOrderComp.Status,
              ProdOrderComp."Prod. Order No.",ProdOrderComp."Prod. Order Line No.");
            ReqLine.SETRANGE("Operation No.",'');
            if not ReqLine.FINDFIRST then begin
              InventoryProfile.INIT;
              InventoryProfile."Line No." := NextLineNo;
              InventoryProfile.TransferFromComponent(ProdOrderComp,TempItemTrkgEntry);
              if InventoryProfile.IsSupply then
                InventoryProfile.ChangeSign;
              InventoryProfile.INSERT;
            end;
          end;
        until ProdOrderComp.NEXT = 0;
    END;

    LOCAL PROCEDURE TransPlanningCompToProfile@74(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      PlanningComponent@1003 : Record "Planning Component";
    BEGIN
      if not PlanMRP then
        exit;

      if PlanningComponent.FindLinesWithItemToPlan(Item) then
        repeat
          if PlanningComponent."Due Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile."Item No." := Item."No.";
            InventoryProfile.TransferFromPlanComponent(PlanningComponent,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            InventoryProfile.INSERT;
          end;
        until PlanningComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE TransAsmLineToProfile@90(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    VAR
      AsmHeader@1006 : Record "Assembly Header";
      AsmLine@1007 : Record "Assembly Line";
      RemRatio@1005 : Decimal;
    BEGIN
      if AsmLine.FindLinesWithItemToPlan(Item,AsmLine."Document Type"::Order) then
        repeat
          if AsmLine."Due Date" <> 0D then begin
            ReqLine.SetRefFilter(
              ReqLine."Ref. Order Type"::Assembly,AsmLine."Document Type",AsmLine."Document No.",0);
            ReqLine.SETRANGE("Operation No.",'');
            if not ReqLine.FINDFIRST then
              InsertAsmLineToProfile(InventoryProfile,AsmLine,1);
          end;
        until AsmLine.NEXT = 0;

      if AsmLine.FindLinesWithItemToPlan(Item,AsmLine."Document Type"::"Blanket Order") then
        repeat
          if AsmLine."Due Date" <> 0D then begin
            ReqLine.SetRefFilter(ReqLine."Ref. Order Type"::Assembly,AsmLine."Document Type",AsmLine."Document No.",0);
            ReqLine.SETRANGE("Operation No.",'');
            if not ReqLine.FINDFIRST then begin
              AsmHeader.GET(AsmLine."Document Type",AsmLine."Document No.");
              RemRatio := (AsmHeader."Quantity (Base)" - CalcSalesOrderQty(AsmLine)) / AsmHeader."Quantity (Base)";
              InsertAsmLineToProfile(InventoryProfile,AsmLine,RemRatio);
            end;
          end;
        until AsmLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransTransReqLineToProfile@85(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1003 : Date);
    VAR
      TransferReqLine@1002 : Record "Requisition Line";
    BEGIN
      TransferReqLine.SETCURRENTKEY("Replenishment System",Type,"No.","Variant Code","Transfer-from Code","Transfer Shipment Date");
      TransferReqLine.SETRANGE("Replenishment System",TransferReqLine."Replenishment System"::Transfer);
      TransferReqLine.SETRANGE(Type,TransferReqLine.Type::Item);
      TransferReqLine.SETRANGE("No.",Item."No.");
      Item.COPYFILTER("Location Filter",TransferReqLine."Transfer-from Code");
      Item.COPYFILTER("Variant Filter",TransferReqLine."Variant Code");
      TransferReqLine.SETFILTER("Transfer Shipment Date",'>%1&<=%2',0D,ToDate);
      if TransferReqLine.FINDSET then
        repeat
          InventoryProfile.INIT;
          InventoryProfile."Line No." := NextLineNo;
          InventoryProfile."Item No." := Item."No.";
          InventoryProfile.TransferFromOutboundTransfPlan(TransferReqLine,TempItemTrkgEntry);
          if InventoryProfile.IsSupply then
            InventoryProfile.ChangeSign;
          InventoryProfile.INSERT;
        until TransferReqLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransShptTransLineToProfile@75(VAR InventoryProfile@1003 : Record "Inventory Profile";VAR Item@1002 : Record Item);
    VAR
      TransLine@1001 : Record "Transfer Line";
      FilterIsSetOnLocation@1000 : Boolean;
    BEGIN
      FilterIsSetOnLocation := Item.GETFILTER("Location Filter") <> '';
      if TransLine.FindLinesWithItemToPlan(Item,false,true) then
        repeat
          if TransLine."Shipment Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile."Item No." := Item."No.";
            InventoryProfile.TransferFromOutboundTransfer(TransLine,TempItemTrkgEntry);
            if InventoryProfile.IsSupply then
              InventoryProfile.ChangeSign;
            if FilterIsSetOnLocation then
              InventoryProfile."Transfer Location Not Planned" := TransferLocationIsFilteredOut(Item,TransLine);
            SyncTransferDemandWithReqLine(InventoryProfile,TransLine."Transfer-to Code");
            InventoryProfile.INSERT;
          end;
        until TransLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransItemLedgEntryToProfile@76(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item);
    BEGIN
      if ItemLedgEntry.FindLinesWithItemToPlan(Item,false) then
        repeat
          InventoryProfile.INIT;
          InventoryProfile."Line No." := NextLineNo;
          InventoryProfile.TransferFromItemLedgerEntry(ItemLedgEntry,TempItemTrkgEntry);
          InventoryProfile."Due Date" := 0D;
          if not InventoryProfile.IsSupply then
            InventoryProfile.ChangeSign;
          InventoryProfile.INSERT;
        until ItemLedgEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE TransReqLineToProfile@78(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1002 : Date);
    VAR
      ReqLine@1003 : Record "Requisition Line";
    BEGIN
      if ReqLine.FindLinesWithItemToPlan(Item) then
        repeat
          if ReqLine."Due Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile."Item No." := Item."No.";
            InventoryProfile.TransferFromRequisitionLine(ReqLine,TempItemTrkgEntry);
            InsertSupplyProfile(InventoryProfile,ToDate);
          end;
        until ReqLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransPurchLineToProfile@79(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1002 : Date);
    VAR
      PurchLine@1009 : Record "Purchase Line";
    BEGIN
      if PurchLine.FindLinesWithItemToPlan(Item,PurchLine."Document Type"::Order) then
        repeat
          if PurchLine."Expected Receipt Date" <> 0D then
            if PurchLine."Prod. Order No." = '' then
              InsertPurchLineToProfile(InventoryProfile,PurchLine,ToDate);
        until PurchLine.NEXT = 0;

      if PurchLine.FindLinesWithItemToPlan(Item,PurchLine."Document Type"::"Return Order") then
        repeat
          if PurchLine."Expected Receipt Date" <> 0D then
            if PurchLine."Prod. Order No." = '' then
              InsertPurchLineToProfile(InventoryProfile,PurchLine,ToDate);
        until PurchLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransProdOrderToProfile@82(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1002 : Date);
    VAR
      ProdOrderLine@1008 : Record "Prod. Order Line";
      CapLedgEntry@1005 : Record "Capacity Ledger Entry";
      ProdOrderComp@1009 : Record "Prod. Order Component";
    BEGIN
      if ProdOrderLine.FindLinesWithItemToPlan(Item,true) then
        repeat
          if ProdOrderLine."Due Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromProdOrderLine(ProdOrderLine,TempItemTrkgEntry);
            if (ProdOrderLine."Planning Flexibility" = ProdOrderLine."Planning Flexibility"::Unlimited) and
               (ProdOrderLine.Status = ProdOrderLine.Status::Released)
            then begin
              CapLedgEntry.SETCURRENTKEY("Order Type","Order No.");
              CapLedgEntry.SETRANGE("Order Type",CapLedgEntry."Order Type"::Production);
              CapLedgEntry.SETRANGE("Order No.",ProdOrderLine."Prod. Order No.");
              ItemLedgEntry.RESET;
              ItemLedgEntry.SETCURRENTKEY("Order Type","Order No.");
              ItemLedgEntry.SETRANGE("Order Type",ItemLedgEntry."Order Type"::Production);
              ItemLedgEntry.SETRANGE("Order No.",ProdOrderLine."Prod. Order No.");
              if not (CapLedgEntry.ISEMPTY and ItemLedgEntry.ISEMPTY) then
                InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None
              else begin
                ProdOrderComp.SETRANGE(Status,ProdOrderLine.Status);
                ProdOrderComp.SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
                ProdOrderComp.SETRANGE("Prod. Order Line No.",ProdOrderLine."Line No.");
                ProdOrderComp.SETFILTER("Qty. Picked (Base)",'>0');
                if not ProdOrderComp.ISEMPTY then
                  InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
              end;
            end;
            InsertSupplyProfile(InventoryProfile,ToDate);
          end;
        until ProdOrderLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransAsmHeaderToProfile@91(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1002 : Date);
    VAR
      AsmHeader@1009 : Record "Assembly Header";
    BEGIN
      if AsmHeader.FindLinesWithItemToPlan(Item,AsmHeader."Document Type"::Order) then
        repeat
          if AsmHeader."Due Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromAsmHeader(AsmHeader,TempItemTrkgEntry);
            if InventoryProfile."Finished Quantity" > 0 then
              InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
            InsertSupplyProfile(InventoryProfile,ToDate);
          end;
        until AsmHeader.NEXT = 0;
    END;

    LOCAL PROCEDURE TransRcptTransLineToProfile@83(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR Item@1000 : Record Item;ToDate@1004 : Date);
    VAR
      TransLine@1006 : Record "Transfer Line";
      WhseEntry@1003 : Record "Warehouse Entry";
      FilterIsSetOnLocation@1002 : Boolean;
    BEGIN
      FilterIsSetOnLocation := Item.GETFILTER("Location Filter") <> '';
      if TransLine.FindLinesWithItemToPlan(Item,true,true) then
        repeat
          if TransLine."Receipt Date" <> 0D then begin
            InventoryProfile.INIT;
            InventoryProfile."Line No." := NextLineNo;
            InventoryProfile.TransferFromInboundTransfer(TransLine,TempItemTrkgEntry);
            if TransLine."Planning Flexibility" = TransLine."Planning Flexibility"::Unlimited then
              if (InventoryProfile."Finished Quantity" > 0) or
                 (TransLine."Quantity Shipped" > 0) or (TransLine."Derived From Line No." > 0)
              then
                InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None
              else begin
                WhseEntry.SetSourceFilter(
                  DATABASE::"Transfer Line",0,InventoryProfile."Source ID",InventoryProfile."Source Ref. No.",true);
                if not WhseEntry.ISEMPTY then
                  InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
              end;
            if FilterIsSetOnLocation then
              InventoryProfile."Transfer Location Not Planned" := TransferLocationIsFilteredOut(Item,TransLine);
            InsertSupplyProfile(InventoryProfile,ToDate);
            InsertTempTransferSKU(TransLine);
          end;
        until TransLine.NEXT = 0;
    END;

    LOCAL PROCEDURE TransferLocationIsFilteredOut@39(VAR Item@1000 : Record Item;VAR TransLine@1001 : Record "Transfer Line") : Boolean;
    VAR
      TempTransLine@1002 : TEMPORARY Record "Transfer Line";
    BEGIN
      TempTransLine := TransLine;
      TempTransLine.INSERT;
      Item.COPYFILTER("Location Filter",TempTransLine."Transfer-from Code");
      Item.COPYFILTER("Location Filter",TempTransLine."Transfer-to Code");
      exit(TempTransLine.ISEMPTY);
    END;

    LOCAL PROCEDURE InsertPurchLineToProfile@125(VAR InventoryProfile@1000 : Record "Inventory Profile";PurchLine@1001 : Record "Purchase Line";ToDate@1002 : Date);
    BEGIN
      InventoryProfile.INIT;
      InventoryProfile."Line No." := NextLineNo;
      InventoryProfile.TransferFromPurchaseLine(PurchLine,TempItemTrkgEntry);
      if InventoryProfile."Finished Quantity" > 0 then
        InventoryProfile."Planning Flexibility" := InventoryProfile."Planning Flexibility"::None;
      InsertSupplyProfile(InventoryProfile,ToDate);
    END;

    LOCAL PROCEDURE InsertAsmLineToProfile@126(VAR InventoryProfile@1000 : Record "Inventory Profile";AsmLine@1001 : Record "Assembly Line";RemRatio@1002 : Decimal);
    BEGIN
      InventoryProfile.INIT;
      InventoryProfile."Line No." := NextLineNo;
      InventoryProfile.TransferFromAsmLine(AsmLine,TempItemTrkgEntry);
      if RemRatio <> 1 then begin
        InventoryProfile."Untracked Quantity" := ROUND(InventoryProfile."Untracked Quantity" * RemRatio,0.00001);
        InventoryProfile."Remaining Quantity (Base)" := InventoryProfile."Untracked Quantity";
      end;
      if InventoryProfile.IsSupply then
        InventoryProfile.ChangeSign;
      InventoryProfile.INSERT;
    END;

    LOCAL PROCEDURE ForecastConsumption@1(VAR Demand@1000 : Record "Inventory Profile";VAR Item@1001 : Record Item;OrderDate@1002 : Date;ToDate@1003 : Date) UpdatedOrderDate : Date;
    VAR
      ForecastEntry@1004 : Record "Production Forecast Entry";
      ForecastEntry2@1005 : Record "Production Forecast Entry";
      NextForecast@1006 : Record "Production Forecast Entry";
      TotalForecastQty@1009 : Decimal;
      ReplenishmentLocation@1011 : Code[10];
      ForecastExist@1007 : Boolean;
      NextForecastExist@1010 : Boolean;
      ReplenishmentLocationFound@1014 : Boolean;
      ComponentForecast@1016 : Boolean;
      ComponentForecastFrom@1017 : Boolean;
    BEGIN
      UpdatedOrderDate := OrderDate;
      ComponentForecastFrom := false;
      if not ManufacturingSetup."Use Forecast on Locations" then begin
        ReplenishmentLocationFound := FindReplishmentLocation(ReplenishmentLocation,Item);
        if InvtSetup."Location Mandatory" and not ReplenishmentLocationFound then
          ComponentForecastFrom := true;

        ForecastEntry.SETCURRENTKEY(
          "Production Forecast Name","Item No.","Component Forecast","Forecast Date","Location Code");
      end else
        ForecastEntry.SETCURRENTKEY(
          "Production Forecast Name","Item No.","Location Code","Forecast Date","Component Forecast");

      ItemLedgEntry.RESET;
      ItemLedgEntry.SETCURRENTKEY("Item No.",Open,"Variant Code",Positive,"Location Code");
      Demand.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date");

      NextForecast.COPY(ForecastEntry);

      if not UseParm then
        CurrForecast := ManufacturingSetup."Current Production Forecast";

      ForecastEntry.SETRANGE("Production Forecast Name",CurrForecast);
      ForecastEntry.SETRANGE("Forecast Date",ExcludeForecastBefore,ToDate);

      ForecastEntry.SETRANGE("Item No.",Item."No.");
      ForecastEntry2.COPY(ForecastEntry);
      Item.COPYFILTER("Location Filter",ForecastEntry2."Location Code");

      for ComponentForecast := ComponentForecastFrom to true do begin
        if ComponentForecast then begin
          ReplenishmentLocation := ManufacturingSetup."Components at Location";
          if InvtSetup."Location Mandatory" and (ReplenishmentLocation = '') then
            exit;
        end;
        ForecastEntry.SETRANGE("Component Forecast",ComponentForecast);
        ForecastEntry2.SETRANGE("Component Forecast",ComponentForecast);
        if ForecastEntry2.FIND('-') then
          repeat
            if ManufacturingSetup."Use Forecast on Locations" then begin
              ForecastEntry2.SETRANGE("Location Code",ForecastEntry2."Location Code");
              ItemLedgEntry.SETRANGE("Location Code",ForecastEntry2."Location Code");
              Demand.SETRANGE("Location Code",ForecastEntry2."Location Code");
            end else begin
              Item.COPYFILTER("Location Filter",ForecastEntry2."Location Code");
              Item.COPYFILTER("Location Filter",ItemLedgEntry."Location Code");
              Item.COPYFILTER("Location Filter",Demand."Location Code");
            end;
            ForecastEntry2.FIND('+');
            ForecastEntry2.COPYFILTER("Location Code",ForecastEntry."Location Code");
            Item.COPYFILTER("Location Filter",ForecastEntry2."Location Code");

            ForecastExist := CheckForecastExist(ForecastEntry,OrderDate,ToDate);

            if ForecastExist then
              repeat
                ForecastEntry.SETRANGE("Forecast Date",ForecastEntry."Forecast Date");
                ForecastEntry.CALCSUMS("Forecast Quantity (Base)");
                TotalForecastQty := ForecastEntry."Forecast Quantity (Base)";
                ForecastEntry.FIND('+');
                NextForecast.COPYFILTERS(ForecastEntry);
                NextForecast.SETRANGE("Forecast Date",ForecastEntry."Forecast Date" + 1,ToDate);
                if not NextForecast.FINDFIRST then
                  NextForecast."Forecast Date" := ToDate + 1
                else
                  repeat
                    NextForecast.SETRANGE("Forecast Date",NextForecast."Forecast Date");
                    NextForecast.CALCSUMS("Forecast Quantity (Base)");
                    if NextForecast."Forecast Quantity (Base)" = 0 then begin
                      NextForecast.SETRANGE("Forecast Date",NextForecast."Forecast Date" + 1,ToDate);
                      if not NextForecast.FINDFIRST then
                        NextForecast."Forecast Date" := ToDate + 1
                    end else
                      NextForecastExist := true
                  until (NextForecast."Forecast Date" = ToDate + 1) or NextForecastExist;
                NextForecastExist := false;

                ItemLedgEntry.SETRANGE("Item No.",Item."No.");
                ItemLedgEntry.SETRANGE(Positive,false);
                ItemLedgEntry.SETRANGE(Open);
                ItemLedgEntry.SETRANGE(
                  "Posting Date",ForecastEntry."Forecast Date",NextForecast."Forecast Date" - 1);
                Item.COPYFILTER("Variant Filter",ItemLedgEntry."Variant Code");
                if ComponentForecast then begin
                  ItemLedgEntry.SETRANGE("Entry Type",ItemLedgEntry."Entry Type"::Consumption);
                  ItemLedgEntry.CALCSUMS(Quantity);
                  TotalForecastQty += ItemLedgEntry.Quantity;
                end else begin
                  ItemLedgEntry.SETRANGE("Entry Type",ItemLedgEntry."Entry Type"::Sale);
                  ItemLedgEntry.SETRANGE("Derived from Blanket Order",false);
                  ItemLedgEntry.CALCSUMS(Quantity);
                  TotalForecastQty += ItemLedgEntry.Quantity;
                  ItemLedgEntry.SETRANGE("Derived from Blanket Order");
                  // Undo shipment shall neutralize consumption from sales
                  ItemLedgEntry.SETRANGE(Positive,true);
                  ItemLedgEntry.SETRANGE(Correction,true);
                  ItemLedgEntry.CALCSUMS(Quantity);
                  TotalForecastQty += ItemLedgEntry.Quantity;
                  ItemLedgEntry.SETRANGE(Correction);
                end;

                Demand.SETRANGE("Item No.",ForecastEntry."Item No.");
                Demand.SETRANGE(
                  "Due Date",ForecastEntry."Forecast Date",NextForecast."Forecast Date" - 1);
                if ComponentForecast then
                  Demand.SETFILTER(
                    "Source Type",
                    '%1|%2|%3',
                    DATABASE::"Prod. Order Component",
                    DATABASE::"Planning Component",
                    DATABASE::"Assembly Line")
                else
                  Demand.SETFILTER(
                    "Source Type",
                    '%1|%2',
                    DATABASE::"Sales Line",
                    DATABASE::"Service Line");
                if Demand.FIND('-') then
                  repeat
                    if not (Demand.IsSupply or Demand."Derived from Blanket Order")
                    then
                      TotalForecastQty := TotalForecastQty - Demand."Remaining Quantity (Base)";
                  until (Demand.NEXT = 0) or (TotalForecastQty < 0);
                if TotalForecastQty > 0 then begin
                  ForecastInitDemand(Demand,ForecastEntry,Item."No.",ReplenishmentLocation,TotalForecastQty);
                  Demand."Due Date" :=
                    CalendarManagement.CalcDateBOC2(
                      '<0D>',ForecastEntry."Forecast Date",
                      CustomizedCalendarChange."Source Type"::Location,Demand."Location Code",'',
                      CustomizedCalendarChange."Source Type"::Location,Demand."Location Code",'',false);
                  if Demand."Due Date" < UpdatedOrderDate then
                    UpdatedOrderDate := Demand."Due Date";
                  Demand.INSERT;
                end;
                ForecastEntry.SETRANGE("Forecast Date",ExcludeForecastBefore,ToDate);
              until ForecastEntry.NEXT = 0;
          until ForecastEntry2.NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE BlanketOrderConsump@38(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR Item@1001 : Record Item;ToDate@1002 : Date);
    VAR
      BlanketSalesLine@1003 : Record "Sales Line";
      QtyReleased@1005 : Decimal;
    BEGIN
      InventoryProfile.RESET;
      with BlanketSalesLine do begin
        SETCURRENTKEY("Document Type","Document No.",Type,"No.");
        SETRANGE("Document Type","Document Type"::"Blanket Order");
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",Item."No.");
        Item.COPYFILTER("Location Filter","Location Code");
        Item.COPYFILTER("Variant Filter","Variant Code");
        SETFILTER("Outstanding Qty. (Base)",'<>0');
        SETFILTER("Shipment Date",'>%1&<=%2',0D,ToDate);
        if FIND('-') then
          repeat
            QtyReleased += CalcInventoryProfileRemainingQty(InventoryProfile,"Document No.");
            SETRANGE("Document No.","Document No.");
            BlanketSalesOrderLinesToProfile(InventoryProfile,BlanketSalesLine,QtyReleased);
            SETRANGE("Document No.");
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE BlanketSalesOrderLinesToProfile@128(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR BlanketSalesLine@1002 : Record "Sales Line";VAR QtyReleased@1001 : Decimal);
    VAR
      IsSalesOrderLineCreated@1003 : Boolean;
    BEGIN
      with BlanketSalesLine do
        for IsSalesOrderLineCreated := true downto false do begin
          FIND('-');
          repeat
            if "Quantity (Base)" <> "Qty. to Asm. to Order (Base)" then
              if DoProcessBlanketLine("Document No.","Line No.",IsSalesOrderLineCreated) then
                if "Outstanding Qty. (Base)" - "Qty. to Asm. to Order (Base)" > QtyReleased then begin
                  InventoryProfile.INIT;
                  InventoryProfile."Line No." := NextLineNo;
                  InventoryProfile.TransferFromSalesLine(BlanketSalesLine,TempItemTrkgEntry);
                  InventoryProfile."Untracked Quantity" := "Outstanding Qty. (Base)" - QtyReleased;
                  InventoryProfile."Remaining Quantity (Base)" := InventoryProfile."Untracked Quantity";
                  QtyReleased := 0;
                  InventoryProfile.INSERT;
                end else
                  QtyReleased -= "Outstanding Qty. (Base)";
          until NEXT = 0;
        end;
    END;

    LOCAL PROCEDURE DoProcessBlanketLine@130(BlanketOrderNo@1000 : Code[20];BlanketOrderLineNo@1001 : Integer;IsSalesOrderLineCreated@1002 : Boolean) : Boolean;
    VAR
      SalesLine@1003 : Record "Sales Line";
    BEGIN
      SalesLine.SETRANGE("Blanket Order No.",BlanketOrderNo);
      SalesLine.SETRANGE("Blanket Order Line No.",BlanketOrderLineNo);
      exit(not SalesLine.ISEMPTY = IsSalesOrderLineCreated)
    END;

    LOCAL PROCEDURE CheckForecastExist@36(VAR ForecastEntry@1000 : Record "Production Forecast Entry";OrderDate@1001 : Date;ToDate@1002 : Date) : Boolean;
    VAR
      ForecastExist@1003 : Boolean;
    BEGIN
      ForecastEntry.SETRANGE("Forecast Date",ExcludeForecastBefore,OrderDate);
      if ForecastEntry.FIND('+') then
        repeat
          ForecastEntry.SETRANGE("Forecast Date",ForecastEntry."Forecast Date");
          ForecastEntry.CALCSUMS("Forecast Quantity (Base)");
          if ForecastEntry."Forecast Quantity (Base)" <> 0 then
            ForecastExist := true
          else
            ForecastEntry.SETRANGE("Forecast Date",ExcludeForecastBefore,ForecastEntry."Forecast Date" - 1);
        until (not ForecastEntry.FIND('+')) or ForecastExist;

      if not ForecastExist then begin
        if ExcludeForecastBefore > OrderDate then
          ForecastEntry.SETRANGE("Forecast Date",ExcludeForecastBefore,ToDate)
        else
          ForecastEntry.SETRANGE("Forecast Date",OrderDate + 1,ToDate);
        if ForecastEntry.FIND('-') then
          repeat
            ForecastEntry.SETRANGE("Forecast Date",ForecastEntry."Forecast Date");
            ForecastEntry.CALCSUMS("Forecast Quantity (Base)");
            if ForecastEntry."Forecast Quantity (Base)" <> 0 then
              ForecastExist := true
            else
              ForecastEntry.SETRANGE("Forecast Date",ForecastEntry."Forecast Date" + 1,ToDate);
          until (not ForecastEntry.FIND('-')) or ForecastExist
      end;
      exit(ForecastExist);
    END;

    LOCAL PROCEDURE FindReplishmentLocation@42(VAR ReplenishmentLocation@1000 : Code[10];VAR Item@1003 : Record Item) : Boolean;
    VAR
      SKU@1001 : Record "Stockkeeping Unit";
    BEGIN
      ReplenishmentLocation := '';
      SKU.SETCURRENTKEY("Item No.","Location Code","Variant Code");
      SKU.SETRANGE("Item No.",Item."No.");
      Item.COPYFILTER("Location Filter",SKU."Location Code");
      Item.COPYFILTER("Variant Filter",SKU."Variant Code");
      SKU.SETRANGE("Replenishment System",Item."Replenishment System"::Purchase,Item."Replenishment System"::"Prod. Order");
      SKU.SETFILTER("Reordering Policy",'<>%1',SKU."Reordering Policy"::" ");
      if SKU.FIND('-') then
        if SKU.NEXT = 0 then
          ReplenishmentLocation := SKU."Location Code";
      exit(ReplenishmentLocation <> '');
    END;

    LOCAL PROCEDURE FindCombination@7(VAR Demand@1000 : Record "Inventory Profile";VAR Supply@1001 : Record "Inventory Profile";VAR Item@1002 : Record Item);
    VAR
      SKU@1008 : Record "Stockkeeping Unit";
      Location@1003 : Record Location;
      PlanningGetParameters@1010 : Codeunit "Planning-Get Parameters";
      State@1007 : 'DemandExist,SupplyExist,BothExist';
      DemandBool@1004 : Boolean;
      SupplyBool@1005 : Boolean;
      TransitLocation@1006 : Boolean;
    BEGIN
      CreateTempSKUForComponentsLocation(Item);

      SKU.SETCURRENTKEY("Item No.","Location Code","Variant Code");
      SKU.SETRANGE("Item No.",Item."No.");
      Item.COPYFILTER("Variant Filter",SKU."Variant Code");
      Item.COPYFILTER("Location Filter",SKU."Location Code");

      if SKU.FINDSET then begin
        repeat
          PlanningGetParameters.AdjustInvalidSettings(SKU);
          if (SKU."Safety Stock Quantity" <> 0) or (SKU."Reorder Point" <> 0) or
             (SKU."Reorder Quantity" <> 0) or (SKU."Maximum Inventory" <> 0)
          then begin
            TempSKU.TRANSFERFIELDS(SKU);
            if TempSKU.INSERT then ;
            while (TempSKU."Replenishment System" = TempSKU."Replenishment System"::Transfer) and
                  (TempSKU."Reordering Policy" <> TempSKU."Reordering Policy"::" ")
            do begin
              TempSKU."Location Code" := TempSKU."Transfer-from Code";
              TransferPlanningParameters(TempSKU);
              if TempSKU."Reordering Policy" <> TempSKU."Reordering Policy"::" " then
                InsertTempSKU;
            end;
          end;
        until SKU.NEXT = 0;
      end else
        if (not InvtSetup."Location Mandatory") and (ManufacturingSetup."Components at Location" = '') then
          CreateTempSKUForLocation(Item."No.",'');

      CLEAR(Demand);
      CLEAR(Supply);
      Demand.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");
      Supply.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");
      Demand.SETRANGE(IsSupply,false);
      Supply.SETRANGE(IsSupply,true);
      DemandBool := Demand.FIND('-');
      SupplyBool := Supply.FIND('-');

      while DemandBool or SupplyBool do begin
        if  DemandBool then begin
          TempSKU."Item No." := Demand."Item No.";
          TempSKU."Variant Code" := Demand."Variant Code";
          TempSKU."Location Code" := Demand."Location Code";
        end else begin
          TempSKU."Item No." := Supply."Item No.";
          TempSKU."Variant Code" := Supply."Variant Code";
          TempSKU."Location Code" := Supply."Location Code";
        end;

        if DemandBool and SupplyBool then
          State := State::BothExist
        else
          if DemandBool then
            State := State::DemandExist
          else
            State := State::SupplyExist;

        case State of
          State::DemandExist:
            DemandBool := FindNextSKU(Demand);
          State::SupplyExist:
            SupplyBool := FindNextSKU(Supply);
          State::BothExist:
            if Demand."Variant Code" = Supply."Variant Code" then begin
              if Demand."Location Code" = Supply."Location Code" then begin
                DemandBool := FindNextSKU(Demand);
                SupplyBool := FindNextSKU(Supply);
              end else
                if Demand."Location Code" < Supply."Location Code" then
                  DemandBool := FindNextSKU(Demand)
                else
                  SupplyBool := FindNextSKU(Supply)
            end else
              if Demand."Variant Code" < Supply."Variant Code" then
                DemandBool := FindNextSKU(Demand)
              else
                SupplyBool := FindNextSKU(Supply);
        end;

        if TempSKU."Location Code" <> '' then begin
          Location.GET(TempSKU."Location Code"); // Assert: will fail if location cannot be found.
          TransitLocation := Location."Use As In-Transit";
        end else
          TransitLocation := false; // Variant SKU only - no location code involved.

        if not TransitLocation then begin
          TransferPlanningParameters(TempSKU);
          InsertTempSKU;
          while (TempSKU."Replenishment System" = TempSKU."Replenishment System"::Transfer) and
                (TempSKU."Reordering Policy" <> TempSKU."Reordering Policy"::" ")
          do begin
            TempSKU."Location Code" := TempSKU."Transfer-from Code";
            TransferPlanningParameters(TempSKU);
            if TempSKU."Reordering Policy" <> TempSKU."Reordering Policy"::" " then
              InsertTempSKU;
          end;
        end;
      end;

      Item.COPYFILTER("Location Filter",TempSKU."Location Code");
      Item.COPYFILTER("Variant Filter",TempSKU."Variant Code");
    END;

    LOCAL PROCEDURE InsertTempSKU@14();
    VAR
      SKU2@1002 : Record "Stockkeeping Unit";
      PlanningGetParameters@1000 : Codeunit "Planning-Get Parameters";
    BEGIN
      with TempSKU do
        if not FIND('=') then begin
          PlanningGetParameters.SetLotForLot;
          PlanningGetParameters.AtSKU(SKU2,"Item No.","Variant Code","Location Code");
          TempSKU := SKU2;
          if "Reordering Policy" <> "Reordering Policy"::" " then
            INSERT;
        end;
    END;

    LOCAL PROCEDURE FindNextSKU@2(VAR InventoryProfile@1000 : Record "Inventory Profile") : Boolean;
    BEGIN
      TempSKU."Variant Code" := InventoryProfile."Variant Code";
      TempSKU."Location Code" := InventoryProfile."Location Code";

      InventoryProfile.SETRANGE("Variant Code",TempSKU."Variant Code");
      InventoryProfile.SETRANGE("Location Code",TempSKU."Location Code");
      InventoryProfile.FINDLAST;
      InventoryProfile.SETRANGE("Variant Code");
      InventoryProfile.SETRANGE("Location Code");
      exit(InventoryProfile.NEXT <> 0);
    END;

    LOCAL PROCEDURE TransferPlanningParameters@40(VAR SKU@1000 : Record "Stockkeeping Unit");
    VAR
      SKU2@1001 : Record "Stockkeeping Unit";
      PlanningGetParameters@1002 : Codeunit "Planning-Get Parameters";
    BEGIN
      PlanningGetParameters.AtSKU(SKU2,SKU."Item No.",SKU."Variant Code",SKU."Location Code");
      SKU := SKU2;
    END;

    LOCAL PROCEDURE DeleteTracking@25(VAR SKU@1000 : Record "Stockkeeping Unit";ToDate@1001 : Date;VAR SupplyInventoryProfile@1002 : Record "Inventory Profile");
    VAR
      Item@1004 : Record Item;
      ReservEntry1@1005 : Record "Reservation Entry";
      ResEntryWasDeleted@1003 : Boolean;
    BEGIN
      ActionMsgEntry.SETCURRENTKEY("Reservation Entry");

      with ReservEntry do begin
        RESET;
        SETCURRENTKEY("Item No.","Variant Code","Location Code");
        SETRANGE("Item No.",SKU."Item No.");
        SETRANGE("Variant Code",SKU."Variant Code");
        SETRANGE("Location Code",SKU."Location Code");
        SETFILTER("Reservation Status",'<>%1',"Reservation Status"::Prospect);
        if FIND('-') then
          repeat
            Item.GET("Item No.");
            if not IsTrkgForSpecialOrderOrDropShpt(ReservEntry) then begin
              if (("Reservation Status" <> "Reservation Status"::Reservation) and
                  ("Expected Receipt Date" <= ToDate) and
                  ("Shipment Date" <= ToDate)) or
                 ((Binding = Binding::"Order-to-Order") and ("Shipment Date" <= ToDate) and
                  (Item."Manufacturing Policy" = Item."Manufacturing Policy"::"Make-to-Stock") and
                  (not ReservedForProdComponent(ReservEntry)))
              then begin
                ResEntryWasDeleted := true;
                if ("Source Type" = DATABASE::"Item Ledger Entry") and
                   ("Reservation Status" = "Reservation Status"::Tracking)
                then
                  if ReservEntry1.GET("Entry No.",not Positive) then
                    ReservEntry1.DELETE;
                DELETE;
              end else
                ResEntryWasDeleted := CloseTracking(ReservEntry,SupplyInventoryProfile,ToDate);

              if ResEntryWasDeleted then begin
                ActionMsgEntry.SETRANGE("Reservation Entry","Entry No.");
                ActionMsgEntry.DELETEALL;
              end;
            end;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE RemoveOrdinaryInventory@46(VAR Supply@1000 : Record "Inventory Profile");
    VAR
      Supply2@1001 : Record "Inventory Profile";
    BEGIN
      Supply2.COPY(Supply);
      with Supply do begin
        SETRANGE(IsSupply);
        SETRANGE("Source Type",DATABASE::"Item Ledger Entry");
        SETFILTER(Binding,'<>%1',Supply2.Binding::"Order-to-Order");
        DELETEALL;
        COPY(Supply2);
      end;
    END;

    LOCAL PROCEDURE UnfoldItemTracking@48(VAR ParentInvProfile@1000 : Record "Inventory Profile";VAR ChildInvProfile@1002 : Record "Inventory Profile");
    BEGIN
      ParentInvProfile.RESET;
      TempItemTrkgEntry.RESET;
      if not TempItemTrkgEntry.FIND('-') then
        exit;
      ParentInvProfile.SETFILTER("Source Type",'<>%1',DATABASE::"Item Ledger Entry");
      ParentInvProfile.SETRANGE("Tracking Reference",0);
      if ParentInvProfile.FIND('-') then
        repeat
          TempItemTrkgEntry.RESET;
          TempItemTrkgEntry.SetSourceFilter(
            ParentInvProfile."Source Type",ParentInvProfile."Source Order Status",ParentInvProfile."Source ID",
            ParentInvProfile."Source Ref. No.",false);
          TempItemTrkgEntry.SetSourceFilter2(ParentInvProfile."Source Batch Name",ParentInvProfile."Source Prod. Order Line");
          if TempItemTrkgEntry.FIND('-') then begin
            if ParentInvProfile.IsSupply and
               (ParentInvProfile.Binding <> ParentInvProfile.Binding::"Order-to-Order")
            then
              ParentInvProfile."Planning Flexibility" := ParentInvProfile."Planning Flexibility"::None;
            repeat
              ChildInvProfile := ParentInvProfile;
              ChildInvProfile."Line No." := NextLineNo;
              ChildInvProfile."Tracking Reference" := ParentInvProfile."Line No.";
              ChildInvProfile."Lot No." := TempItemTrkgEntry."Lot No.";
              ChildInvProfile."Serial No." := TempItemTrkgEntry."Serial No.";
              ChildInvProfile."Expiration Date" := TempItemTrkgEntry."Expiration Date";
              ChildInvProfile.TransferQtyFromItemTrgkEntry(TempItemTrkgEntry);
              ChildInvProfile.INSERT;
              ParentInvProfile.ReduceQtyByItemTracking(ChildInvProfile);
              ParentInvProfile.MODIFY;
            until TempItemTrkgEntry.NEXT = 0;
          end;
        until ParentInvProfile.NEXT = 0;
    END;

    LOCAL PROCEDURE MatchAttributes@54(VAR Supply@1000 : Record "Inventory Profile";VAR Demand@1001 : Record "Inventory Profile";RespectPlanningParm@1007 : Boolean);
    VAR
      xDemand@1002 : Record "Inventory Profile";
      xSupply@1003 : Record "Inventory Profile";
      NewSupplyDate@1005 : Date;
      SupplyExists@1004 : Boolean;
      CanBeRescheduled@1008 : Boolean;
      ItemInventoryExists@1006 : Boolean;
    BEGIN
      xDemand.COPYFILTERS(Demand);
      xSupply.COPYFILTERS(Supply);
      ItemInventoryExists := CheckItemInventoryExists(Supply);
      Demand.SETRANGE("Attribute Priority",1,7);
      Demand.SETFILTER("Source Type",'<>%1',DATABASE::"Requisition Line");
      if Demand.FINDSET(true) then
        repeat
          Supply.SETRANGE(Binding,Demand.Binding);
          Supply.SETRANGE("Primary Order Status",Demand."Primary Order Status");
          Supply.SETRANGE("Primary Order No.",Demand."Primary Order No.");
          Supply.SETRANGE("Primary Order Line",Demand."Primary Order Line");
          if (Demand."Ref. Order Type" = Demand."Ref. Order Type"::Assembly) and
             (Demand.Binding = Demand.Binding::"Order-to-Order") and
             (Demand."Primary Order No." = '')
          then
            Supply.SETRANGE("Source Prod. Order Line",Demand."Source Prod. Order Line");

          Supply.SetTrackingFilter(Demand);
          SupplyExists := Supply.FINDFIRST;
          while (Demand."Untracked Quantity" > 0) and (not ApplyUntrackedQuantityToItemInventory(SupplyExists,ItemInventoryExists)) do begin
            if SupplyExists and (Demand.Binding = Demand.Binding::"Order-to-Order") then begin
              NewSupplyDate := Supply."Due Date";
              CanBeRescheduled :=
                (Supply."Fixed Date" = 0D) and
                ((Supply."Due Date" <> Demand."Due Date") or (Supply."Due Time" <> Demand."Due Time"));
              if CanBeRescheduled then
                if (Supply."Due Date" > Demand."Due Date") or (Supply."Due Time" > Demand."Due Time") then
                  CanBeRescheduled := CheckScheduleIn(Supply,Demand."Due Date",NewSupplyDate,false)
                else
                  CanBeRescheduled := CheckScheduleOut(Supply,Demand."Due Date",NewSupplyDate,false);
              if CanBeRescheduled and
                 ((NewSupplyDate <> Supply."Due Date") or (Supply."Planning Level Code" > 0))
              then begin
                Reschedule(Supply,Demand."Due Date",Demand."Due Time");
                Supply."Fixed Date" := Supply."Due Date";
              end;
            end;
            if not SupplyExists or (Supply."Due Date" > Demand."Due Date") then begin
              InitSupply(Supply,Demand."Untracked Quantity",Demand."Due Date");
              TransferAttributes(Supply,Demand);
              Supply."Fixed Date" := Supply."Due Date";
              Supply.INSERT;
              SupplyExists := true;
            end;

            if Demand.Binding = Demand.Binding::"Order-to-Order" then
              if (Demand."Untracked Quantity" > Supply."Untracked Quantity") and
                 (Supply."Due Date" <= Demand."Due Date")
              then
                IncreaseQtyToMeetDemand(Supply,Demand,false,RespectPlanningParm,false);

            if Supply."Untracked Quantity" < Demand."Untracked Quantity" then
              SupplyExists := CloseSupply(Demand,Supply)
            else
              CloseDemand(Demand,Supply);
          end;
        until Demand.NEXT = 0;

      // Neutralize or generalize excess Order-To-Order Supply
      Supply.COPYFILTERS(xSupply);
      Supply.SETRANGE(Binding,Supply.Binding::"Order-to-Order");
      Supply.SETFILTER("Untracked Quantity",'>=0');
      if Supply.FINDSET then
        repeat
          if Supply."Untracked Quantity" > 0 then begin
            if DecreaseQty(Supply,Supply."Untracked Quantity") then begin
              // Assertion: New specific Supply shall match the Demand exactly and must not update
              // the Planning Line again since that will double the derived demand in case of transfers
              if Supply."Action Message" = Supply."Action Message"::New then
                Supply.FIELDERROR("Action Message");
              MaintainPlanningLine(Supply,PlanningLineStage::Exploded,ScheduleDirection::Backward)
            end else begin
              // Evaluate excess supply
              if TempSKU."Include Inventory" then begin
                // Release the remaining Untracked Quantity
                Supply.Binding := Supply.Binding::" ";
                Supply."Primary Order Type" := 0;
                Supply."Primary Order Status" := 0;
                Supply."Primary Order No." := '';
                Supply."Primary Order Line" := 0;
                SetAttributePriority(Supply);
              end else
                Supply."Untracked Quantity" := 0;
            end;
            // Ensure that the directly allocated quantity will not be part of Projected Inventory
            if Supply."Untracked Quantity" <> 0 then begin
              UpdateQty(Supply,Supply."Untracked Quantity");
              Supply.MODIFY;
            end;
          end;
          if Supply."Untracked Quantity" = 0 then
            Supply.DELETE;
        until Supply.NEXT = 0;

      Demand.COPYFILTERS(xDemand);
      Supply.COPYFILTERS(xSupply);
    END;

    LOCAL PROCEDURE MatchReservationEntries@116(VAR FromTrkgReservEntry@1000 : Record "Reservation Entry";VAR ToTrkgReservEntry@1001 : Record "Reservation Entry");
    BEGIN
      if (FromTrkgReservEntry."Reservation Status" = FromTrkgReservEntry."Reservation Status"::Reservation) xor
         (ToTrkgReservEntry."Reservation Status" = ToTrkgReservEntry."Reservation Status"::Reservation)
      then begin
        SwitchTrackingToReservationStatus(FromTrkgReservEntry);
        SwitchTrackingToReservationStatus(ToTrkgReservEntry);
      end;
    END;

    LOCAL PROCEDURE SwitchTrackingToReservationStatus@111(VAR ReservEntry@1000 : Record "Reservation Entry");
    BEGIN
      if ReservEntry."Reservation Status" = ReservEntry."Reservation Status"::Tracking then
        ReservEntry."Reservation Status" := ReservEntry."Reservation Status"::Reservation;
    END;

    LOCAL PROCEDURE PlanItem@41(VAR Demand@1000 : Record "Inventory Profile";VAR Supply@1001 : Record "Inventory Profile";PlanningStartDate@1002 : Date;ToDate@1003 : Date;RespectPlanningParm@1019 : Boolean);
    VAR
      InvChangeReminder@1004 : TEMPORARY Record "Inventory Profile";
      PlanningGetParameters@1020 : Codeunit "Planning-Get Parameters";
      OriginalSupplyDate@1014 : Date;
      NewSupplyDate@1013 : Date;
      LatestBucketStartDate@1012 : Date;
      NextState@1011 : 'StartOver,MatchDates,MatchQty,CreateSupply,ReduceSupply,CloseDemand,CloseSupply,CloseLoop';
      LastProjectedInventory@1005 : Decimal;
      LastAvailableInventory@1007 : Decimal;
      SupplyWithinLeadtime@1015 : Decimal;
      DemandExists@1008 : Boolean;
      SupplyExists@1009 : Boolean;
      PlanThisSKU@1017 : Boolean;
      ROPHasBeenCrossed@1010 : Boolean;
      NewSupplyHasTakenOver@1026 : Boolean;
      WeAreSureThatDatesMatch@1027 : Boolean;
      IsReorderPointPlanning@1033 : Boolean;
      IsExceptionOrder@1006 : Boolean;
      SupplyAvailableWithinLeadTime@1016 : Decimal;
      NeedOfPublishSurplus@1018 : Boolean;
      InitialProjectedInventory@1021 : Decimal;
    BEGIN
      ReqLine.RESET;
      ReqLine.SETRANGE("Worksheet Template Name",CurrTemplateName);
      ReqLine.SETRANGE("Journal Batch Name",CurrWorksheetName);
      ReqLine.LOCKTABLE;
      if ReqLine.FINDLAST then;

      if PlanningResilicency then
        ReqLine.SetResiliencyOn(CurrTemplateName,CurrWorksheetName,TempSKU."Item No.");

      Demand.RESET;
      Supply.RESET;
      Demand.SETRANGE(IsSupply,false);
      Supply.SETRANGE(IsSupply,true);

      UpdateTempSKUTransferLevels;

      TempSKU.SETCURRENTKEY("Item No.","Transfer-Level Code");
      Demand.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");
      Supply.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");
      InvChangeReminder.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date");

      Supply.SETRANGE("Drop Shipment",false);
      Supply.SETRANGE("Special Order",false);
      Demand.SETRANGE("Drop Shipment",false);
      Demand.SETRANGE("Special Order",false);

      ExceedROPqty := 0.000000001;

      if TempSKU.FIND('-') then
        repeat
          IsReorderPointPlanning :=
            (TempSKU."Reorder Point" > TempSKU."Safety Stock Quantity") or
            (TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::"Maximum Qty.") or
            (TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::"Fixed Reorder Qty.");

          BucketSize := TempSKU."Time Bucket";
          // Minimum bucket size is 1 day:
          if CALCDATE(BucketSize) <= TODAY then
            EVALUATE(BucketSize,'<1D>');
          BucketSizeInDays := CALCDATE(BucketSize) - TODAY;

          FilterDemandSupplyRelatedToSKU(Demand);
          FilterDemandSupplyRelatedToSKU(Supply);

          DampenersDays := PlanningGetParameters.CalcDampenerDays(TempSKU);
          DampenerQty := PlanningGetParameters.CalcDampenerQty(TempSKU);
          OverflowLevel := PlanningGetParameters.CalcOverflowLevel(TempSKU);

          if not TempSKU."Include Inventory" then
            RemoveOrdinaryInventory(Supply);
          InsertSafetyStockDemands(Demand,PlanningStartDate);
          UpdatePriorities(Supply,IsReorderPointPlanning,ToDate);

          DemandExists := Demand.FINDSET;
          SupplyExists := Supply.FINDSET;
          LatestBucketStartDate := PlanningStartDate;
          LastProjectedInventory := 0;
          LastAvailableInventory := 0;
          PlanThisSKU := CheckPlanSKU(TempSKU,DemandExists,SupplyExists,IsReorderPointPlanning);

          if PlanThisSKU then begin
            PrepareDemand(Demand,IsReorderPointPlanning,ToDate);
            PlanThisSKU := not (DemandMatchedSupply(Demand,Supply,TempSKU) and DemandMatchedSupply(Supply,Demand,TempSKU));
          end;
          if PlanThisSKU then begin
            // Preliminary clean of tracking
            if DemandExists or SupplyExists then
              DeleteTracking(TempSKU,ToDate,Supply);

            MatchAttributes(Supply,Demand,RespectPlanningParm);

            // Calculate initial inventory
            Demand.SETRANGE("Due Date",0D,PlanningStartDate - 1);
            Supply.SETRANGE("Due Date",0D,PlanningStartDate - 1);
            DemandExists := Demand.FINDSET;
            SupplyExists := Supply.FINDSET;
            while DemandExists and SupplyExists do
              if Demand."Untracked Quantity" > Supply."Untracked Quantity" then begin
                LastProjectedInventory += Supply."Remaining Quantity (Base)";
                Demand."Untracked Quantity" -= Supply."Untracked Quantity";
                FrozenZoneTrack(Supply,Demand);
                Supply."Untracked Quantity" := 0;
                Supply.MODIFY;
                SupplyExists := Supply.NEXT <> 0;
              end else begin
                LastProjectedInventory -= Demand."Remaining Quantity (Base)";
                Supply."Untracked Quantity" -= Demand."Untracked Quantity";
                FrozenZoneTrack(Demand,Supply);
                Demand."Untracked Quantity" := 0;
                Demand.MODIFY;
                DemandExists := Demand.NEXT <> 0;
                if not DemandExists then
                  Supply.MODIFY;
              end;

            while DemandExists do begin
              LastProjectedInventory -= Demand."Remaining Quantity (Base)";
              LastAvailableInventory -= Demand."Untracked Quantity";
              Demand."Untracked Quantity" := 0;
              Demand.MODIFY;
              DemandExists := Demand.NEXT <> 0;
            end;

            while SupplyExists do begin
              LastProjectedInventory += Supply."Remaining Quantity (Base)";
              LastAvailableInventory += Supply."Untracked Quantity";
              Supply."Planning Flexibility" := Supply."Planning Flexibility"::None;
              Supply.MODIFY;
              SupplyExists := Supply.NEXT <> 0;
            end;

            if LastAvailableInventory < 0 then begin // Emergency order
              // Insert Supply
              InitSupply(Supply,-LastAvailableInventory,PlanningStartDate - 1);
              Supply."Planning Flexibility" := Supply."Planning Flexibility"::None;
              Supply.INSERT;
              MaintainPlanningLine(Supply,PlanningLineStage::Exploded,ScheduleDirection::Backward);
              Track(Supply,Demand,true,false,Supply.Binding::" ");
              LastProjectedInventory += Supply."Remaining Quantity (Base)";
              LastAvailableInventory += Supply."Untracked Quantity";
              Transparency.LogSurplus(Supply."Line No.",Supply."Line No.",0,'',
                Supply."Untracked Quantity",SurplusType::EmergencyOrder);
              Supply."Untracked Quantity" := 0;
              if Supply."Planning Line No." <> ReqLine."Line No." then
                ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
              Transparency.PublishSurplus(Supply,TempSKU,ReqLine,TempTrkgReservEntry);
              DummyInventoryProfileTrackBuffer."Warning Level" := DummyInventoryProfileTrackBuffer."Warning Level"::Emergency;
              Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
                STRSUBSTNO(Text006,DummyInventoryProfileTrackBuffer."Warning Level",-Supply."Remaining Quantity (Base)",
                  PlanningStartDate));
              Supply.DELETE;
            end;

            if LastAvailableInventory < TempSKU."Safety Stock Quantity" then begin // Initial Safety Stock Warning
              SupplyAvailableWithinLeadTime := SumUpAvailableSupply(Supply,PlanningStartDate,PlanningStartDate);
              InitialProjectedInventory := LastAvailableInventory + SupplyAvailableWithinLeadTime;
              if InitialProjectedInventory < TempSKU."Safety Stock Quantity" then
                CreateSupplyForInitialSafetyStockWarning(
                  Supply,
                  InitialProjectedInventory,LastProjectedInventory,LastAvailableInventory,
                  PlanningStartDate,RespectPlanningParm,IsReorderPointPlanning);
            end;

            if IsReorderPointPlanning then begin
              SupplyWithinLeadtime := SumUpProjectedSupply(Supply,PlanningStartDate,PlanningStartDate + BucketSizeInDays - 1);

              if LastProjectedInventory + SupplyWithinLeadtime <= TempSKU."Reorder Point" then begin
                InitSupply(Supply,0,0D);
                if LastAvailableInventory < TempSKU."Safety Stock Quantity" then
                  CreateSupplyForward(Supply,PlanningStartDate,
                    TempSKU."Safety Stock Quantity" - LastAvailableInventory + LastProjectedInventory,
                    NewSupplyHasTakenOver,Demand."Due Date")
                else
                  CreateSupplyForward(Supply,PlanningStartDate,LastProjectedInventory,NewSupplyHasTakenOver,Demand."Due Date");

                NeedOfPublishSurplus := Supply."Due Date" > ToDate;
              end;
            end;

            // Common balancing
            Demand.SETRANGE("Due Date",PlanningStartDate,ToDate);

            DemandExists := Demand.FINDSET;
            Demand.SETRANGE("Due Date");

            Supply.SETFILTER("Untracked Quantity",'>=0');
            SupplyExists := Supply.FINDSET;

            Supply.SETRANGE("Untracked Quantity");
            Supply.SETRANGE("Due Date");

            if not SupplyExists then
              if not Supply.ISEMPTY then begin
                Supply.SETRANGE("Due Date",PlanningStartDate,ToDate);
                SupplyExists := Supply.FINDSET;
                Supply.SETRANGE("Due Date");
                if NeedOfPublishSurplus and not (DemandExists or SupplyExists) then begin
                  Track(Supply,Demand,true,false,Supply.Binding::" ");
                  Transparency.PublishSurplus(Supply,TempSKU,ReqLine,TempTrkgReservEntry);
                end;
              end;

            if IsReorderPointPlanning then
              ChkInitialOverflow(Demand,Supply,
                OverflowLevel,LastProjectedInventory,PlanningStartDate,ToDate);

            CheckSupplyWithSKU(Supply,TempSKU);

            NextState := NextState::StartOver;
            while PlanThisSKU do
              case NextState of
                NextState::StartOver:
                  begin
                    if DemandExists and (Demand."Source Type" = DATABASE::"Transfer Line") then
                      while CancelTransfer(Supply,Demand,DemandExists) do
                        DemandExists := Demand.NEXT <> 0;

                    if DemandExists then
                      if Demand."Untracked Quantity" = 0 then
                        NextState := NextState::CloseDemand
                      else
                        if SupplyExists then
                          NextState := NextState::MatchDates
                        else
                          NextState := NextState::CreateSupply
                    else
                      if SupplyExists then
                        NextState := NextState::ReduceSupply
                      else
                        NextState := NextState::CloseLoop;
                  end;
                NextState::MatchDates:
                  begin
                    OriginalSupplyDate := Supply."Due Date";
                    NewSupplyDate := Supply."Due Date";
                    WeAreSureThatDatesMatch := false;

                    if Demand."Due Date" < Supply."Due Date" then begin
                      if CheckScheduleIn(Supply,Demand."Due Date",NewSupplyDate,true) then
                        WeAreSureThatDatesMatch := true
                      else
                        NextState := NextState::CreateSupply;
                    end else
                      if Demand."Due Date" > Supply."Due Date" then begin
                        if CheckScheduleOut(Supply,Demand."Due Date",NewSupplyDate,true) then
                          WeAreSureThatDatesMatch := not ScheduleAllOutChangesSequence(Supply,NewSupplyDate)
                        else
                          NextState := NextState::ReduceSupply;
                      end else
                        WeAreSureThatDatesMatch := true;

                    if WeAreSureThatDatesMatch and IsReorderPointPlanning then begin
                      // Now we know the final position on the timeline of the supply.
                      MaintainProjectedInv(
                        InvChangeReminder,NewSupplyDate,LastProjectedInventory,LatestBucketStartDate,ROPHasBeenCrossed);
                      if ROPHasBeenCrossed then begin
                        CreateSupplyForward(Supply,LatestBucketStartDate,
                          LastProjectedInventory,NewSupplyHasTakenOver,Demand."Due Date");
                        if NewSupplyHasTakenOver then begin
                          WeAreSureThatDatesMatch := false;
                          NextState := NextState::MatchDates;
                        end;
                      end;
                    end;

                    if WeAreSureThatDatesMatch then begin
                      if NewSupplyDate <> OriginalSupplyDate then
                        Reschedule(Supply,NewSupplyDate,000000T);
                      Supply.TESTFIELD("Due Date",NewSupplyDate);
                      Supply."Fixed Date" := Supply."Due Date"; // We note the latest possible date on the supply.
                      NextState := NextState::MatchQty;
                    end;
                  end;
                NextState::MatchQty:
                  begin
                    if Supply."Untracked Quantity" < Demand."Untracked Quantity" then begin
                      if ShallSupplyBeClosed(Supply,Demand."Due Date",IsReorderPointPlanning) then
                        NextState := NextState::CloseSupply
                      else
                        if IncreaseQtyToMeetDemand(
                             Supply,Demand,true,RespectPlanningParm,
                             not SKURequiresLotAccumulation(TempSKU))
                        then begin
                          NextState := NextState::CloseDemand;
                          // initial Safety Stock can be changed to normal, if we can increase qty for normal demand
                          if (Supply."Order Relation" = Supply."Order Relation"::"Safety Stock") and
                             (Demand."Order Relation" = Demand."Order Relation"::Normal)
                          then begin
                            Supply."Order Relation" := Supply."Order Relation"::Normal;
                            LastProjectedInventory -= TempSKU."Safety Stock Quantity";
                          end;
                        end else
                          NextState := NextState::CloseSupply;
                    end else
                      NextState := NextState::CloseDemand;
                  end;
                NextState::CreateSupply:
                  begin
                    WeAreSureThatDatesMatch := true; // We assume this is true at this point.....
                    NewSupplyDate := Demand."Due Date";
                    if (NewSupplyDate >= LatestBucketStartDate) and IsReorderPointPlanning then
                      MaintainProjectedInv(
                        InvChangeReminder,NewSupplyDate,LastProjectedInventory,LatestBucketStartDate,ROPHasBeenCrossed);
                    if ROPHasBeenCrossed then begin
                      CreateSupplyForward(Supply,LatestBucketStartDate,LastProjectedInventory,
                        NewSupplyHasTakenOver,Demand."Due Date");
                      if NewSupplyHasTakenOver then begin
                        SupplyExists := true;
                        WeAreSureThatDatesMatch := false;
                        NextState := NextState::MatchDates;
                      end;
                    end;

                    if WeAreSureThatDatesMatch then begin
                      IsExceptionOrder := IsReorderPointPlanning;
                      CreateSupply(Supply,Demand,
                        LastProjectedInventory +
                        QtyFromPendingReminders(InvChangeReminder,Demand."Due Date",LatestBucketStartDate) -
                        Demand."Remaining Quantity (Base)",
                        IsExceptionOrder,RespectPlanningParm);
                      Supply.TESTFIELD("Due Date",NewSupplyDate);
                      Supply."Fixed Date" := Supply."Due Date"; // We note the latest possible date on the supply.
                      SupplyExists := true;
                      if IsExceptionOrder then begin
                        DummyInventoryProfileTrackBuffer."Warning Level" :=
                          DummyInventoryProfileTrackBuffer."Warning Level"::Exception;
                        Transparency.LogWarning(Supply."Line No.",ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
                          STRSUBSTNO(Text007,DummyInventoryProfileTrackBuffer."Warning Level",
                            TempSKU.FIELDCAPTION("Safety Stock Quantity"),TempSKU."Safety Stock Quantity",Demand."Due Date"));
                      end;
                      NextState := NextState::MatchQty;
                    end;
                  end;
                NextState::ReduceSupply:
                  begin
                    if IsReorderPointPlanning and (Supply."Due Date" >= LatestBucketStartDate) then
                      MaintainProjectedInv(
                        InvChangeReminder,Supply."Due Date",LastProjectedInventory,LatestBucketStartDate,ROPHasBeenCrossed);
                    NewSupplyHasTakenOver := false;
                    if ROPHasBeenCrossed then begin
                      CreateSupplyForward(Supply,LatestBucketStartDate,LastProjectedInventory,NewSupplyHasTakenOver,Supply."Due Date");
                      if NewSupplyHasTakenOver then begin
                        if DemandExists then
                          NextState := NextState::MatchDates
                        else
                          NextState := NextState::CloseSupply;
                      end;
                    end;

                    if not NewSupplyHasTakenOver then
                      if DecreaseQty(Supply,Supply."Untracked Quantity") then
                        NextState := NextState::CloseSupply
                      else begin
                        Supply."Max. Quantity" := Supply."Remaining Quantity (Base)";
                        if DemandExists then
                          NextState := NextState::MatchQty
                        else
                          NextState := NextState::CloseSupply;
                      end;
                  end;
                NextState::CloseDemand:
                  begin
                    if Demand."Due Date" < PlanningStartDate then
                      ERROR(Text001,Demand.FIELDCAPTION("Due Date"));

                    if Demand."Order Relation" = Demand."Order Relation"::"Safety Stock" then begin
                      AllocateSafetystock(Supply,Demand."Untracked Quantity",Demand."Due Date");
                      if IsReorderPointPlanning and (Supply."Due Date" >= LatestBucketStartDate) then
                        PostInvChgReminder(InvChangeReminder,Supply,true);
                    end else begin
                      if IsReorderPointPlanning then
                        PostInvChgReminder(InvChangeReminder,Demand,false);

                      if Demand."Untracked Quantity" <> 0 then begin
                        Supply."Untracked Quantity" -= Demand."Untracked Quantity";

                        if Supply."Untracked Quantity" < Supply."Safety Stock Quantity" then
                          Supply."Safety Stock Quantity" := Supply."Untracked Quantity";

                        if Supply."Action Message" <> Supply."Action Message"::" " then
                          MaintainPlanningLine(Supply,PlanningLineStage::"Line Created",ScheduleDirection::Backward);
                        Supply.MODIFY;

                        if IsReorderPointPlanning and (Supply."Due Date" >= LatestBucketStartDate) then
                          PostInvChgReminder(InvChangeReminder,Supply,true);

                        CheckSupplyAndTrack(Demand,Supply);
                        SurplusType := Transparency.FindReason(Demand);
                        if SurplusType <> SurplusType::None then
                          Transparency.LogSurplus(
                            Supply."Line No.",Demand."Line No.",
                            Demand."Source Type",Demand."Source ID",
                            Demand."Untracked Quantity",SurplusType);
                      end;
                    end;

                    Demand.DELETE;

                    // If just handled demand was safetystock
                    if Demand."Order Relation" = Demand."Order Relation"::"Safety Stock" then
                      SupplyExists := Supply.FINDSET(true); // We assume that next profile is NOT safety stock

                    DemandExists := Demand.NEXT <> 0;
                    NextState := NextState::StartOver;
                  end;
                NextState::CloseSupply:
                  begin
                    if DemandExists and (Supply."Untracked Quantity" > 0) then begin
                      Demand."Untracked Quantity" -= Supply."Untracked Quantity";
                      Demand.MODIFY;
                    end;

                    if DemandExists and (Demand."Order Relation" = Demand."Order Relation"::"Safety Stock") then begin
                      AllocateSafetystock(Supply,Supply."Untracked Quantity",Demand."Due Date");
                      if IsReorderPointPlanning and (Supply."Due Date" >= LatestBucketStartDate) then
                        PostInvChgReminder(InvChangeReminder,Supply,true);
                    end else begin
                      if IsReorderPointPlanning and (Supply."Due Date" >= LatestBucketStartDate) then
                        PostInvChgReminder(InvChangeReminder,Supply,false);

                      if Supply."Action Message" <> Supply."Action Message"::" " then
                        MaintainPlanningLine(Supply,PlanningLineStage::Exploded,ScheduleDirection::Backward)
                      else
                        Supply.TESTFIELD("Planning Line No.",0);

                      if (Supply."Action Message" = Supply."Action Message"::New) or
                         (Supply."Due Date" <= ToDate)
                      then
                        if DemandExists then
                          Track(Supply,Demand,false,false,Supply.Binding)
                        else
                          Track(Supply,Demand,true,false,Supply.Binding::" ");
                      Supply.DELETE;

                      // Planning Transparency
                      if DemandExists then begin
                        SurplusType := Transparency.FindReason(Demand);
                        if SurplusType <> SurplusType::None then
                          Transparency.LogSurplus(Supply."Line No.",Demand."Line No.",
                            Demand."Source Type",Demand."Source ID",
                            Supply."Untracked Quantity",SurplusType);
                      end;
                      if Supply."Planning Line No." <> 0 then begin
                        if Supply."Safety Stock Quantity" > 0 then
                          Transparency.LogSurplus(Supply."Line No.",Supply."Line No.",0,'',
                            Supply."Safety Stock Quantity",SurplusType::SafetyStock);
                        if Supply."Planning Line No." <> ReqLine."Line No." then
                          ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
                        Transparency.PublishSurplus(Supply,TempSKU,ReqLine,TempTrkgReservEntry);
                      end else
                        Transparency.CleanLog(Supply."Line No.");
                    end;
                    if TempSKU."Maximum Order Quantity" > 0 then
                      CheckSupplyRemQtyAndUntrackQty(Supply);
                    SupplyExists := Supply.NEXT <> 0;
                    NextState := NextState::StartOver;
                  end;
                NextState::CloseLoop:
                  begin
                    if IsReorderPointPlanning then
                      MaintainProjectedInv(
                        InvChangeReminder,ToDate,LastProjectedInventory,LatestBucketStartDate,ROPHasBeenCrossed);
                    if ROPHasBeenCrossed then begin
                      CreateSupplyForward(Supply,LatestBucketStartDate,LastProjectedInventory,NewSupplyHasTakenOver,Demand."Due Date");
                      SupplyExists := true;
                      NextState := NextState::StartOver;
                    end else
                      PlanThisSKU := false;
                  end;
                else
                  ERROR(Text001,SELECTSTR(NextState + 1,NextStateTxt));
              end;
          end;
        until TempSKU.NEXT = 0;
      SetAcceptAction(TempSKU."Item No.");
    END;

    LOCAL PROCEDURE FilterDemandSupplyRelatedToSKU@23(VAR InventoryProfile@1000 : Record "Inventory Profile");
    BEGIN
      InventoryProfile.SETRANGE("Item No.",TempSKU."Item No.");
      InventoryProfile.SETRANGE("Variant Code",TempSKU."Variant Code");
      InventoryProfile.SETRANGE("Location Code",TempSKU."Location Code");
    END;

    LOCAL PROCEDURE ScheduleForward@33(VAR Supply@1000 : Record "Inventory Profile";StartingDate@1001 : Date);
    BEGIN
      Supply."Starting Date" := StartingDate;
      MaintainPlanningLine(Supply,PlanningLineStage::"Routing Created",ScheduleDirection::Forward);
      if (Supply."Fixed Date" > 0D) and
         (Supply."Fixed Date" < Supply."Due Date")
      then
        Supply."Due Date" := Supply."Fixed Date"
      else
        Supply."Fixed Date" := Supply."Due Date";
    END;

    LOCAL PROCEDURE IncreaseQtyToMeetDemand@8(VAR Supply@1000 : Record "Inventory Profile";DemandInvtProfile@1001 : Record "Inventory Profile";LimitedHorizon@1004 : Boolean;RespectPlanningParm@1003 : Boolean;CheckSourceType@1005 : Boolean) : Boolean;
    VAR
      TotalDemandedQty@1002 : Decimal;
    BEGIN
      if Supply."Planning Flexibility" <> Supply."Planning Flexibility"::Unlimited then
        exit(false);

      if CheckSourceType then
        if (DemandInvtProfile."Source Type" = DATABASE::"Planning Component") and
           (Supply."Source Type" = DATABASE::"Prod. Order Line")
        then
          exit(false);

      if (Supply."Max. Quantity" > 0) or (Supply."Action Message" = Supply."Action Message"::Cancel) then
        if Supply."Max. Quantity" <= Supply."Remaining Quantity (Base)" then
          exit(false);

      if LimitedHorizon then
        if not AllowLotAccumulation(Supply,DemandInvtProfile."Due Date") then
          exit(false);

      TotalDemandedQty := DemandInvtProfile."Untracked Quantity";
      IncreaseQty(Supply,DemandInvtProfile."Untracked Quantity" - Supply."Untracked Quantity",RespectPlanningParm);
      exit(TotalDemandedQty <= Supply."Untracked Quantity");
    END;

    LOCAL PROCEDURE IncreaseQty@28(VAR Supply@1000 : Record "Inventory Profile";NeededQty@1001 : Decimal;RespectPlanningParm@1003 : Boolean);
    VAR
      TempQty@1002 : Decimal;
    BEGIN
      TempQty := Supply."Remaining Quantity (Base)";

      if not Supply."Is Exception Order" or RespectPlanningParm then
        Supply."Remaining Quantity (Base)" += NeededQty +
          AdjustReorderQty(
            Supply."Remaining Quantity (Base)" + NeededQty,TempSKU,Supply."Line No.",Supply."Min. Quantity")
      else
        Supply."Remaining Quantity (Base)" += NeededQty;

      if TempSKU."Maximum Order Quantity" > 0 then
        if Supply."Remaining Quantity (Base)" > TempSKU."Maximum Order Quantity" then
          Supply."Remaining Quantity (Base)" := TempSKU."Maximum Order Quantity";
      if (Supply."Action Message" <> Supply."Action Message"::New) and
         (Supply."Remaining Quantity (Base)" <> TempQty)
      then begin
        if Supply."Original Quantity" = 0 then
          Supply."Original Quantity" := Supply.Quantity;
        if Supply."Original Due Date" = 0D then
          Supply."Action Message" := Supply."Action Message"::"Change Qty."
        else
          Supply."Action Message" := Supply."Action Message"::"Resched.& Chg. Qty.";
      end;

      Supply."Untracked Quantity" :=
        Supply."Untracked Quantity" +
        Supply."Remaining Quantity (Base)" -
        TempQty;

      Supply."Quantity (Base)" :=
        Supply."Quantity (Base)" +
        Supply."Remaining Quantity (Base)" -
        TempQty;
      Supply.MODIFY;
    END;

    LOCAL PROCEDURE DecreaseQty@63(VAR Supply@1000 : Record "Inventory Profile";ReduceQty@1001 : Decimal) : Boolean;
    VAR
      TempQty@1002 : Decimal;
      TrackedQty@1003 : Decimal;
    BEGIN
      if ReduceQty > Supply."Untracked Quantity" then
        ReduceQty := Supply."Untracked Quantity";
      if Supply."Min. Quantity" > Supply."Remaining Quantity (Base)" - ReduceQty then
        ReduceQty := Supply."Remaining Quantity (Base)" - Supply."Min. Quantity";

      // Ensure leaving enough untracked qty. to cover the safety stock
      TrackedQty := Supply."Remaining Quantity (Base)" - Supply."Untracked Quantity";
      if TrackedQty + Supply."Safety Stock Quantity" > Supply."Remaining Quantity (Base)" - ReduceQty then
        ReduceQty := Supply."Remaining Quantity (Base)" - (TrackedQty + Supply."Safety Stock Quantity");

      // Planning Transparency
      if (ReduceQty <= DampenerQty) and (Supply."Planning Level Code" = 0) then begin
        Transparency.LogSurplus(
          Supply."Line No.",0,
          DATABASE::"Manufacturing Setup",Supply."Source ID",
          DampenerQty,SurplusType::DampenerQty);
        exit(false);
      end;

      if (Supply."Planning Flexibility" = Supply."Planning Flexibility"::None) or
         ((ReduceQty <= DampenerQty) and
          (Supply."Planning Level Code" = 0))
      then
        exit(false);

      if ReduceQty > 0 then begin
        TempQty := Supply."Remaining Quantity (Base)";

        Supply."Remaining Quantity (Base)" :=
          Supply."Remaining Quantity (Base)" - ReduceQty +
          AdjustReorderQty(Supply."Remaining Quantity (Base)" - ReduceQty,TempSKU,Supply."Line No.",Supply."Min. Quantity");

        if TempSKU."Maximum Order Quantity" > 0 then
          if Supply."Remaining Quantity (Base)" > TempSKU."Maximum Order Quantity" then
            Supply."Remaining Quantity (Base)" := TempSKU."Maximum Order Quantity";
        if (Supply."Action Message" <> Supply."Action Message"::New) and
           (TempQty <> Supply."Remaining Quantity (Base)")
        then begin
          if Supply."Original Quantity" = 0 then
            Supply."Original Quantity" := Supply.Quantity;
          if Supply."Remaining Quantity (Base)" = 0 then
            Supply."Action Message" := Supply."Action Message"::Cancel
          else
            if Supply."Original Due Date" = 0D then
              Supply."Action Message" := Supply."Action Message"::"Change Qty."
            else
              Supply."Action Message" := Supply."Action Message"::"Resched.& Chg. Qty.";
        end;

        Supply."Untracked Quantity" :=
          Supply."Untracked Quantity" -
          TempQty +
          Supply."Remaining Quantity (Base)";

        Supply."Quantity (Base)" :=
          Supply."Quantity (Base)" -
          TempQty +
          Supply."Remaining Quantity (Base)";

        Supply.MODIFY;
      end;

      exit(Supply."Untracked Quantity" = 0);
    END;

    LOCAL PROCEDURE CreateSupply@53(VAR Supply@1000 : Record "Inventory Profile";VAR Demand@1002 : Record "Inventory Profile";ProjectedInventory@1006 : Decimal;IsExceptionOrder@1001 : Boolean;RespectPlanningParm@1003 : Boolean);
    VAR
      ReorderQty@1005 : Decimal;
    BEGIN
      InitSupply(Supply,0,Demand."Due Date");
      ReorderQty := Demand."Untracked Quantity";
      if (not IsExceptionOrder) or RespectPlanningParm then begin
        if not RespectPlanningParm then
          ReorderQty := CalcReorderQty(ReorderQty,ProjectedInventory,Supply."Line No.")
        else
          if IsExceptionOrder then begin
            if Demand."Order Relation" = Demand."Order Relation"::"Safety Stock" then // Compensate for Safety Stock offset
              ProjectedInventory := ProjectedInventory + Demand."Remaining Quantity (Base)";
            ReorderQty := CalcReorderQty(ReorderQty,ProjectedInventory,Supply."Line No.");
            if ReorderQty < -ProjectedInventory then
              ReorderQty :=
                ROUND(-ProjectedInventory / TempSKU."Reorder Quantity" + ExceedROPqty,1,'>') *
                TempSKU."Reorder Quantity";
          end;

        ReorderQty += AdjustReorderQty(ReorderQty,TempSKU,Supply."Line No.",Supply."Min. Quantity");
        Supply."Max. Quantity" := TempSKU."Maximum Order Quantity";
      end;
      UpdateQty(Supply,ReorderQty);
      if TempSKU."Maximum Order Quantity" > 0 then begin
        if Supply."Remaining Quantity (Base)" > TempSKU."Maximum Order Quantity" then
          Supply."Remaining Quantity (Base)" := TempSKU."Maximum Order Quantity";
        if Supply."Untracked Quantity" >= TempSKU."Maximum Order Quantity" then
          Supply."Untracked Quantity" :=
            Supply."Untracked Quantity" -
            ReorderQty +
            Supply."Remaining Quantity (Base)";
      end;
      Supply."Min. Quantity" := Supply."Remaining Quantity (Base)";
      TransferAttributes(Supply,Demand);
      Supply."Is Exception Order" := IsExceptionOrder;
      Supply.INSERT;
      if (not IsExceptionOrder or RespectPlanningParm) and (OverflowLevel > 0) then
        // the new supply might cause overflow in inventory since
        // it wasn't considered when Overflow was calculated
        CheckNewOverflow(Supply,ProjectedInventory + ReorderQty,ReorderQty,Supply."Due Date");
    END;

    LOCAL PROCEDURE CreateDemand@17(VAR Demand@1000 : Record "Inventory Profile";VAR SKU@1001 : Record "Stockkeeping Unit";NeededQuantity@1002 : Decimal;NeededDueDate@1003 : Date;OrderRelation@1004 : 'Normal,"Safety Stock","Reorder Point"');
    BEGIN
      Demand.INIT;
      Demand."Line No." := NextLineNo;
      Demand."Item No." := SKU."Item No.";
      Demand."Variant Code" := SKU."Variant Code";
      Demand."Location Code" := SKU."Location Code";
      Demand."Quantity (Base)" := NeededQuantity;
      Demand."Remaining Quantity (Base)" := NeededQuantity;
      Demand.IsSupply := false;
      Demand."Order Relation" := OrderRelation;
      Demand."Source Type" := 0;
      Demand."Untracked Quantity" := NeededQuantity;
      Demand."Due Date" := NeededDueDate;
      Demand."Planning Flexibility" := Demand."Planning Flexibility"::None;
      Demand.INSERT;
    END;

    LOCAL PROCEDURE Track@19(FromProfile@1000 : Record "Inventory Profile";ToProfile@1001 : Record "Inventory Profile";IsSurplus@1002 : Boolean;IssueActionMessage@1003 : Boolean;Binding@1004 : '" ","Order-to-Order"');
    VAR
      TrkgReservEntryArray@1005 : ARRAY [6] OF Record "Reservation Entry";
      SplitState@1009 : 'NoSplit,SplitFromProfile,SplitToProfile,Cancel';
      SplitQty@1006 : Decimal;
      SplitQty2@1007 : Decimal;
      TrackQty@1008 : Decimal;
      DecreaseSupply@1010 : Boolean;
    BEGIN
      DecreaseSupply :=
        FromProfile.IsSupply and
        (FromProfile."Action Message" in [FromProfile."Action Message"::"Change Qty.",
                                          FromProfile."Action Message"::"Resched.& Chg. Qty."]) and
        (FromProfile."Quantity (Base)" < FromProfile."Original Quantity" * FromProfile."Qty. per Unit of Measure");

      if ((FromProfile."Action Message" = FromProfile."Action Message"::Cancel) and
          (FromProfile."Untracked Quantity" = 0)) or (DecreaseSupply and IsSurplus)
      then begin
        IsSurplus := false;
        if DecreaseSupply then
          FromProfile."Untracked Quantity" :=
            FromProfile."Original Quantity" * FromProfile."Qty. per Unit of Measure" - FromProfile."Quantity (Base)"
        else
          if FromProfile.IsSupply then
            FromProfile."Untracked Quantity" := FromProfile."Remaining Quantity" * FromProfile."Qty. per Unit of Measure"
          else
            FromProfile."Untracked Quantity" := -FromProfile."Remaining Quantity" * FromProfile."Qty. per Unit of Measure";
        FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[1],false);
        TrkgReservEntryArray[3] := TrkgReservEntryArray[1];
        ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[3],true);
        if FromProfile.IsSupply then
          TrkgReservEntryArray[3]."Shipment Date" := FromProfile."Due Date"
        else
          TrkgReservEntryArray[3]."Expected Receipt Date" := FromProfile."Due Date";
        SplitState := SplitState::Cancel;
      end else begin
        TrackQty := FromProfile."Untracked Quantity";

        if FromProfile.IsSupply then begin
          if not ((FromProfile."Original Quantity" * FromProfile."Qty. per Unit of Measure" > FromProfile."Quantity (Base)") or
                  (FromProfile."Untracked Quantity" > 0))
          then
            exit;

          SplitQty := FromProfile."Original Quantity" * FromProfile."Qty. per Unit of Measure" +
            FromProfile."Untracked Quantity" - FromProfile."Quantity (Base)";

          case FromProfile."Action Message" of
            FromProfile."Action Message"::"Resched.& Chg. Qty.",
            FromProfile."Action Message"::Reschedule,
            FromProfile."Action Message"::New,
            FromProfile."Action Message"::"Change Qty.":
              begin
                if (SplitQty > 0) and (SplitQty < TrackQty) then begin
                  SplitState := SplitState::SplitFromProfile;
                  FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[1],
                    (FromProfile."Action Message" = FromProfile."Action Message"::Reschedule) or
                    (FromProfile."Action Message" = FromProfile."Action Message"::"Resched.& Chg. Qty."));
                  TrkgReservEntryArray[3] := TrkgReservEntryArray[1];
                  ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[3],true);
                  if IsSurplus then begin
                    TrkgReservEntryArray[3]."Quantity (Base)" := TrackQty - SplitQty;
                    TrkgReservEntryArray[1]."Quantity (Base)" := SplitQty;
                  end else begin
                    TrkgReservEntryArray[1]."Quantity (Base)" := TrackQty - SplitQty;
                    TrkgReservEntryArray[3]."Quantity (Base)" := SplitQty;
                  end;
                  TrkgReservEntryArray[1].Quantity :=
                    ROUND(TrkgReservEntryArray[1]."Quantity (Base)" / TrkgReservEntryArray[1]."Qty. per Unit of Measure",0.00001);
                  TrkgReservEntryArray[3].Quantity :=
                    ROUND(TrkgReservEntryArray[3]."Quantity (Base)" / TrkgReservEntryArray[3]."Qty. per Unit of Measure",0.00001);
                end else begin
                  FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[1],false);
                  ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[1],true);
                end;
                if IsSurplus then begin
                  TrkgReservEntryArray[4] := TrkgReservEntryArray[1];
                  ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[4],true);
                  TrkgReservEntryArray[4]."Shipment Date" := ReqLine."Due Date";
                end;
                ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[2],false);
              end;
            else
              FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[1],false);
              ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[2],
                (ToProfile."Source Type" = DATABASE::"Planning Component") and
                (ToProfile."Primary Order Status" > 1)); // Firm Planned, Released Prod.Order
          end;
        end else begin
          ToProfile.TESTFIELD(IsSupply,true);
          SplitQty := ToProfile."Remaining Quantity" * ToProfile."Qty. per Unit of Measure" + ToProfile."Untracked Quantity" +
            FromProfile."Untracked Quantity" - ToProfile."Quantity (Base)";

          if FromProfile."Source Type" = DATABASE::"Planning Component" then begin
            SplitQty2 := FromProfile."Original Quantity" * FromProfile."Qty. per Unit of Measure";
            if FromProfile."Untracked Quantity" < SplitQty2 then
              SplitQty2 := FromProfile."Untracked Quantity";
            if SplitQty2 > SplitQty then
              SplitQty2 := SplitQty;
          end;

          if SplitQty2 > 0 then begin
            ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[5],false);
            if ToProfile."Action Message" = ToProfile."Action Message"::New then begin
              ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[5],true);
              FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[6],false);
            end else
              FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[6],true);
            TrkgReservEntryArray[5]."Quantity (Base)" := SplitQty2;
            TrkgReservEntryArray[5].Quantity :=
              ROUND(TrkgReservEntryArray[5]."Quantity (Base)" / TrkgReservEntryArray[5]."Qty. per Unit of Measure",0.00001);
            FromProfile."Untracked Quantity" := FromProfile."Untracked Quantity" - SplitQty2;
            TrackQty := TrackQty - SplitQty2;
            SplitQty := SplitQty - SplitQty2;
            PrepareTempTracking(TrkgReservEntryArray[5],TrkgReservEntryArray[6],IsSurplus,IssueActionMessage,Binding);
          end;

          if (ToProfile."Action Message" <> ToProfile."Action Message"::" ") and
             (SplitQty < TrackQty)
          then begin
            if (SplitQty > 0) and (SplitQty < TrackQty) then begin
              SplitState := SplitState::SplitToProfile;
              ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[2],
                (FromProfile."Action Message" = FromProfile."Action Message"::Reschedule) or
                (FromProfile."Action Message" = FromProfile."Action Message"::"Resched.& Chg. Qty."));
              TrkgReservEntryArray[3] := TrkgReservEntryArray[2];
              ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[2],true);
              TrkgReservEntryArray[2]."Quantity (Base)" := TrackQty - SplitQty;
              TrkgReservEntryArray[3]."Quantity (Base)" := SplitQty;
              TrkgReservEntryArray[2].Quantity :=
                ROUND(TrkgReservEntryArray[2]."Quantity (Base)" / TrkgReservEntryArray[2]."Qty. per Unit of Measure",0.00001);
              TrkgReservEntryArray[3].Quantity :=
                ROUND(TrkgReservEntryArray[3]."Quantity (Base)" / TrkgReservEntryArray[3]."Qty. per Unit of Measure",0.00001);
            end else begin
              ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[2],false);
              ReqLine.TransferToTrackingEntry(TrkgReservEntryArray[2],true);
            end;
          end else
            ToProfile.TransferToTrackingEntry(TrkgReservEntryArray[2],false);
          FromProfile.TransferToTrackingEntry(TrkgReservEntryArray[1],false);
        end;
      end;

      case SplitState of
        SplitState::NoSplit:
          PrepareTempTracking(TrkgReservEntryArray[1],TrkgReservEntryArray[2],IsSurplus,IssueActionMessage,Binding);
        SplitState::SplitFromProfile:
          if IsSurplus then begin
            PrepareTempTracking(TrkgReservEntryArray[1],TrkgReservEntryArray[4],false,IssueActionMessage,Binding);
            PrepareTempTracking(TrkgReservEntryArray[3],TrkgReservEntryArray[4],true,IssueActionMessage,Binding);
          end else begin
            TrkgReservEntryArray[4] := TrkgReservEntryArray[2];
            PrepareTempTracking(TrkgReservEntryArray[1],TrkgReservEntryArray[2],IsSurplus,IssueActionMessage,Binding);
            PrepareTempTracking(TrkgReservEntryArray[3],TrkgReservEntryArray[4],IsSurplus,IssueActionMessage,Binding);
          end;
        SplitState::SplitToProfile:
          begin
            TrkgReservEntryArray[4] := TrkgReservEntryArray[1];
            PrepareTempTracking(TrkgReservEntryArray[2],TrkgReservEntryArray[1],IsSurplus,IssueActionMessage,Binding);
            PrepareTempTracking(TrkgReservEntryArray[3],TrkgReservEntryArray[4],IsSurplus,IssueActionMessage,Binding);
          end;
        SplitState::Cancel:
          PrepareTempTracking(TrkgReservEntryArray[1],TrkgReservEntryArray[3],IsSurplus,IssueActionMessage,Binding);
      end;
    END;

    LOCAL PROCEDURE PrepareTempTracking@35(VAR FromTrkgReservEntry@1000 : Record "Reservation Entry";VAR ToTrkgReservEntry@1001 : Record "Reservation Entry";IsSurplus@1002 : Boolean;IssueActionMessage@1003 : Boolean;Binding@1004 : '" ","Order-to-Order"');
    BEGIN
      if not IsSurplus then begin
        ToTrkgReservEntry."Quantity (Base)" := -FromTrkgReservEntry."Quantity (Base)";
        ToTrkgReservEntry.Quantity :=
          ROUND(ToTrkgReservEntry."Quantity (Base)" / ToTrkgReservEntry."Qty. per Unit of Measure",0.00001);
      end else
        ToTrkgReservEntry."Suppressed Action Msg." := not IssueActionMessage;

      ToTrkgReservEntry.Positive := ToTrkgReservEntry."Quantity (Base)" > 0;
      FromTrkgReservEntry.Positive := FromTrkgReservEntry."Quantity (Base)" > 0;

      FromTrkgReservEntry.Binding := Binding;
      ToTrkgReservEntry.Binding := Binding;

      if IsSurplus or (ToTrkgReservEntry."Reservation Status" = ToTrkgReservEntry."Reservation Status"::Surplus) then begin
        FromTrkgReservEntry."Reservation Status" := FromTrkgReservEntry."Reservation Status"::Surplus;
        FromTrkgReservEntry."Suppressed Action Msg." := ToTrkgReservEntry."Suppressed Action Msg.";
        InsertTempTracking(FromTrkgReservEntry,ToTrkgReservEntry);
        exit;
      end;

      if FromTrkgReservEntry."Reservation Status" = FromTrkgReservEntry."Reservation Status"::Surplus then begin
        ToTrkgReservEntry."Reservation Status" := ToTrkgReservEntry."Reservation Status"::Surplus;
        ToTrkgReservEntry."Suppressed Action Msg." := FromTrkgReservEntry."Suppressed Action Msg.";
        InsertTempTracking(ToTrkgReservEntry,FromTrkgReservEntry);
        exit;
      end;

      InsertTempTracking(FromTrkgReservEntry,ToTrkgReservEntry);
    END;

    LOCAL PROCEDURE InsertTempTracking@26(VAR FromTrkgReservEntry@1000 : Record "Reservation Entry";VAR ToTrkgReservEntry@1001 : Record "Reservation Entry");
    VAR
      NextEntryNo@1002 : Integer;
      ShouldInsert@1004 : Boolean;
    BEGIN
      if FromTrkgReservEntry."Quantity (Base)" = 0 then
        exit;
      NextEntryNo := TempTrkgReservEntry."Entry No." + 1;

      if FromTrkgReservEntry."Reservation Status" = FromTrkgReservEntry."Reservation Status"::Surplus then begin
        TempTrkgReservEntry := FromTrkgReservEntry;
        TempTrkgReservEntry."Entry No." := NextEntryNo;
        SetQtyToHandle(TempTrkgReservEntry);
        TempTrkgReservEntry.INSERT;
      end else begin
        MatchReservationEntries(FromTrkgReservEntry,ToTrkgReservEntry);
        if FromTrkgReservEntry.Positive then begin
          FromTrkgReservEntry."Shipment Date" := ToTrkgReservEntry."Shipment Date";
          if ToTrkgReservEntry."Source Type" = DATABASE::"Item Ledger Entry" then
            ToTrkgReservEntry."Shipment Date" := DMY2DATE(31,12,9999);
          ToTrkgReservEntry."Expected Receipt Date" := FromTrkgReservEntry."Expected Receipt Date";
        end else begin
          ToTrkgReservEntry."Shipment Date" := FromTrkgReservEntry."Shipment Date";
          if FromTrkgReservEntry."Source Type" = DATABASE::"Item Ledger Entry" then
            FromTrkgReservEntry."Shipment Date" := DMY2DATE(31,12,9999);
          FromTrkgReservEntry."Expected Receipt Date" := ToTrkgReservEntry."Expected Receipt Date";
        end;

        if FromTrkgReservEntry.Positive then
          ShouldInsert := ShouldInsertTrackingEntry(FromTrkgReservEntry)
        else
          ShouldInsert := ShouldInsertTrackingEntry(ToTrkgReservEntry);

        if ShouldInsert then begin
          TempTrkgReservEntry := FromTrkgReservEntry;
          TempTrkgReservEntry."Entry No." := NextEntryNo;
          SetQtyToHandle(TempTrkgReservEntry);
          TempTrkgReservEntry.INSERT;

          TempTrkgReservEntry := ToTrkgReservEntry;
          TempTrkgReservEntry."Entry No." := NextEntryNo;
          SetQtyToHandle(TempTrkgReservEntry);
          TempTrkgReservEntry.INSERT;
        end;
      end;
    END;

    LOCAL PROCEDURE SetQtyToHandle@51(VAR TrkgReservEntry@1000 : Record "Reservation Entry");
    VAR
      PickedQty@1001 : Decimal;
    BEGIN
      if not TrkgReservEntry.TrackingExists then
        exit;

      PickedQty := QtyPickedForSourceDocument(TrkgReservEntry);

      if PickedQty <> 0 then begin
        TrkgReservEntry."Qty. to Handle (Base)" := PickedQty;
        TrkgReservEntry."Qty. to Invoice (Base)" := PickedQty;
      end else begin
        TrkgReservEntry."Qty. to Handle (Base)" := TrkgReservEntry."Quantity (Base)";
        TrkgReservEntry."Qty. to Invoice (Base)" := TrkgReservEntry."Quantity (Base)";
      end;
    END;

    LOCAL PROCEDURE CommitTracking@29();
    VAR
      PrevTempEntryNo@1000 : Integer;
      PrevInsertedEntryNo@1001 : Integer;
    BEGIN
      if not TempTrkgReservEntry.FIND('-') then
        exit;

      repeat
        ReservEntry := TempTrkgReservEntry;
        if TempTrkgReservEntry."Entry No." = PrevTempEntryNo then
          ReservEntry."Entry No." := PrevInsertedEntryNo
        else
          ReservEntry."Entry No." := 0;
        ReservEntry.UpdateItemTracking;
        UpdateAppliedItemEntry(ReservEntry);
        ReservEntry.INSERT;
        PrevTempEntryNo := TempTrkgReservEntry."Entry No.";
        PrevInsertedEntryNo := ReservEntry."Entry No.";
        TempTrkgReservEntry.DELETE;
      until TempTrkgReservEntry.NEXT = 0;
      CLEAR(TempTrkgReservEntry);
    END;

    LOCAL PROCEDURE MaintainPlanningLine@27(VAR Supply@1000 : Record "Inventory Profile";NewPhase@1001 : '" ","Line Created","Routing Created",Exploded,Obsolete';Direction@1002 : 'Forward,Backward');
    VAR
      PurchaseLine@1003 : Record "Purchase Line";
      ProdOrderLine@1004 : Record "Prod. Order Line";
      AsmHeader@1008 : Record "Assembly Header";
      TransLine@1007 : Record "Transfer Line";
      CrntSupply@1005 : Record "Inventory Profile";
      PlanLineNo@1006 : Integer;
      RecalculationRequired@1009 : Boolean;
    BEGIN
      if (NewPhase = NewPhase::"Line Created") or
         (Supply."Planning Line Phase" < Supply."Planning Line Phase"::"Line Created")
      then
        if Supply."Planning Line No." = 0 then
          with ReqLine do begin
            BlockDynamicTracking(true);
            if FINDLAST then
              PlanLineNo := "Line No." + 10000
            else
              PlanLineNo := 10000;
            INIT;
            "Worksheet Template Name" := CurrTemplateName;
            "Journal Batch Name" := CurrWorksheetName;
            "Line No." := PlanLineNo;
            Type := Type::Item;
            "No." := Supply."Item No.";
            "Variant Code" := Supply."Variant Code";
            "Location Code" := Supply."Location Code";
            "Planning Line Origin" := "Planning Line Origin"::Planning;
            if Supply."Action Message" = Supply."Action Message"::New
            then begin
              "Order Date" := Supply."Due Date";
              "Planning Level" := Supply."Planning Level Code";
              case TempSKU."Replenishment System" of
                TempSKU."Replenishment System"::Purchase:
                  "Ref. Order Type" := "Ref. Order Type"::Purchase;
                TempSKU."Replenishment System"::"Prod. Order":
                  begin
                    "Ref. Order Type" := "Ref. Order Type"::"Prod. Order";
                    if "Planning Level" > 0 then begin
                      "Ref. Order Status" := Supply."Primary Order Status";
                      "Ref. Order No." := Supply."Primary Order No.";
                    end;
                  end;
                TempSKU."Replenishment System"::Assembly:
                  "Ref. Order Type" := "Ref. Order Type"::Assembly;
                TempSKU."Replenishment System"::Transfer:
                  "Ref. Order Type" := "Ref. Order Type"::Transfer;
              end;
              VALIDATE("No.");
              VALIDATE("Variant Code");
              VALIDATE("Unit of Measure Code",Supply."Unit of Measure Code");
              "Starting Time" := ManufacturingSetup."Normal Starting Time";
              "Ending Time" := ManufacturingSetup."Normal Ending Time";
            end else
              case Supply."Source Type" of
                DATABASE::"Purchase Line":
                  SetPurchase(PurchaseLine,Supply);
                DATABASE::"Prod. Order Line":
                  SetProdOrder(ProdOrderLine,Supply);
                DATABASE::"Assembly Header":
                  SetAssembly(AsmHeader,Supply);
                DATABASE::"Transfer Line":
                  SetTransfer(TransLine,Supply);
              end;
            AdjustPlanLine(Supply);
            "Accept Action Message" := true;
            "Routing Reference No." := "Line No.";
            UpdateDatetime;
            "MPS Order" := Supply."MPS Order";
            INSERT;
            Supply."Planning Line No." := "Line No.";
            if NewPhase = NewPhase::"Line Created" then
              Supply."Planning Line Phase" := Supply."Planning Line Phase"::"Line Created";
          end else begin
          if Supply."Planning Line No." <> ReqLine."Line No." then
            ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
          ReqLine.BlockDynamicTracking(true);
          AdjustPlanLine(Supply);
          if NewPhase = NewPhase::"Line Created" then
            ReqLine.MODIFY;
        end;

      if (NewPhase = NewPhase::"Routing Created") or
         ((NewPhase > NewPhase::"Routing Created") and
          (Supply."Planning Line Phase" < Supply."Planning Line Phase"::"Routing Created"))
      then begin
        ReqLine.BlockDynamicTracking(true);
        if Supply."Planning Line No." <> ReqLine."Line No." then
          ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
        AdjustPlanLine(Supply);
        if ReqLine.Quantity > 0 then begin
          if Supply."Starting Date" <> 0D then
            ReqLine."Starting Date" := Supply."Starting Date"
          else
            ReqLine."Starting Date" := Supply."Due Date";
          GetRouting(ReqLine);
          RecalculationRequired := true;
          if NewPhase = NewPhase::"Routing Created" then
            Supply."Planning Line Phase" := Supply."Planning Line Phase"::"Routing Created";
        end;
        ReqLine.MODIFY;
      end;

      if NewPhase = NewPhase::Exploded then begin
        if Supply."Planning Line No." <> ReqLine."Line No." then
          ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
        ReqLine.BlockDynamicTracking(true);
        AdjustPlanLine(Supply);
        if ReqLine.Quantity = 0 then
          if ReqLine."Action Message" = ReqLine."Action Message"::New then begin
            ReqLine.BlockDynamicTracking(true);
            ReqLine.DELETE(true);
          end else
            DisableRelations
        else begin
          GetComponents(ReqLine);
          RecalculationRequired := true;
        end;

        if ReqLine."Ref. Order Type" = ReqLine."Ref. Order Type"::Transfer then begin
          AdjustTransferDates(ReqLine);
          if ReqLine."Action Message" = ReqLine."Action Message"::New then begin
            CrntSupply.COPY(Supply);
            Supply.INIT;
            Supply."Line No." := NextLineNo;
            Supply."Item No." := ReqLine."No.";
            Supply.TransferFromOutboundTransfPlan(ReqLine,TempItemTrkgEntry);
            Supply."Lot No." := CrntSupply."Lot No.";
            Supply."Serial No." := CrntSupply."Serial No.";
            if Supply.IsSupply then
              Supply.ChangeSign;
            Supply.INSERT;

            Supply.COPY(CrntSupply);
          end else
            SynchronizeTransferProfiles(Supply,ReqLine);
        end;
      end;

      if RecalculationRequired then begin
        Recalculate(ReqLine,Direction);
        ReqLine.UpdateDatetime;
        ReqLine.MODIFY;

        Supply."Starting Date" := ReqLine."Starting Date";
        Supply."Due Date" := ReqLine."Due Date";
      end;

      if NewPhase = NewPhase::Obsolete then begin
        if Supply."Planning Line No." <> ReqLine."Line No." then
          ReqLine.GET(CurrTemplateName,CurrWorksheetName,Supply."Planning Line No.");
        ReqLine.DELETE(true);
        Supply."Planning Line No." := 0;
        Supply."Planning Line Phase" := Supply."Planning Line Phase"::" ";
      end;

      Supply.MODIFY;
    END;

    [External]
    PROCEDURE AdjustReorderQty@20(OrderQty@1001 : Decimal;SKU@1002 : Record "Stockkeeping Unit";SupplyLineNo@1003 : Integer;MinQty@1005 : Decimal) : Decimal;
    VAR
      DeltaQty@1000 : Decimal;
      Rounding@1004 : Decimal;
    BEGIN
      // Copy of this procedure exists in COD5400- Available Management
      if OrderQty <= 0 then
        exit(0);

      if (SKU."Maximum Order Quantity" < OrderQty) and
         (SKU."Maximum Order Quantity" <> 0) and
         (SKU."Maximum Order Quantity" > MinQty)
      then begin
        DeltaQty := SKU."Maximum Order Quantity" - OrderQty;
        Transparency.LogSurplus(
          SupplyLineNo,0,DATABASE::Item,TempSKU."Item No.",
          DeltaQty,SurplusType::MaxOrder);
      end else
        DeltaQty := 0;
      if SKU."Minimum Order Quantity" > (OrderQty + DeltaQty) then begin
        DeltaQty := SKU."Minimum Order Quantity" - OrderQty;
        Transparency.LogSurplus(
          SupplyLineNo,0,DATABASE::Item,TempSKU."Item No.",
          SKU."Minimum Order Quantity",SurplusType::MinOrder);
      end;
      if SKU."Order Multiple" <> 0 then begin
        Rounding := ROUND(OrderQty + DeltaQty,SKU."Order Multiple",'>') - (OrderQty + DeltaQty);
        DeltaQty += Rounding;
        if DeltaQty <> 0 then
          Transparency.LogSurplus(
            SupplyLineNo,0,DATABASE::Item,TempSKU."Item No.",
            Rounding,SurplusType::OrderMultiple);
      end;
      exit(DeltaQty);
    END;

    LOCAL PROCEDURE CalcInventoryProfileRemainingQty@109(VAR InventoryProfile@1000 : Record "Inventory Profile";DocumentNo@1001 : Code[20]) : Decimal;
    BEGIN
      with InventoryProfile do begin
        SETRANGE("Source Type",DATABASE::"Sales Line");
        SETRANGE("Ref. Blanket Order No.",DocumentNo);
        CALCSUMS("Remaining Quantity (Base)");
        exit("Remaining Quantity (Base)");
      end;
    END;

    LOCAL PROCEDURE CalcReorderQty@15(NeededQty@1000 : Decimal;ProjectedInventory@1001 : Decimal;SupplyLineNo@1002 : Integer) QtyToOrder : Decimal;
    VAR
      Item@1005 : Record Item;
      SKU@1004 : Record "Stockkeeping Unit";
    BEGIN
      // Calculate qty to order:
      // If Max:   QtyToOrder = MaxInv - ProjInvLevel
      // If Fixed: QtyToOrder = FixedReorderQty
      // Copy of this procedure exists in COD5400- Available Management
      case TempSKU."Reordering Policy" of
        TempSKU."Reordering Policy"::"Maximum Qty.":
          begin
            if TempSKU."Maximum Inventory" <= TempSKU."Reorder Point" then begin
              if PlanningResilicency then
                if SKU.GET(TempSKU."Location Code",TempSKU."Item No.",TempSKU."Variant Code") then
                  ReqLine.SetResiliencyError(
                    STRSUBSTNO(
                      Text004,SKU.FIELDCAPTION("Maximum Inventory"),SKU."Maximum Inventory",SKU.TABLECAPTION,
                      SKU."Location Code",SKU."Item No.",SKU."Variant Code",
                      SKU.FIELDCAPTION("Reorder Point"),SKU."Reorder Point"),
                    DATABASE::"Stockkeeping Unit",SKU.GETPOSITION)
                else
                  if Item.GET(TempSKU."Item No.") then
                    ReqLine.SetResiliencyError(
                      STRSUBSTNO(
                        Text005,Item.FIELDCAPTION("Maximum Inventory"),Item."Maximum Inventory",Item.TABLECAPTION,
                        Item."No.",Item.FIELDCAPTION("Reorder Point"),Item."Reorder Point"),
                      DATABASE::Item,Item.GETPOSITION);
              TempSKU.TESTFIELD("Maximum Inventory",TempSKU."Reorder Point" + 1); // Assertion
            end;

            QtyToOrder := TempSKU."Maximum Inventory" - ProjectedInventory;
            Transparency.LogSurplus(
              SupplyLineNo,0,DATABASE::Item,TempSKU."Item No.",
              QtyToOrder,SurplusType::MaxInventory);
          end;
        TempSKU."Reordering Policy"::"Fixed Reorder Qty.":
          begin
            if PlanningResilicency and (TempSKU."Reorder Quantity" = 0) then
              if SKU.GET(TempSKU."Location Code",TempSKU."Item No.",TempSKU."Variant Code") then
                ReqLine.SetResiliencyError(
                  STRSUBSTNO(
                    Text004,SKU.FIELDCAPTION("Reorder Quantity"),0,SKU.TABLECAPTION,
                    SKU."Location Code",SKU."Item No.",SKU."Variant Code",
                    SKU.FIELDCAPTION("Reordering Policy"),SKU."Reordering Policy"),
                  DATABASE::"Stockkeeping Unit",SKU.GETPOSITION)
              else
                if Item.GET(TempSKU."Item No.") then
                  ReqLine.SetResiliencyError(
                    STRSUBSTNO(
                      Text005,Item.FIELDCAPTION("Reorder Quantity"),0,Item.TABLECAPTION,
                      Item."No.",Item.FIELDCAPTION("Reordering Policy"),Item."Reordering Policy"),
                    DATABASE::Item,Item.GETPOSITION);

            TempSKU.TESTFIELD("Reorder Quantity"); // Assertion
            QtyToOrder := TempSKU."Reorder Quantity";
            Transparency.LogSurplus(
              SupplyLineNo,0,DATABASE::Item,TempSKU."Item No.",
              QtyToOrder,SurplusType::FixedOrderQty);
          end;
        else
          QtyToOrder := NeededQty;
      end;
    END;

    LOCAL PROCEDURE CalcOrderQty@95(NeededQty@1000 : Decimal;ProjectedInventory@1001 : Decimal;SupplyLineNo@1002 : Integer) QtyToOrder : Decimal;
    BEGIN
      QtyToOrder := CalcReorderQty(NeededQty,ProjectedInventory,SupplyLineNo);
      // Ensure that QtyToOrder is large enough to exceed ROP:
      if QtyToOrder <= (TempSKU."Reorder Point" - ProjectedInventory) then
        QtyToOrder :=
          ROUND((TempSKU."Reorder Point" - ProjectedInventory) / TempSKU."Reorder Quantity" + 0.000000001,1,'>') *
          TempSKU."Reorder Quantity";
    END;

    LOCAL PROCEDURE CalcSalesOrderQty@129(AsmLine@1000 : Record "Assembly Line") QtyOnSalesOrder : Decimal;
    VAR
      SalesOrderLine@1001 : Record "Sales Line";
      ATOLink@1002 : Record "Assemble-to-Order Link";
    BEGIN
      QtyOnSalesOrder := 0;
      ATOLink.GET(AsmLine."Document Type",AsmLine."Document No.");
      SalesOrderLine.SETCURRENTKEY("Document Type","Blanket Order No.","Blanket Order Line No.");
      SalesOrderLine.SETRANGE("Document Type",SalesOrderLine."Document Type"::Order);
      SalesOrderLine.SETRANGE("Blanket Order No.",ATOLink."Document No.");
      SalesOrderLine.SETRANGE("Blanket Order Line No.",ATOLink."Document Line No.");
      if SalesOrderLine.FIND('-') then
        repeat
          QtyOnSalesOrder += SalesOrderLine."Quantity (Base)";
        until SalesOrderLine.NEXT = 0;
    END;

    LOCAL PROCEDURE AdjustPlanLine@24(VAR Supply@1000 : Record "Inventory Profile");
    BEGIN
      with Supply do begin
        ReqLine."Action Message" := "Action Message";
        ReqLine.BlockDynamicTracking(true);
        if "Action Message" in
           ["Action Message"::New,
            "Action Message"::"Change Qty.",
            "Action Message"::Reschedule,
            "Action Message"::"Resched.& Chg. Qty.",
            "Action Message"::Cancel]
        then begin
          if "Qty. per Unit of Measure" = 0 then
            "Qty. per Unit of Measure" := 1;
          ReqLine.VALIDATE(
            Quantity,
            ROUND("Remaining Quantity (Base)" / "Qty. per Unit of Measure",0.00001));
          ReqLine."Original Quantity" := "Original Quantity";
          ReqLine."Net Quantity (Base)" :=
            (ReqLine."Remaining Quantity" - ReqLine."Original Quantity") *
            ReqLine."Qty. per Unit of Measure";
        end;
        ReqLine."Original Due Date" := "Original Due Date";
        ReqLine."Due Date" := "Due Date";
        if "Planning Level Code" = 0 then
          ReqLine."Ending Date" :=
            LeadTimeMgt.PlannedEndingDate(
              "Item No.","Location Code","Variant Code","Due Date",'',ReqLine."Ref. Order Type")
        else begin
          ReqLine."Ending Date" := "Due Date";
          ReqLine."Ending Time" := "Due Time";
        end;
        if (ReqLine."Starting Date" = 0D) or
           (ReqLine."Starting Date" > ReqLine."Ending Date")
        then
          ReqLine."Starting Date" := ReqLine."Ending Date";
      end;
    END;

    LOCAL PROCEDURE DisableRelations@37();
    VAR
      PlanningComponent@1000 : Record "Planning Component";
      PlanningRtngLine@1001 : Record "Planning Routing Line";
      ProdOrderCapNeed@1002 : Record "Prod. Order Capacity Need";
    BEGIN
      if ReqLine.Type <> ReqLine.Type::Item then
        exit;
      PlanningComponent.SETRANGE("Worksheet Template Name",ReqLine."Worksheet Template Name");
      PlanningComponent.SETRANGE("Worksheet Batch Name",ReqLine."Journal Batch Name");
      PlanningComponent.SETRANGE("Worksheet Line No.",ReqLine."Line No.");
      if PlanningComponent.FIND('-') then
        repeat
          PlanningComponent.BlockDynamicTracking(false);
          PlanningComponent.DELETE(true);
        until PlanningComponent.NEXT = 0;

      PlanningRtngLine.SETRANGE("Worksheet Template Name",ReqLine."Worksheet Template Name");
      PlanningRtngLine.SETRANGE("Worksheet Batch Name",ReqLine."Journal Batch Name");
      PlanningRtngLine.SETRANGE("Worksheet Line No.",ReqLine."Line No.");
      PlanningRtngLine.DELETEALL;

      with ProdOrderCapNeed do begin
        SETCURRENTKEY("Worksheet Template Name","Worksheet Batch Name","Worksheet Line No.");
        SETRANGE("Worksheet Template Name",ReqLine."Worksheet Template Name");
        SETRANGE("Worksheet Batch Name",ReqLine."Journal Batch Name");
        SETRANGE("Worksheet Line No.",ReqLine."Line No.");
        DELETEALL;
        RESET;
        SETCURRENTKEY(Status,"Prod. Order No.",Active);
        SETRANGE(Status,ReqLine."Ref. Order Status");
        SETRANGE("Prod. Order No.",ReqLine."Ref. Order No.");
        SETRANGE(Active,true);
        MODIFYALL(Active,false);
      end
    END;

    LOCAL PROCEDURE SynchronizeTransferProfiles@65(VAR InventoryProfile@1001 : Record "Inventory Profile";VAR TransferReqLine@1004 : Record "Requisition Line");
    VAR
      Supply@1000 : Record "Inventory Profile";
    BEGIN
      if InventoryProfile."Transfer Location Not Planned" then
        exit;
      Supply.COPY(InventoryProfile);
      if GetTransferSisterProfile(Supply,InventoryProfile) then begin
        TransferReqLineToInvProfiles(InventoryProfile,TransferReqLine);
        InventoryProfile.MODIFY;
      end;
      InventoryProfile.COPY(Supply);
    END;

    LOCAL PROCEDURE TransferReqLineToInvProfiles@105(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR TransferReqLine@1001 : Record "Requisition Line");
    BEGIN
      with InventoryProfile do begin
        TESTFIELD("Location Code",TransferReqLine."Transfer-from Code");

        "Min. Quantity" := "Remaining Quantity (Base)";
        "Original Quantity" := TransferReqLine."Original Quantity";
        Quantity := TransferReqLine.Quantity;
        "Remaining Quantity" := TransferReqLine.Quantity;
        "Quantity (Base)" := TransferReqLine."Quantity (Base)";
        "Remaining Quantity (Base)" := TransferReqLine."Quantity (Base)";
        "Untracked Quantity" := TransferReqLine."Quantity (Base)";
        "Unit of Measure Code" := TransferReqLine."Unit of Measure Code";
        "Qty. per Unit of Measure" := TransferReqLine."Qty. per Unit of Measure";
        "Due Date" := TransferReqLine."Transfer Shipment Date";
      end;
    END;

    LOCAL PROCEDURE SyncTransferDemandWithReqLine@104(VAR InventoryProfile@1000 : Record "Inventory Profile";LocationCode@1002 : Code[10]);
    VAR
      TransferReqLine@1001 : Record "Requisition Line";
    BEGIN
      with TransferReqLine do begin
        SETRANGE("Ref. Order Type","Ref. Order Type"::Transfer);
        SETRANGE("Ref. Order No.",InventoryProfile."Source ID");
        SETRANGE("Ref. Line No.",InventoryProfile."Source Ref. No.");
        SETRANGE("Transfer-from Code",InventoryProfile."Location Code");
        SETRANGE("Location Code",LocationCode);
        SETFILTER("Action Message",'<>%1',"Action Message"::New);
        if FINDFIRST then
          TransferReqLineToInvProfiles(InventoryProfile,TransferReqLine);
      end;
    END;

    LOCAL PROCEDURE GetTransferSisterProfile@71(CurrInvProfile@1000 : Record "Inventory Profile";VAR SisterInvProfile@1001 : Record "Inventory Profile") Ok : Boolean;
    BEGIN
      // Finds the invprofile which represents the opposite side of a transfer order.
      if (CurrInvProfile."Source Type" <> DATABASE::"Transfer Line") or
         (CurrInvProfile."Action Message" = CurrInvProfile."Action Message"::New)
      then
        exit(false);

      with SisterInvProfile do begin
        CLEAR(SisterInvProfile);
        SETRANGE("Source Type",DATABASE::"Transfer Line");
        SETRANGE("Source ID",CurrInvProfile."Source ID");
        SETRANGE("Source Ref. No.",CurrInvProfile."Source Ref. No.");
        SETRANGE("Lot No.",CurrInvProfile."Lot No.");
        SETRANGE("Serial No.",CurrInvProfile."Serial No.");
        SETRANGE(IsSupply,not CurrInvProfile.IsSupply);

        Ok := FIND('-');

        // Assertion: only 1 outbound transfer record may exist:
        if Ok then
          if NEXT <> 0 then
            ERROR(Text001,TABLECAPTION);

        exit;
      end;
    END;

    LOCAL PROCEDURE AdjustTransferDates@60(VAR TransferReqLine@1012 : Record "Requisition Line");
    VAR
      TransferRoute@1003 : Record "Transfer Route";
      ShippingAgentServices@1013 : Record "Shipping Agent Services";
      Location@1009 : Record Location;
      SKU@1001 : Record "Stockkeeping Unit";
      ShippingTime@1006 : DateFormula;
      OutboundWhseTime@1007 : DateFormula;
      InboundWhseTime@1008 : DateFormula;
      OK@1000 : Boolean;
    BEGIN
      // Used for planning lines handling transfer orders.
      // "Ending Date", Starting Date and "Transfer Shipment Date" are calculated backwards from "Due Date".

      TransferReqLine.TESTFIELD("Ref. Order Type",TransferReqLine."Ref. Order Type"::Transfer);
      with TransferReqLine do begin
        OK := Location.GET("Transfer-from Code");
        if PlanningResilicency and not OK then
          if SKU.GET("Location Code","No.","Variant Code") then
            ReqLine.SetResiliencyError(
              STRSUBSTNO(
                Text003,SKU.FIELDCAPTION("Transfer-from Code"),SKU.TABLECAPTION,
                SKU."Location Code",SKU."Item No.",SKU."Variant Code"),
              DATABASE::"Stockkeeping Unit",SKU.GETPOSITION);
        if not OK then
          Location.GET("Transfer-from Code");
        OutboundWhseTime := Location."Outbound Whse. Handling Time";

        Location.GET("Location Code");
        InboundWhseTime := Location."Inbound Whse. Handling Time";

        OK := TransferRoute.GET("Transfer-from Code","Location Code");
        if PlanningResilicency and not OK then
          ReqLine.SetResiliencyError(
            STRSUBSTNO(
              Text002,TransferRoute.TABLECAPTION,
              "Transfer-from Code","Location Code"),
            DATABASE::"Transfer Route",'');
        if not OK then
          TransferRoute.GET("Transfer-from Code","Location Code");

        if ShippingAgentServices.GET(TransferRoute."Shipping Agent Code",TransferRoute."Shipping Agent Service Code") then
          ShippingTime := ShippingAgentServices."Shipping Time"
        else
          EVALUATE(ShippingTime,'');

        // The calculation will run through the following steps:
        // ShipmentDate <- PlannedShipmentDate <- PlannedReceiptDate <- ReceiptDate

        // Calc Planned Receipt Date (Ending Date) backward from ReceiptDate
        TransferRoute.CalcPlanReceiptDateBackward(
          "Ending Date","Due Date",InboundWhseTime,
          "Location Code",TransferRoute."Shipping Agent Code",TransferRoute."Shipping Agent Service Code");

        // Calc Planned Shipment Date (Starting Date) backward from Planned ReceiptDate (Ending Date)
        TransferRoute.CalcPlanShipmentDateBackward(
          "Starting Date","Ending Date",ShippingTime,
          "Transfer-from Code",TransferRoute."Shipping Agent Code",TransferRoute."Shipping Agent Service Code");

        // Calc Shipment Date backward from Planned Shipment Date (Starting Date)
        TransferRoute.CalcShipmentDateBackward(
          "Transfer Shipment Date","Starting Date",OutboundWhseTime,"Transfer-from Code");

        UpdateDatetime;
        MODIFY;
      end;
    END;

    LOCAL PROCEDURE InsertTempTransferSKU@66(VAR TransLine@1000 : Record "Transfer Line");
    VAR
      SKU@1001 : Record "Stockkeeping Unit";
    BEGIN
      TempTransferSKU.INIT;
      TempTransferSKU."Item No." := TransLine."Item No.";
      TempTransferSKU."Variant Code" := TransLine."Variant Code";
      if TransLine.Quantity > 0 then
        TempTransferSKU."Location Code" := TransLine."Transfer-to Code"
      else
        TempTransferSKU."Location Code" := TransLine."Transfer-from Code";
      if SKU.GET(TempTransferSKU."Location Code",TempTransferSKU."Item No.",TempTransferSKU."Variant Code") then
        TempTransferSKU."Transfer-from Code" := SKU."Transfer-from Code"
      else
        TempTransferSKU."Transfer-from Code" := '';
      if TempTransferSKU.INSERT then;
    END;

    LOCAL PROCEDURE UpdateTempSKUTransferLevels@61();
    VAR
      SKU@1003 : Record "Stockkeeping Unit";
    BEGIN
      SKU.COPY(TempSKU);
      with TempTransferSKU do begin
        RESET;
        if FIND('-') then
          repeat
            TempSKU.RESET;
            if TempSKU.GET("Location Code","Item No.","Variant Code") then
              if TempSKU."Transfer-from Code" = '' then begin
                TempSKU.SETRANGE("Location Code","Transfer-from Code");
                TempSKU.SETRANGE("Item No.","Item No.");
                TempSKU.SETRANGE("Variant Code","Variant Code");
                if not TempSKU.FIND('-') then
                  "Transfer-Level Code" := -1
                else
                  "Transfer-Level Code" := TempSKU."Transfer-Level Code" - 1;
                TempSKU.GET("Location Code","Item No.","Variant Code");
                TempSKU."Transfer-from Code" := "Transfer-from Code";
                TempSKU."Transfer-Level Code" := "Transfer-Level Code";
                TempSKU.MODIFY;
                TempSKU.UpdateTempSKUTransferLevels(TempSKU,TempSKU,TempSKU."Transfer-from Code");
              end;
          until NEXT = 0;
      end;
      TempSKU.COPY(SKU);
    END;

    LOCAL PROCEDURE CancelTransfer@69(VAR Supply@1000 : Record "Inventory Profile";VAR Demand@1001 : Record "Inventory Profile";DemandExists@1004 : Boolean) Cancel : Boolean;
    VAR
      xSupply2@1002 : Record "Inventory Profile";
    BEGIN
      // Used to handle transfers where supply is planned with a higher Transfer Level Code than demand.
      // If you encounter the demand before the supply, the supply must be removed.

      if not DemandExists then
        exit(false);
      if Demand."Source Type" <> DATABASE::"Transfer Line" then
        exit(false);
      Demand.TESTFIELD(IsSupply,false);

      xSupply2.COPY(Supply);
      if GetTransferSisterProfile(Demand,Supply) then begin
        if Supply."Action Message" = Supply."Action Message"::New then
          Supply.FIELDERROR("Action Message");

        if Supply."Planning Flexibility" = Supply."Planning Flexibility"::Unlimited then begin
          Supply."Original Quantity" := Supply.Quantity;
          Supply."Max. Quantity" := Supply."Remaining Quantity (Base)";
          Supply."Quantity (Base)" := Supply."Min. Quantity";
          Supply."Remaining Quantity (Base)" := Supply."Min. Quantity";
          Supply."Untracked Quantity" := 0;

          if Supply."Remaining Quantity (Base)" = 0 then
            Supply."Action Message" := Supply."Action Message"::Cancel
          else
            Supply."Action Message" := Supply."Action Message"::"Change Qty.";
          Supply.MODIFY;

          MaintainPlanningLine(Supply,PlanningLineStage::Exploded,ScheduleDirection::Backward);
          Track(Supply,Demand,true,false,Supply.Binding::" ");
          Supply.DELETE;

          Cancel := (Supply."Action Message" = Supply."Action Message"::Cancel);

          // IF supply is fully cancelled, demand is deleted, otherwise demand is modified:
          if Cancel then
            Demand.DELETE
          else begin
            Demand.GET(Demand."Line No."); // Get the updated version
            Demand."Untracked Quantity" -= (Demand."Original Quantity" - Demand."Quantity (Base)");
            Demand.MODIFY;
          end;
        end;
      end;
      Supply.COPY(xSupply2);
    END;

    LOCAL PROCEDURE PostInvChgReminder@43(VAR InvChangeReminder@1000 : Record "Inventory Profile";InvProfile@1001 : Record "Inventory Profile";PostOnlyMinimum@1002 : Boolean);
    BEGIN
      // Update information on changes in the Projected Inventory over time
      // Only the quantity that is known for sure should be posted

      InvChangeReminder := InvProfile;

      if PostOnlyMinimum then begin
        InvChangeReminder."Remaining Quantity (Base)" -= InvProfile."Untracked Quantity";
        InvChangeReminder."Remaining Quantity (Base)" += InvProfile."Safety Stock Quantity";
      end;

      if not InvChangeReminder.INSERT then
        InvChangeReminder.MODIFY;
    END;

    LOCAL PROCEDURE QtyFromPendingReminders@31(VAR InvChangeReminder@1002 : Record "Inventory Profile";AtDate@1001 : Date;LatestBucketStartDate@1000 : Date) PendingQty : Decimal;
    VAR
      xInvChangeReminder@1003 : Record "Inventory Profile";
    BEGIN
      // Calculates the sum of queued up adjustments to the projected inventory level
      xInvChangeReminder.COPY(InvChangeReminder);

      InvChangeReminder.SETRANGE("Due Date",LatestBucketStartDate,AtDate);
      if InvChangeReminder.FINDSET then
        repeat
          if InvChangeReminder.IsSupply then
            PendingQty += InvChangeReminder."Remaining Quantity (Base)"
          else
            PendingQty -= InvChangeReminder."Remaining Quantity (Base)";
        until InvChangeReminder.NEXT = 0;

      InvChangeReminder.COPY(xInvChangeReminder);
    END;

    LOCAL PROCEDURE MaintainProjectedInv@44(VAR InvChangeReminder@1000 : Record "Inventory Profile";AtDate@1001 : Date;VAR LastProjectedInventory@1002 : Decimal;VAR LatestBucketStartDate@1003 : Date;VAR ROPHasBeenCrossed@1005 : Boolean);
    VAR
      NextBucketEndDate@1004 : Date;
      NewProjectedInv@1006 : Decimal;
      SupplyIncrementQty@1007 : Decimal;
      DemandIncrementQty@1008 : Decimal;
    BEGIN
      // Updates information about projected inventory up until AtDate or until reorder point is crossed.
      // The check is performed within time buckets.

      ROPHasBeenCrossed := false;
      LatestBucketStartDate := FindNextBucketStartDate(InvChangeReminder,AtDate,LatestBucketStartDate);
      NextBucketEndDate := LatestBucketStartDate + BucketSizeInDays - 1;

      while (NextBucketEndDate < AtDate) and not ROPHasBeenCrossed do begin
        InvChangeReminder.SETFILTER("Due Date",'%1..%2',LatestBucketStartDate,NextBucketEndDate);
        SupplyIncrementQty := 0;
        DemandIncrementQty := 0;
        if InvChangeReminder.FINDSET then
          repeat
            if InvChangeReminder.IsSupply then begin
              if InvChangeReminder."Order Relation" <> InvChangeReminder."Order Relation"::"Safety Stock" then
                SupplyIncrementQty += InvChangeReminder."Remaining Quantity (Base)";
            end else
              DemandIncrementQty -= InvChangeReminder."Remaining Quantity (Base)";
            InvChangeReminder.DELETE;
          until InvChangeReminder.NEXT = 0;

        NewProjectedInv := LastProjectedInventory + SupplyIncrementQty + DemandIncrementQty;
        if FutureSupplyWithinLeadtime > SupplyIncrementQty then
          FutureSupplyWithinLeadtime -= SupplyIncrementQty
        else
          FutureSupplyWithinLeadtime := 0;
        ROPHasBeenCrossed :=
          (LastProjectedInventory + SupplyIncrementQty > TempSKU."Reorder Point") and
          (NewProjectedInv <= TempSKU."Reorder Point") or
          (NewProjectedInv + FutureSupplyWithinLeadtime <= TempSKU."Reorder Point");
        LastProjectedInventory := NewProjectedInv;
        if ROPHasBeenCrossed then
          LatestBucketStartDate := NextBucketEndDate + 1
        else
          LatestBucketStartDate := FindNextBucketStartDate(InvChangeReminder,AtDate,LatestBucketStartDate);
        NextBucketEndDate := LatestBucketStartDate + BucketSizeInDays - 1;
      end;
    END;

    LOCAL PROCEDURE FindNextBucketStartDate@18(VAR InvChangeReminder@1000 : Record "Inventory Profile";AtDate@1001 : Date;LatestBucketStartDate@1003 : Date) NextBucketStartDate : Date;
    VAR
      NumberOfDaysToNextReminder@1005 : Integer;
    BEGIN
      if AtDate = 0D then
        exit(LatestBucketStartDate);

      InvChangeReminder.SETFILTER("Due Date",'%1..%2',LatestBucketStartDate,AtDate);
      if InvChangeReminder.FINDFIRST then
        AtDate := InvChangeReminder."Due Date";

      NumberOfDaysToNextReminder := AtDate - LatestBucketStartDate;
      NextBucketStartDate := AtDate - (NumberOfDaysToNextReminder mod BucketSizeInDays);
    END;

    LOCAL PROCEDURE SetIgnoreOverflow@49(VAR SupplyInvtProfile@1000 : Record "Inventory Profile");
    BEGIN
      // Apply a minimum quantity to the existing orders to protect the
      // remaining valid surplus from being reduced in the common balancing act

      with SupplyInvtProfile do begin
        if FINDSET(true) then
          repeat
            "Min. Quantity" := "Remaining Quantity (Base)";
            MODIFY;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE ChkInitialOverflow@50(VAR DemandInvtProfile@1002 : Record "Inventory Profile";VAR SupplyInvtProfile@1001 : Record "Inventory Profile";OverflowLevel@1004 : Decimal;InventoryLevel@1007 : Decimal;FromDate@1013 : Date;ToDate@1012 : Date);
    VAR
      xDemandInvtProfile@1005 : Record "Inventory Profile";
      xSupplyInvtProfile@1006 : Record "Inventory Profile";
      OverflowQty@1008 : Decimal;
      OriginalSupplyQty@1009 : Decimal;
      PrevBucketStartDate@1010 : Date;
      PrevBucketEndDate@1011 : Date;
      CurrBucketStartDate@1003 : Date;
      CurrBucketEndDate@1014 : Date;
      NumberOfDaysToNextSupply@1000 : Integer;
    BEGIN
      xDemandInvtProfile.COPY(DemandInvtProfile);
      xSupplyInvtProfile.COPY(SupplyInvtProfile);
      SupplyInvtProfile.SETRANGE("Is Exception Order",false);

      if OverflowLevel > 0 then begin
        // Detect if there is overflow in inventory within any time bucket
        // In that case: Decrease superfluous Supply; latest first
        // Apply a minimum quantity to the existing orders to protect the
        // remaining valid surplus from being reduced in the common balancing act

        // Avoid Safety Stock Demand
        DemandInvtProfile.SETRANGE("Order Relation",DemandInvtProfile."Order Relation"::Normal);

        PrevBucketStartDate := FromDate;
        CurrBucketEndDate := ToDate;

        while PrevBucketStartDate <= ToDate do begin
          SupplyInvtProfile.SETRANGE("Due Date",PrevBucketStartDate,ToDate);
          if SupplyInvtProfile.FINDFIRST then begin
            NumberOfDaysToNextSupply := SupplyInvtProfile."Due Date" - PrevBucketStartDate;
            CurrBucketEndDate :=
              SupplyInvtProfile."Due Date" - (NumberOfDaysToNextSupply mod BucketSizeInDays) + BucketSizeInDays - 1;
            CurrBucketStartDate := CurrBucketEndDate - BucketSizeInDays + 1;
            PrevBucketEndDate := CurrBucketStartDate - 1;

            DemandInvtProfile.SETRANGE("Due Date",PrevBucketStartDate,PrevBucketEndDate);
            if DemandInvtProfile.FINDSET then
              repeat
                InventoryLevel -= DemandInvtProfile."Remaining Quantity (Base)";
              until DemandInvtProfile.NEXT = 0;

            // Negative inventory from previous buckets shall not influence
            // possible overflow in the current time bucket
            if InventoryLevel < 0 then
              InventoryLevel := 0;

            DemandInvtProfile.SETRANGE("Due Date",CurrBucketStartDate,CurrBucketEndDate);
            if DemandInvtProfile.FINDSET then
              repeat
                InventoryLevel -= DemandInvtProfile."Remaining Quantity (Base)";
              until DemandInvtProfile.NEXT = 0;

            SupplyInvtProfile.SETRANGE("Due Date",CurrBucketStartDate,CurrBucketEndDate);
            if SupplyInvtProfile.FIND('-') then begin
              repeat
                InventoryLevel += SupplyInvtProfile."Remaining Quantity (Base)";
              until SupplyInvtProfile.NEXT = 0;

              OverflowQty := InventoryLevel - OverflowLevel;
              repeat
                if OverflowQty > 0 then begin
                  OriginalSupplyQty := SupplyInvtProfile."Quantity (Base)";
                  SupplyInvtProfile."Min. Quantity" := 0;
                  DecreaseQty(SupplyInvtProfile,OverflowQty);
                  if OriginalSupplyQty <> SupplyInvtProfile."Quantity (Base)" then begin
                    DummyInventoryProfileTrackBuffer."Warning Level" := DummyInventoryProfileTrackBuffer."Warning Level"::Attention;
                    Transparency.LogWarning(SupplyInvtProfile."Line No.",ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
                      STRSUBSTNO(Text010,InventoryLevel,OverflowLevel,CurrBucketEndDate));
                    OverflowQty -= (OriginalSupplyQty - SupplyInvtProfile."Quantity (Base)");
                    InventoryLevel -= (OriginalSupplyQty - SupplyInvtProfile."Quantity (Base)");
                  end;
                end;
                SupplyInvtProfile."Min. Quantity" := SupplyInvtProfile."Remaining Quantity (Base)";
                SupplyInvtProfile.MODIFY;
                if SupplyInvtProfile."Line No." = xSupplyInvtProfile."Line No." then
                  xSupplyInvtProfile := SupplyInvtProfile;
              until (SupplyInvtProfile.NEXT(-1) = 0);
            end;

            if InventoryLevel < 0 then
              InventoryLevel := 0;
            PrevBucketStartDate := CurrBucketEndDate + 1;
          end else
            PrevBucketStartDate := ToDate + 1;
        end;
      end else
        if OverflowLevel = 0 then
          SetIgnoreOverflow(SupplyInvtProfile);

      DemandInvtProfile.COPY(xDemandInvtProfile);
      SupplyInvtProfile.COPY(xSupplyInvtProfile);
    END;

    LOCAL PROCEDURE CheckNewOverflow@45(VAR SupplyInvtProfile@1000 : Record "Inventory Profile";InventoryLevel@1002 : Decimal;QtyToDecreaseOverFlow@1004 : Decimal;LastDueDate@1006 : Date);
    VAR
      xSupplyInvtProfile@1001 : Record "Inventory Profile";
      OriginalSupplyQty@1003 : Decimal;
      QtyToDecrease@1005 : Decimal;
    BEGIN
      // the function tries to avoid overflow when a new supply was suggested
      xSupplyInvtProfile.COPY(SupplyInvtProfile);
      SupplyInvtProfile.SETRANGE("Due Date",LastDueDate + 1,PlanToDate);
      SupplyInvtProfile.SETFILTER("Remaining Quantity (Base)",'>0');

      if SupplyInvtProfile.FINDSET(true) then
        repeat
          if SupplyInvtProfile."Original Quantity" > 0 then
            InventoryLevel := InventoryLevel + SupplyInvtProfile."Original Quantity" * SupplyInvtProfile."Qty. per Unit of Measure"
          else
            InventoryLevel := InventoryLevel + SupplyInvtProfile."Remaining Quantity (Base)";
          OriginalSupplyQty := SupplyInvtProfile."Quantity (Base)";

          if InventoryLevel > OverflowLevel then begin
            SupplyInvtProfile."Min. Quantity" := 0;
            DummyInventoryProfileTrackBuffer."Warning Level" := DummyInventoryProfileTrackBuffer."Warning Level"::Attention;
            QtyToDecrease := InventoryLevel - OverflowLevel;

            if QtyToDecrease > QtyToDecreaseOverFlow then
              QtyToDecrease := QtyToDecreaseOverFlow;

            if QtyToDecrease > SupplyInvtProfile."Remaining Quantity (Base)" then
              QtyToDecrease := SupplyInvtProfile."Remaining Quantity (Base)";

            DecreaseQty(SupplyInvtProfile,QtyToDecrease);

            Transparency.LogWarning(
              SupplyInvtProfile."Line No.",ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
              STRSUBSTNO(
                Text010,
                InventoryLevel,
                OverflowLevel,SupplyInvtProfile."Due Date"));

            QtyToDecreaseOverFlow := QtyToDecreaseOverFlow - (OriginalSupplyQty - SupplyInvtProfile."Quantity (Base)");
            InventoryLevel := InventoryLevel - (OriginalSupplyQty - SupplyInvtProfile."Quantity (Base)");
            SupplyInvtProfile."Min. Quantity" := SupplyInvtProfile."Remaining Quantity (Base)";
            SupplyInvtProfile.MODIFY;
          end;
        until (SupplyInvtProfile.NEXT = 0) or (QtyToDecreaseOverFlow <= 0);

      SupplyInvtProfile.COPY(xSupplyInvtProfile);
    END;

    LOCAL PROCEDURE CheckScheduleIn@62(VAR Supply@1000 : Record "Inventory Profile";TargetDate@1001 : Date;VAR PossibleDate@1002 : Date;LimitedHorizon@1004 : Boolean) : Boolean;
    BEGIN
      if Supply."Planning Flexibility" <> Supply."Planning Flexibility"::Unlimited then
        exit(false);

      if LimitedHorizon and not AllowScheduleIn(Supply,TargetDate) then
        PossibleDate := Supply."Due Date"
      else
        PossibleDate := TargetDate;

      exit(TargetDate = PossibleDate);
    END;

    LOCAL PROCEDURE CheckScheduleOut@67(VAR Supply@1000 : Record "Inventory Profile";TargetDate@1001 : Date;VAR PossibleDate@1002 : Date;LimitedHorizon@1003 : Boolean) : Boolean;
    BEGIN
      if Supply."Planning Flexibility" <> Supply."Planning Flexibility"::Unlimited then
        exit(false);

      if (TargetDate - Supply."Due Date") <= DampenersDays then
        PossibleDate := Supply."Due Date"
      else
        if not LimitedHorizon or
           (Supply."Planning Level Code" > 0)
        then
          PossibleDate := TargetDate
        else
          if AllowScheduleOut(Supply,TargetDate) then
            PossibleDate := TargetDate
          else begin
            // Do not reschedule but may be lot accumulation is still an option
            PossibleDate := Supply."Due Date";
            if Supply."Fixed Date" <> 0D then
              exit(AllowLotAccumulation(Supply,TargetDate));
            exit(false);
          end;

      // Limit possible rescheduling in case the supply is already linked up to another demand
      if (Supply."Fixed Date" <> 0D) and
         (Supply."Fixed Date" < PossibleDate)
      then begin
        if not AllowLotAccumulation(Supply,TargetDate) then // but reschedule only if lot accumulation is allowed for target date
          exit(false);

        PossibleDate := Supply."Fixed Date";
      end;

      exit(true);
    END;

    LOCAL PROCEDURE CheckSupplyWithSKU@99(VAR InventoryProfile@1000 : Record "Inventory Profile";VAR SKU@1001 : Record "Stockkeeping Unit");
    VAR
      xInventoryProfile@1002 : Record "Inventory Profile";
    BEGIN
      xInventoryProfile.COPY(InventoryProfile);

      with InventoryProfile do begin
        if SKU."Maximum Order Quantity" > 0 then
          if FIND('-') then
            repeat
              if (SKU."Maximum Order Quantity" > "Max. Quantity") and
                 ("Quantity (Base)" > 0) and
                 ("Max. Quantity" = 0)
              then begin
                "Max. Quantity" := SKU."Maximum Order Quantity";
                MODIFY;
              end;
            until NEXT = 0;
      end;
      InventoryProfile.COPY(xInventoryProfile);
      if InventoryProfile.GET(InventoryProfile."Line No.") then;
    END;

    LOCAL PROCEDURE CreateSupplyForward@68(VAR Supply@1000 : Record "Inventory Profile";AtDate@1001 : Date;ProjectedInventory@1003 : Decimal;VAR NewSupplyHasTakenOver@1005 : Boolean;CurrDueDate@1012 : Date);
    VAR
      InterimSupply@1006 : TEMPORARY Record "Inventory Profile";
      CurrSupply@1008 : Record "Inventory Profile";
      LeadTimeEndDate@1007 : Date;
      QtyToOrder@1002 : Decimal;
      QtyToOrderThisLine@1010 : Decimal;
      SupplyWithinLeadtime@1004 : Decimal;
      HasLooped@1009 : Boolean;
      CurrSupplyExists@1011 : Boolean;
      QtyToDecreaseOverFlow@1013 : Decimal;
    BEGIN
      // Save current supply and check if it is real
      CurrSupply := Supply;
      CurrSupplyExists := Supply.FIND('=');

      // Initiate new supplyprofile
      InitSupply(InterimSupply,0,AtDate);

      // Make sure VAR boolean is reset:
      NewSupplyHasTakenOver := false;
      QtyToOrder := CalcOrderQty(QtyToOrder,ProjectedInventory,InterimSupply."Line No.");

      // Use new supplyprofile to determine lead-time
      UpdateQty(InterimSupply,QtyToOrder + AdjustReorderQty(QtyToOrder,TempSKU,InterimSupply."Line No.",0));
      InterimSupply.INSERT;
      ScheduleForward(InterimSupply,AtDate);
      LeadTimeEndDate := InterimSupply."Due Date";

      // Find supply within leadtime, returns a qty
      SupplyWithinLeadtime := SumUpProjectedSupply(Supply,AtDate,LeadTimeEndDate);
      FutureSupplyWithinLeadtime := SupplyWithinLeadtime;

      // If found supply + projinvlevel covers ROP then the situation has already been taken care of: roll back and (exit)
      if SupplyWithinLeadtime + ProjectedInventory > TempSKU."Reorder Point" then begin
        // Delete obsolete Planning Line
        MaintainPlanningLine(InterimSupply,PlanningLineStage::Obsolete,ScheduleDirection::Backward);
        Transparency.CleanLog(InterimSupply."Line No.");
        exit;
      end;

      // If Max: Deduct found supply in order to stay below max inventory and adjust transparency log
      if TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::"Maximum Qty." then
        if SupplyWithinLeadtime <> 0 then begin
          QtyToOrder -= SupplyWithinLeadtime;
          Transparency.ModifyLogEntry(
            InterimSupply."Line No.",0,DATABASE::Item,TempSKU."Item No.",-SupplyWithinLeadtime,SurplusType::MaxInventory);
        end;

      LeadTimeEndDate := AtDate;

      while QtyToOrder > 0 do begin
        // In case of max order the new supply could be split in several new supplies:
        if HasLooped then begin
          InitSupply(InterimSupply,0,AtDate);
          case TempSKU."Reordering Policy" of
            TempSKU."Reordering Policy"::"Maximum Qty.":
              SurplusType := SurplusType::MaxInventory;
            TempSKU."Reordering Policy"::"Fixed Reorder Qty.":
              SurplusType := SurplusType::FixedOrderQty;
          end;
          Transparency.LogSurplus(InterimSupply."Line No.",0,0,'',QtyToOrder,SurplusType);
          QtyToOrderThisLine := QtyToOrder + AdjustReorderQty(QtyToOrder,TempSKU,InterimSupply."Line No.",0);
          UpdateQty(InterimSupply,QtyToOrderThisLine);
          InterimSupply.INSERT;
          ScheduleForward(InterimSupply,AtDate);
        end else begin
          QtyToOrderThisLine := QtyToOrder + AdjustReorderQty(QtyToOrder,TempSKU,InterimSupply."Line No.",0);
          if QtyToOrderThisLine <> InterimSupply."Remaining Quantity (Base)" then begin
            UpdateQty(InterimSupply,QtyToOrderThisLine);
            ScheduleForward(InterimSupply,AtDate);
          end;
          HasLooped := true;
        end;

        // The supply is inserted into the overall supply dataset
        Supply := InterimSupply;
        InterimSupply.DELETE;
        Supply."Min. Quantity" := Supply."Remaining Quantity (Base)";
        Supply."Max. Quantity" := TempSKU."Maximum Order Quantity";
        Supply."Fixed Date" := Supply."Due Date";
        Supply."Order Priority" := 1000; // Make sure to give last priority if supply exists on the same date
        Supply."Attribute Priority" := 1000;
        Supply.INSERT;

        // Planning Transparency
        Transparency.LogSurplus(Supply."Line No.",0,0,'',Supply."Untracked Quantity",SurplusType::ReorderPoint);

        if Supply."Due Date" < CurrDueDate then begin
          CurrSupply := Supply;
          CurrDueDate := Supply."Due Date";
          NewSupplyHasTakenOver := true
        end;

        if LeadTimeEndDate < Supply."Due Date" then
          LeadTimeEndDate := Supply."Due Date";

        if (not CurrSupplyExists) or
           (Supply."Due Date" < CurrSupply."Due Date")
        then begin
          CurrSupply := Supply;
          CurrSupplyExists := true;
          NewSupplyHasTakenOver := CurrSupply."Due Date" <= CurrDueDate;
        end;

        QtyToOrder -= Supply."Remaining Quantity (Base)";
        FutureSupplyWithinLeadtime += Supply."Remaining Quantity (Base)";
        QtyToDecreaseOverFlow += Supply."Quantity (Base)";
      end;

      if HasLooped and (OverflowLevel > 0) then
        // the new supply might cause overflow in inventory since
        // it wasn't considered when Overflow was calculated
        CheckNewOverflow(Supply,ProjectedInventory + QtyToDecreaseOverFlow,QtyToDecreaseOverFlow,LeadTimeEndDate);

      Supply := CurrSupply;
    END;

    LOCAL PROCEDURE AllowScheduleIn@58(SupplyInvtProfile@1000 : Record "Inventory Profile";TargetDate@1001 : Date) CanReschedule : Boolean;
    BEGIN
      CanReschedule := CALCDATE(TempSKU."Rescheduling Period",TargetDate) >= SupplyInvtProfile."Due Date";
    END;

    LOCAL PROCEDURE AllowScheduleOut@87(SupplyInvtProfile@1000 : Record "Inventory Profile";TargetDate@1001 : Date) CanReschedule : Boolean;
    BEGIN
      CanReschedule := CALCDATE(TempSKU."Rescheduling Period",SupplyInvtProfile."Due Date") >= TargetDate;
    END;

    LOCAL PROCEDURE AllowLotAccumulation@88(SupplyInvtProfile@1000 : Record "Inventory Profile";DemandDueDate@1001 : Date) AccumulationOK : Boolean;
    BEGIN
      AccumulationOK := CALCDATE(TempSKU."Lot Accumulation Period",SupplyInvtProfile."Due Date") >= DemandDueDate;
    END;

    LOCAL PROCEDURE ShallSupplyBeClosed@89(SupplyInventoryProfile@1000 : Record "Inventory Profile";DemandDueDate@1001 : Date;IsReorderPointPlanning@1002 : Boolean) : Boolean;
    VAR
      CloseSupply@1003 : Boolean;
    BEGIN
      if SupplyInventoryProfile."Is Exception Order" then begin
        if TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::"Lot-for-Lot" then
          // supply within Lot Accumulation Period will be summed up with Exception order
          CloseSupply := not AllowLotAccumulation(SupplyInventoryProfile,DemandDueDate)
        else
          // only demand in the same day as Exception will be summed up
          CloseSupply := SupplyInventoryProfile."Due Date" <> DemandDueDate;
      end else
        CloseSupply := IsReorderPointPlanning;

      exit(CloseSupply);
    END;

    LOCAL PROCEDURE NextLineNo@64() : Integer;
    BEGIN
      LineNo += 1;
      exit(LineNo);
    END;

    LOCAL PROCEDURE Reschedule@57(VAR Supply@1001 : Record "Inventory Profile";TargetDate@1000 : Date;TargetTime@1003 : Time);
    BEGIN
      Supply.TESTFIELD("Planning Flexibility",Supply."Planning Flexibility"::Unlimited);

      if (TargetDate <> Supply."Due Date") and
         (Supply."Action Message" <> Supply."Action Message"::New)
      then begin
        if Supply."Original Due Date" = 0D then
          Supply."Original Due Date" := Supply."Due Date";
        if Supply."Original Quantity" = 0 then
          Supply."Action Message" := Supply."Action Message"::Reschedule
        else
          Supply."Action Message" := Supply."Action Message"::"Resched.& Chg. Qty.";
      end;
      Supply."Due Date" := TargetDate;
      if (Supply."Due Time" = 000000T) or
         (Supply."Due Time" > TargetTime)
      then
        Supply."Due Time" := TargetTime;
      Supply.MODIFY;
    END;

    LOCAL PROCEDURE InitSupply@72(VAR Supply@1001 : Record "Inventory Profile";OrderQty@1002 : Decimal;DueDate@1000 : Date);
    VAR
      Item@1003 : Record Item;
      ItemUnitOfMeasure@1004 : Record "Item Unit of Measure";
    BEGIN
      Supply.INIT;
      Supply."Line No." := NextLineNo;
      Supply."Item No." := TempSKU."Item No.";
      Supply."Variant Code" := TempSKU."Variant Code";
      Supply."Location Code" := TempSKU."Location Code";
      Supply."Action Message" := Supply."Action Message"::New;
      UpdateQty(Supply,OrderQty);
      Supply."Due Date" := DueDate;
      Supply.IsSupply := true;
      Item.GET(TempSKU."Item No.");
      Supply."Unit of Measure Code" := Item."Base Unit of Measure";
      Supply."Qty. per Unit of Measure" := 1;

      case TempSKU."Replenishment System" of
        TempSKU."Replenishment System"::Purchase:
          begin
            Supply."Source Type" := DATABASE::"Purchase Line";
            Supply."Unit of Measure Code" := Item."Purch. Unit of Measure";
            if Supply."Unit of Measure Code" <> Item."Base Unit of Measure" then begin
              ItemUnitOfMeasure.GET(TempSKU."Item No.",Item."Purch. Unit of Measure");
              Supply."Qty. per Unit of Measure" := ItemUnitOfMeasure."Qty. per Unit of Measure";
            end;
          end;
        TempSKU."Replenishment System"::"Prod. Order":
          Supply."Source Type" := DATABASE::"Prod. Order Line";
        TempSKU."Replenishment System"::Assembly:
          Supply."Source Type" := DATABASE::"Assembly Header";
        TempSKU."Replenishment System"::Transfer:
          Supply."Source Type" := DATABASE::"Transfer Line";
      end;
    END;

    LOCAL PROCEDURE UpdateQty@13(VAR InvProfile@1001 : Record "Inventory Profile";Qty@1002 : Decimal);
    BEGIN
      with InvProfile do begin
        "Untracked Quantity" := Qty;
        "Quantity (Base)" := "Untracked Quantity";
        "Remaining Quantity (Base)" := "Quantity (Base)";
      end;
    END;

    LOCAL PROCEDURE TransferAttributes@73(VAR ToInvProfile@1000 : Record "Inventory Profile";VAR FromInvProfile@1001 : Record "Inventory Profile");
    BEGIN
      if SpecificLotTracking then
        ToInvProfile."Lot No." := FromInvProfile."Lot No.";
      if SpecificSNTracking then
        ToInvProfile."Serial No." := FromInvProfile."Serial No.";

      if TempSKU."Replenishment System" = TempSKU."Replenishment System"::"Prod. Order" then
        if FromInvProfile."Planning Level Code" > 0 then begin
          ToInvProfile.Binding := ToInvProfile.Binding::"Order-to-Order";
          ToInvProfile."Planning Level Code" := FromInvProfile."Planning Level Code";
          ToInvProfile."Due Time" := FromInvProfile."Due Time";
        end;

      if FromInvProfile.Binding = FromInvProfile.Binding::"Order-to-Order" then begin
        ToInvProfile.Binding := ToInvProfile.Binding::"Order-to-Order";
        ToInvProfile."Primary Order Status" := FromInvProfile."Primary Order Status";
        ToInvProfile."Primary Order No." := FromInvProfile."Primary Order No.";
        ToInvProfile."Primary Order Line" := FromInvProfile."Primary Order Line";
      end;

      ToInvProfile."MPS Order" := FromInvProfile."MPS Order";

      if ToInvProfile.TrackingExists then
        ToInvProfile."Planning Flexibility" := ToInvProfile."Planning Flexibility"::None;
    END;

    LOCAL PROCEDURE AllocateSafetystock@77(VAR Supply@1000 : Record "Inventory Profile";QtyToAllocate@1001 : Decimal;AtDate@1003 : Date);
    VAR
      MinQtyToCoverSafetyStock@1002 : Decimal;
    BEGIN
      if QtyToAllocate > Supply."Safety Stock Quantity" then begin
        Supply."Safety Stock Quantity" := QtyToAllocate;
        MinQtyToCoverSafetyStock :=
          Supply."Remaining Quantity (Base)" - Supply."Untracked Quantity" + Supply."Safety Stock Quantity";
        if Supply."Min. Quantity" < MinQtyToCoverSafetyStock then
          Supply."Min. Quantity" := MinQtyToCoverSafetyStock;
        if Supply."Min. Quantity" > Supply."Remaining Quantity (Base)" then
          ERROR(Text001,Supply.FIELDCAPTION("Safety Stock Quantity"));
        if (Supply."Fixed Date" = 0D) or (Supply."Fixed Date" > AtDate) then
          Supply."Fixed Date" := AtDate;
        Supply.MODIFY;
      end;
    END;

    LOCAL PROCEDURE SumUpProjectedSupply@81(VAR Supply@1002 : Record "Inventory Profile";FromDate@1000 : Date;ToDate@1001 : Date) ProjectedQty : Decimal;
    VAR
      xSupply@1003 : Record "Inventory Profile";
    BEGIN
      // Sums up the contribution to the projected inventory

      xSupply.COPY(Supply);
      Supply.SETRANGE("Due Date",FromDate,ToDate);

      if Supply.FINDSET then
        repeat
          if (Supply.Binding <> Supply.Binding::"Order-to-Order") and
             (Supply."Order Relation" <> Supply."Order Relation"::"Safety Stock")
          then
            ProjectedQty += Supply."Remaining Quantity (Base)";
        until Supply.NEXT = 0;

      Supply.COPY(xSupply);
    END;

    LOCAL PROCEDURE SumUpAvailableSupply@30(VAR Supply@1002 : Record "Inventory Profile";FromDate@1000 : Date;ToDate@1001 : Date) AvailableQty : Decimal;
    VAR
      xSupply@1003 : Record "Inventory Profile";
    BEGIN
      // Sums up the contribution to the available inventory

      xSupply.COPY(Supply);
      Supply.SETRANGE("Due Date",FromDate,ToDate);

      if Supply.FINDSET then
        repeat
          AvailableQty += Supply."Untracked Quantity";
        until Supply.NEXT = 0;

      Supply.COPY(xSupply);
    END;

    LOCAL PROCEDURE SetPriority@80(VAR InvProfile@1000 : Record "Inventory Profile";IsReorderPointPlanning@1001 : Boolean;ToDate@1002 : Date);
    BEGIN
      with InvProfile do begin
        if IsSupply then begin
          if "Due Date" > ToDate then
            "Planning Flexibility" := "Planning Flexibility"::None;

          if IsReorderPointPlanning and (Binding <> Binding::"Order-to-Order") and
             ("Planning Flexibility" <> "Planning Flexibility"::None)
          then
            "Planning Flexibility" := "Planning Flexibility"::"Reduce Only";

          case "Source Type" of
            DATABASE::"Item Ledger Entry":
              "Order Priority" := 100;
            DATABASE::"Sales Line":
              case "Source Order Status" of // Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order
                5:
                  "Order Priority" := 200; // Return Order
                1:
                  "Order Priority" := 200; // Negative Sales Order
              end;
            DATABASE::"Job Planning Line":
              "Order Priority" := 230;
            DATABASE::"Transfer Line",DATABASE::"Requisition Line":
              "Order Priority" := 300;
            DATABASE::"Assembly Header":
              "Order Priority" := 320;
            DATABASE::"Prod. Order Line":
              case "Source Order Status" of // Simulated,Planned,Firm Planned,Released,Finished
                3:
                  "Order Priority" := 400; // Released
                2:
                  "Order Priority" := 410; // Firm Planned
                1:
                  "Order Priority" := 420; // Planned
              end;
            DATABASE::"Purchase Line":
              "Order Priority" := 500;
            DATABASE::"Prod. Order Component",DATABASE::"Planning Component":
              case "Source Order Status" of // Simulated,Planned,Firm Planned,Released,Finished
                3:
                  "Order Priority" := 600; // Released
                2:
                  "Order Priority" := 610; // Firm Planned
                1:
                  "Order Priority" := 620; // Planned
              end;
          end;
        end else  // Demand
          case "Source Type" of
            DATABASE::"Item Ledger Entry":
              "Order Priority" := 100;
            DATABASE::"Purchase Line":
              "Order Priority" := 200;
            DATABASE::"Sales Line":
              case "Source Order Status" of // Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order
                1:
                  "Order Priority" := 300; // Order
                4:
                  "Order Priority" := 700; // Blanket Order
                5:
                  "Order Priority" := 300; // Negative Return Order
              end;
            DATABASE::"Service Line":
              "Order Priority" := 400;
            DATABASE::"Job Planning Line":
              "Order Priority" := 450;
            DATABASE::"Assembly Line":
              "Order Priority" := 470;
            DATABASE::"Prod. Order Component",DATABASE::"Planning Component":
              case "Source Order Status" of // Simulated,Planned,Firm Planned,Released,Finished
                3:
                  "Order Priority" := 500; // Released
                2:
                  "Order Priority" := 510; // Firm Planned
                1:
                  "Order Priority" := 520; // Planned
                0:
                  "Order Priority" := 600;
              end;
            DATABASE::"Transfer Line",DATABASE::"Requisition Line":
              "Order Priority" := 600;
            DATABASE::"Production Forecast Entry":
              "Order Priority" := 800;
          end;

        TESTFIELD("Order Priority");

        // Inflexible supply must be handled before all other supply and is therefore grouped
        // together with inventory in group 100:
        if IsSupply and ("Source Type" <> DATABASE::"Item Ledger Entry") then
          if "Planning Flexibility" <> "Planning Flexibility"::Unlimited then
            "Order Priority" := 100 + ("Order Priority" / 10);

        if "Planning Flexibility" = "Planning Flexibility"::Unlimited then
          if ActiveInWarehouse then
            "Order Priority" -= 1;

        SetAttributePriority(InvProfile);

        MODIFY;
      end;
    END;

    LOCAL PROCEDURE SetAttributePriority@47(VAR InvProfile@1000 : Record "Inventory Profile");
    VAR
      HandleLot@1002 : Boolean;
      HandleSN@1001 : Boolean;
    BEGIN
      with InvProfile do begin
        HandleSN := ("Serial No." <> '') and SpecificSNTracking;
        HandleLot := ("Lot No." <> '') and SpecificLotTracking;

        if HandleSN then begin
          if HandleLot then
            if Binding = Binding::"Order-to-Order" then
              "Attribute Priority" := 1
            else
              "Attribute Priority" := 4
          else
            if Binding = Binding::"Order-to-Order" then
              "Attribute Priority" := 2
            else
              "Attribute Priority" := 5;
        end else begin
          if HandleLot then
            if Binding = Binding::"Order-to-Order" then
              "Attribute Priority" := 3
            else
              "Attribute Priority" := 6
          else
            if Binding = Binding::"Order-to-Order" then
              "Attribute Priority" := 7;
        end;
      end;
    END;

    LOCAL PROCEDURE UpdatePriorities@86(VAR InvProfile@1000 : Record "Inventory Profile";IsReorderPointPlanning@1002 : Boolean;ToDate@1003 : Date);
    VAR
      xInvProfile@1001 : Record "Inventory Profile";
    BEGIN
      xInvProfile.COPY(InvProfile);
      InvProfile.SETCURRENTKEY("Line No.");
      if InvProfile.FINDSET(true) then
        repeat
          SetPriority(InvProfile,IsReorderPointPlanning,ToDate);
        until InvProfile.NEXT = 0;
      InvProfile.COPY(xInvProfile);
    END;

    LOCAL PROCEDURE InsertSafetyStockDemands@84(VAR Demand@1000 : Record "Inventory Profile";PlanningStartDate@1004 : Date);
    VAR
      xDemand@1002 : Record "Inventory Profile";
      SafetyStockDemandBuffer@1001 : TEMPORARY Record "Inventory Profile";
      OrderRelation@1003 : 'Normal,"Safety Stock","Reorder Point"';
    BEGIN
      if TempSKU."Safety Stock Quantity" = 0 then
        exit;
      xDemand.COPY(Demand);

      Demand.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");
      Demand.SETFILTER("Due Date",'%1..',PlanningStartDate);

      if Demand.FINDSET then
        repeat
          if SafetyStockDemandBuffer."Due Date" <> Demand."Due Date" then
            CreateDemand(SafetyStockDemandBuffer,TempSKU,TempSKU."Safety Stock Quantity",
              Demand."Due Date",OrderRelation::"Safety Stock");
        until Demand.NEXT = 0;

      Demand.SETRANGE("Due Date",PlanningStartDate);
      if Demand.ISEMPTY then
        CreateDemand(SafetyStockDemandBuffer,TempSKU,TempSKU."Safety Stock Quantity",PlanningStartDate,OrderRelation::"Safety Stock");

      if SafetyStockDemandBuffer.FINDSET(true) then
        repeat
          Demand := SafetyStockDemandBuffer;
          Demand."Order Priority" := 1000;
          Demand.INSERT;
        until SafetyStockDemandBuffer.NEXT = 0;

      Demand.COPY(xDemand)
    END;

    LOCAL PROCEDURE ScheduleAllOutChangesSequence@10(VAR Supply@1000 : Record "Inventory Profile";NewDate@1006 : Date) : Boolean;
    VAR
      xSupply@1004 : Record "Inventory Profile";
      TempRescheduledSupply@1002 : TEMPORARY Record "Inventory Profile";
      TryRescheduleSupply@1003 : Boolean;
      HasLooped@1005 : Boolean;
      Continue@1007 : Boolean;
      NumberofSupplies@1008 : Integer;
    BEGIN
      xSupply.COPY(Supply);
      if (Supply."Due Date" = 0D) or
         (Supply."Planning Flexibility" <> Supply."Planning Flexibility"::Unlimited)
      then
        exit(false);

      if not AllowScheduleOut(Supply,NewDate) then
        exit(false);

      Continue := true;
      TryRescheduleSupply := true;

      while Continue do begin
        NumberofSupplies += 1;
        TempRescheduledSupply := Supply;
        TempRescheduledSupply."Line No." := -TempRescheduledSupply."Line No."; // Use negative Line No. to shift sequence
        TempRescheduledSupply.INSERT;
        if TryRescheduleSupply then begin
          Reschedule(TempRescheduledSupply,NewDate,000000T);
          Continue := TempRescheduledSupply."Due Date" <> Supply."Due Date";
        end;
        if Continue then
          if Supply.NEXT <> 0 then begin
            Continue := Supply."Due Date" <= NewDate;
            TryRescheduleSupply :=
              (Supply."Planning Flexibility" = Supply."Planning Flexibility"::Unlimited) and (Supply."Fixed Date" = 0D);
          end else
            Continue := false;
      end;

      // If there is only one supply before the demand we roll back
      if NumberofSupplies = 1 then begin
        Supply.COPY(xSupply);
        exit(false);
      end;

      TempRescheduledSupply.SETCURRENTKEY(
        "Item No.","Variant Code","Location Code","Due Date","Attribute Priority","Order Priority");

      // If we have resheduled we replace the original supply records with the resceduled ones,
      // we re-write the primary key to make sure that the supplies are handled in the right order.
      if TempRescheduledSupply.FINDSET then begin
        repeat
          Supply."Line No." := -TempRescheduledSupply."Line No.";
          Supply.DELETE;
          Supply := TempRescheduledSupply;
          Supply."Line No." := NextLineNo;
          Supply.INSERT;
          if not HasLooped then begin
            xSupply := Supply; // The first supply is bookmarked
            HasLooped := true;
          end;
        until TempRescheduledSupply.NEXT = 0;
        Supply := xSupply;
      end;

      exit(true);
    END;

    LOCAL PROCEDURE PrepareOrderToOrderLink@16(VAR InventoryProfile@1000 : Record "Inventory Profile");
    BEGIN
      // Prepare new demand for order-to-order planning
      with InventoryProfile do begin
        if FINDSET(true) then
          repeat
            if not IsSupply then
              if not ("Source Type" = DATABASE::"Production Forecast Entry") then
                if not (("Source Type" = DATABASE::"Sales Line") and ("Source Order Status" = 4)) then // Blanket Order
                  if (TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::Order) or
                     ("Planning Level Code" <> 0)
                  then begin
                    if "Source Type" = DATABASE::"Planning Component" then begin
                      // Primary Order references have already been set on Component Lines
                      Binding := Binding::"Order-to-Order";
                    end else begin
                      Binding := Binding::"Order-to-Order";
                      "Primary Order Type" := "Source Type";
                      "Primary Order Status" := "Source Order Status";
                      "Primary Order No." := "Source ID";
                      if "Source Type" <> DATABASE::"Prod. Order Component" then
                        "Primary Order Line" := "Source Ref. No.";
                    end;
                    MODIFY;
                  end;
          until NEXT = 0;
      end;
    END;

    LOCAL PROCEDURE SetAcceptAction@5(ItemNo@1000 : Code[20]);
    VAR
      ReqLine@1001 : Record "Requisition Line";
      PurchHeader@1002 : Record "Purchase Header";
      ProdOrder@1003 : Record "Production Order";
      TransHeader@1004 : Record "Transfer Header";
      AsmHeader@1007 : Record "Assembly Header";
      ReqWkshTempl@1006 : Record "Req. Wksh. Template";
      AcceptActionMsg@1005 : Boolean;
    BEGIN
      with ReqLine do begin
        ReqWkshTempl.GET(CurrTemplateName);
        if ReqWkshTempl.Type <> ReqWkshTempl.Type::Planning then
          exit;
        SETCURRENTKEY("Worksheet Template Name","Journal Batch Name",Type,"No.");
        SETRANGE("Worksheet Template Name",CurrTemplateName);
        SETRANGE("Journal Batch Name",CurrWorksheetName);
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",ItemNo);
        DummyInventoryProfileTrackBuffer."Warning Level" := DummyInventoryProfileTrackBuffer."Warning Level"::Attention;

        if FINDSET(true) then
          repeat
            AcceptActionMsg := "Starting Date" >= WORKDATE;
            if not AcceptActionMsg then
              Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
                STRSUBSTNO(Text008,DummyInventoryProfileTrackBuffer."Warning Level",FIELDCAPTION("Starting Date"),
                  "Starting Date",WORKDATE));

            if "Action Message" <> "Action Message"::New then
              case "Ref. Order Type" of
                "Ref. Order Type"::Purchase:
                  if (PurchHeader.GET(PurchHeader."Document Type"::Order,"Ref. Order No.") and
                      (PurchHeader.Status = PurchHeader.Status::Released))
                  then begin
                    AcceptActionMsg := false;
                    Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",STRSUBSTNO(Text009,
                        DummyInventoryProfileTrackBuffer."Warning Level",PurchHeader.FIELDCAPTION(Status),"Ref. Order Type",
                        "Ref. Order No.",PurchHeader.Status));
                  end;
                "Ref. Order Type"::"Prod. Order":
                  if "Ref. Order Status" = ProdOrder.Status::Released then begin
                    AcceptActionMsg := false;
                    Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",STRSUBSTNO(Text009,
                        DummyInventoryProfileTrackBuffer."Warning Level",ProdOrder.FIELDCAPTION(Status),"Ref. Order Type",
                        "Ref. Order No.","Ref. Order Status"));
                  end;
                "Ref. Order Type"::Assembly:
                  if AsmHeader.GET("Ref. Order Status","Ref. Order No.") and
                     (AsmHeader.Status = AsmHeader.Status::Released)
                  then begin
                    AcceptActionMsg := false;
                    Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",STRSUBSTNO(Text009,
                        DummyInventoryProfileTrackBuffer."Warning Level",AsmHeader.FIELDCAPTION(Status),"Ref. Order Type",
                        "Ref. Order No.",AsmHeader.Status));
                  end;
                "Ref. Order Type"::Transfer:
                  if (TransHeader.GET("Ref. Order No.") and
                      (TransHeader.Status = TransHeader.Status::Released))
                  then begin
                    AcceptActionMsg := false;
                    Transparency.LogWarning(0,ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",STRSUBSTNO(Text009,
                        DummyInventoryProfileTrackBuffer."Warning Level",TransHeader.FIELDCAPTION(Status),"Ref. Order Type",
                        "Ref. Order No.",TransHeader.Status));
                  end;
              end;

            if AcceptActionMsg then
              AcceptActionMsg := Transparency.ReqLineWarningLevel(ReqLine) = 0;

            if not AcceptActionMsg then begin
              "Accept Action Message" := false;
              MODIFY;
            end;
          until NEXT = 0;
      end;
    END;

    [External]
    PROCEDURE GetRouting@21(VAR ReqLine@1000 : Record "Requisition Line");
    VAR
      PlanRoutingLine@1002 : Record "Planning Routing Line";
      ProdOrderRoutingLine@1003 : Record "Prod. Order Routing Line";
      ProdOrderLine@1006 : Record "Prod. Order Line";
      VersionMgt@1004 : Codeunit VersionManagement;
    BEGIN
      with ReqLine do begin
        if Quantity <= 0 then
          exit;

        if ("Action Message" = "Action Message"::New) or
           ("Ref. Order Type" = "Ref. Order Type"::Purchase)
        then begin
          if "Routing No." <> '' then
            VALIDATE("Routing Version Code",
              VersionMgt.GetRtngVersion("Routing No.","Due Date",true));
          CLEAR(PlngLnMgt);
          if PlanningResilicency then
            PlngLnMgt.SetResiliencyOn("Worksheet Template Name","Journal Batch Name","No.");
        end else
          if "Ref. Order Type" = "Ref. Order Type"::"Prod. Order" then begin
            ProdOrderLine.GET("Ref. Order Status","Ref. Order No.","Ref. Line No.");
            ProdOrderRoutingLine.SETRANGE(Status,ProdOrderLine.Status);
            ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
            ProdOrderRoutingLine.SETRANGE("Routing Reference No.",ProdOrderLine."Routing Reference No.");
            ProdOrderRoutingLine.SETRANGE("Routing No.",ProdOrderLine."Routing No.");
            DisableRelations;
            if ProdOrderRoutingLine.FIND('-') then
              repeat
                PlanRoutingLine.INIT;
                PlanRoutingLine."Worksheet Template Name" := "Worksheet Template Name";
                PlanRoutingLine."Worksheet Batch Name" := "Journal Batch Name";
                PlanRoutingLine."Worksheet Line No." := "Line No.";
                PlanRoutingLine.TransferFromProdOrderRouting(ProdOrderRoutingLine);
                PlanRoutingLine.INSERT;
              until ProdOrderRoutingLine.NEXT = 0;
          end;
      end;
    END;

    [External]
    PROCEDURE GetComponents@32(VAR ReqLine@1000 : Record "Requisition Line");
    VAR
      PlanComponent@1003 : Record "Planning Component";
      ProdOrderComp@1004 : Record "Prod. Order Component";
      AsmLine@1006 : Record "Assembly Line";
      VersionMgt@1005 : Codeunit VersionManagement;
    BEGIN
      with ReqLine do begin
        BlockDynamicTracking(true);
        CLEAR(PlngLnMgt);
        if PlanningResilicency then
          PlngLnMgt.SetResiliencyOn("Worksheet Template Name","Journal Batch Name","No.");
        PlngLnMgt.BlockDynamicTracking(true);
        if "Action Message" = "Action Message"::New then begin
          if "Production BOM No." <> '' then
            VALIDATE("Production BOM Version Code",
              VersionMgt.GetBOMVersion("Production BOM No.","Due Date",true));
        end else
          case "Ref. Order Type" of
            "Ref. Order Type"::"Prod. Order":
              begin
                ProdOrderComp.SETRANGE(Status,"Ref. Order Status");
                ProdOrderComp.SETRANGE("Prod. Order No.","Ref. Order No.");
                ProdOrderComp.SETRANGE("Prod. Order Line No.","Ref. Line No.");
                if ProdOrderComp.FIND('-') then
                  repeat
                    PlanComponent.INIT;
                    PlanComponent."Worksheet Template Name" := "Worksheet Template Name";
                    PlanComponent."Worksheet Batch Name" := "Journal Batch Name";
                    PlanComponent."Worksheet Line No." := "Line No.";
                    PlanComponent."Planning Line Origin" := "Planning Line Origin";
                    PlanComponent.TransferFromComponent(ProdOrderComp);
                    PlanComponent.INSERT;
                    TempPlanningCompList := PlanComponent;
                    if not TempPlanningCompList.INSERT then
                      TempPlanningCompList.MODIFY;
                  until ProdOrderComp.NEXT = 0;
              end;
            "Ref. Order Type"::Assembly:
              begin
                AsmLine.SETRANGE("Document Type",AsmLine."Document Type"::Order);
                AsmLine.SETRANGE("Document No.","Ref. Order No.");
                AsmLine.SETRANGE(Type,AsmLine.Type::Item);
                if AsmLine.FIND('-') then
                  repeat
                    PlanComponent.INIT;
                    PlanComponent."Worksheet Template Name" := "Worksheet Template Name";
                    PlanComponent."Worksheet Batch Name" := "Journal Batch Name";
                    PlanComponent."Worksheet Line No." := "Line No.";
                    PlanComponent."Planning Line Origin" := "Planning Line Origin";
                    PlanComponent.TransferFromAsmLine(AsmLine);
                    PlanComponent.INSERT;
                    TempPlanningCompList := PlanComponent;
                    if not TempPlanningCompList.INSERT then
                      TempPlanningCompList.MODIFY;
                  until AsmLine.NEXT = 0;
              end;
          end;
      end;
    END;

    [Internal]
    PROCEDURE Recalculate@117(VAR ReqLine@1000 : Record "Requisition Line";Direction@1001 : 'Forward,Backward');
    VAR
      RefreshRouting@1003 : Boolean;
    BEGIN
      with ReqLine do begin
        RefreshRouting := ("Action Message" = "Action Message"::New) or ("Ref. Order Type" = "Ref. Order Type"::Purchase);

        PlngLnMgt.Calculate(ReqLine,Direction,RefreshRouting,"Action Message" = "Action Message"::New,-1);
        if "Action Message" = "Action Message"::New then
          PlngLnMgt.GetPlanningCompList(TempPlanningCompList);
      end;
    END;

    [External]
    PROCEDURE GetPlanningCompList@34(VAR PlanningCompList@1000 : TEMPORARY Record "Planning Component");
    BEGIN
      if TempPlanningCompList.FIND('-') then
        repeat
          PlanningCompList := TempPlanningCompList;
          if not PlanningCompList.INSERT then
            PlanningCompList.MODIFY;
          TempPlanningCompList.DELETE;
        until TempPlanningCompList.NEXT = 0;
    END;

    [External]
    PROCEDURE SetParm@59(Forecast@1000 : Code[10];ExclBefore@1001 : Date;WorksheetType@1002 : 'Requisition,Planning');
    BEGIN
      CurrForecast := Forecast;
      ExcludeForecastBefore := ExclBefore;
      UseParm := true;
      CurrWorksheetType := WorksheetType;
    END;

    [External]
    PROCEDURE SetResiliencyOn@11();
    BEGIN
      PlanningResilicency := true;
    END;

    [External]
    PROCEDURE GetResiliencyError@4(VAR PlanningErrorLog@1000 : Record "Planning Error Log") : Boolean;
    BEGIN
      if ReqLine.GetResiliencyError(PlanningErrorLog) then
        exit(true);
      exit(PlngLnMgt.GetResiliencyError(PlanningErrorLog));
    END;

    LOCAL PROCEDURE CloseTracking@92(ReservEntry@1000 : Record "Reservation Entry";VAR SupplyInventoryProfile@1001 : Record "Inventory Profile";ToDate@1002 : Date) : Boolean;
    VAR
      xSupplyInventoryProfile@1003 : Record "Inventory Profile";
      ReservationEngineMgt@1004 : Codeunit "Reservation Engine Mgt.";
      Closed@1005 : Boolean;
    BEGIN
      with ReservEntry do begin
        if "Reservation Status" <> "Reservation Status"::Tracking then
          exit(false);

        xSupplyInventoryProfile.COPY(SupplyInventoryProfile);
        Closed := false;

        if ("Expected Receipt Date" <= ToDate) and
           ("Shipment Date" > ToDate)
        then begin
          // tracking exists with demand in future
          SupplyInventoryProfile.SETCURRENTKEY(
            "Source Type","Source Order Status","Source ID","Source Batch Name","Source Ref. No.","Source Prod. Order Line",IsSupply,
            "Due Date");
          SupplyInventoryProfile.SETRANGE("Source Type","Source Type");
          SupplyInventoryProfile.SETRANGE("Source Order Status","Source Subtype");
          SupplyInventoryProfile.SETRANGE("Source ID","Source ID");
          SupplyInventoryProfile.SETRANGE("Source Batch Name","Source Batch Name");
          SupplyInventoryProfile.SETRANGE("Source Ref. No.","Source Ref. No.");
          SupplyInventoryProfile.SETRANGE("Source Prod. Order Line","Source Prod. Order Line");
          SupplyInventoryProfile.SETRANGE("Due Date",0D,ToDate);

          if not SupplyInventoryProfile.ISEMPTY then begin
            // demand is either deleted as well or will get Surplus status
            ReservationEngineMgt.CloseReservEntry(ReservEntry,false,false);
            Closed := true;
          end;
        end;
      end;

      SupplyInventoryProfile.COPY(xSupplyInventoryProfile);
      exit(Closed);
    END;

    LOCAL PROCEDURE FrozenZoneTrack@52(FromInventoryProfile@1000 : Record "Inventory Profile";ToInventoryProfile@1001 : Record "Inventory Profile");
    BEGIN
      if FromInventoryProfile.TrackingExists then
        Track(FromInventoryProfile,ToInventoryProfile,true,false,FromInventoryProfile.Binding::" ");

      if ToInventoryProfile.TrackingExists then begin
        ToInventoryProfile."Untracked Quantity" := FromInventoryProfile."Untracked Quantity";
        ToInventoryProfile."Quantity (Base)" := FromInventoryProfile."Untracked Quantity";
        ToInventoryProfile."Original Quantity" := 0;
        Track(ToInventoryProfile,FromInventoryProfile,true,false,ToInventoryProfile.Binding::" ");
      end;
    END;

    LOCAL PROCEDURE ExceedROPinException@93(RespectPlanningParm@1000 : Boolean) : Boolean;
    BEGIN
      if not RespectPlanningParm then
        exit(false);

      exit(TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::"Fixed Reorder Qty.");
    END;

    LOCAL PROCEDURE CreateSupplyForInitialSafetyStockWarning@97(VAR SupplyInventoryProfile@1004 : Record "Inventory Profile";ProjectedInventory@1000 : Decimal;VAR LastProjectedInventory@1006 : Decimal;VAR LastAvailableInventory@1007 : Decimal;PlanningStartDate@1005 : Date;RespectPlanningParm@1002 : Boolean;IsReorderPointPlanning@1008 : Boolean);
    VAR
      OrderQty@1001 : Decimal;
      ReorderQty@1003 : Decimal;
    BEGIN
      OrderQty := TempSKU."Safety Stock Quantity" - ProjectedInventory;
      if ExceedROPinException(RespectPlanningParm) then
        OrderQty := TempSKU."Reorder Point" - ProjectedInventory;

      ReorderQty := OrderQty;

      repeat
        InitSupply(SupplyInventoryProfile,ReorderQty,PlanningStartDate);
        if RespectPlanningParm then begin
          if IsReorderPointPlanning then
            ReorderQty := CalcOrderQty(ReorderQty,ProjectedInventory,SupplyInventoryProfile."Line No.");

          ReorderQty += AdjustReorderQty(ReorderQty,TempSKU,SupplyInventoryProfile."Line No.",SupplyInventoryProfile."Min. Quantity");
          SupplyInventoryProfile."Max. Quantity" := TempSKU."Maximum Order Quantity";
          UpdateQty(SupplyInventoryProfile,ReorderQty);
          SupplyInventoryProfile."Min. Quantity" := SupplyInventoryProfile."Quantity (Base)";
        end;
        SupplyInventoryProfile."Fixed Date" := SupplyInventoryProfile."Due Date";
        SupplyInventoryProfile."Order Relation" := SupplyInventoryProfile."Order Relation"::"Safety Stock";
        SupplyInventoryProfile."Is Exception Order" := true;
        SupplyInventoryProfile.INSERT;

        DummyInventoryProfileTrackBuffer."Warning Level" := DummyInventoryProfileTrackBuffer."Warning Level"::Exception;
        Transparency.LogWarning(SupplyInventoryProfile."Line No.",ReqLine,DummyInventoryProfileTrackBuffer."Warning Level",
          STRSUBSTNO(Text007,DummyInventoryProfileTrackBuffer."Warning Level",TempSKU.FIELDCAPTION("Safety Stock Quantity"),
            TempSKU."Safety Stock Quantity",PlanningStartDate));

        LastProjectedInventory += SupplyInventoryProfile."Remaining Quantity (Base)";
        ProjectedInventory += SupplyInventoryProfile."Remaining Quantity (Base)";
        LastAvailableInventory += SupplyInventoryProfile."Untracked Quantity";

        OrderQty -= ReorderQty;
        if ExceedROPinException(RespectPlanningParm) and (OrderQty = 0) then
          OrderQty := ExceedROPqty;
        ReorderQty := OrderQty;
      until OrderQty <= 0; // Create supplies until Safety Stock is met or Reorder point is exceeded
    END;

    LOCAL PROCEDURE IsTrkgForSpecialOrderOrDropShpt@94(ReservEntry@1000 : Record "Reservation Entry") : Boolean;
    VAR
      SalesLine@1001 : Record "Sales Line";
      PurchLine@1002 : Record "Purchase Line";
    BEGIN
      case ReservEntry."Source Type" of
        DATABASE::"Sales Line":
          if SalesLine.GET(ReservEntry."Source Subtype",ReservEntry."Source ID",ReservEntry."Source Ref. No.") then
            exit(SalesLine."Special Order" or SalesLine."Drop Shipment");
        DATABASE::"Purchase Line":
          if PurchLine.GET(ReservEntry."Source Subtype",ReservEntry."Source ID",ReservEntry."Source Ref. No.") then
            exit(PurchLine."Special Order" or PurchLine."Drop Shipment");
      end;

      exit(false);
    END;

    LOCAL PROCEDURE CheckSupplyRemQtyAndUntrackQty@96(VAR InventoryProfile@1001 : Record "Inventory Profile");
    VAR
      RemQty@1002 : Decimal;
    BEGIN
      with InventoryProfile do begin
        if "Source Type" = DATABASE::"Item Ledger Entry" then
          exit;

        if "Remaining Quantity (Base)" >= TempSKU."Maximum Order Quantity" then begin
          RemQty := "Remaining Quantity (Base)";
          "Remaining Quantity (Base)" := TempSKU."Maximum Order Quantity";
          if not ("Action Message" in ["Action Message"::New,"Action Message"::Reschedule]) then
            "Original Quantity" := "Quantity (Base)";
        end;
        if "Untracked Quantity" >= TempSKU."Maximum Order Quantity" then
          "Untracked Quantity" := "Untracked Quantity" - RemQty + "Remaining Quantity (Base)";
      end;
    END;

    LOCAL PROCEDURE CheckItemInventoryExists@98(VAR InventoryProfile@1000 : Record "Inventory Profile") ItemInventoryExists : Boolean;
    BEGIN
      with InventoryProfile do begin
        SETRANGE("Source Type",DATABASE::"Item Ledger Entry");
        SETFILTER(Binding,'<>%1',Binding::"Order-to-Order");
        ItemInventoryExists := not ISEMPTY;
        SETRANGE("Source Type");
        SETRANGE(Binding);
      end;
    END;

    LOCAL PROCEDURE ApplyUntrackedQuantityToItemInventory@101(SupplyExists@1001 : Boolean;ItemInventoryExists@1000 : Boolean) : Boolean;
    BEGIN
      if SupplyExists then
        exit(false);
      exit(ItemInventoryExists);
    END;

    LOCAL PROCEDURE UpdateAppliedItemEntry@102(VAR ReservEntry@1000 : Record "Reservation Entry");
    BEGIN
      with TempItemTrkgEntry do begin
        SetSourceFilter(
          ReservEntry."Source Type",ReservEntry."Source Subtype",ReservEntry."Source ID",ReservEntry."Source Ref. No.",true);
        if ReservEntry."Lot No." <> '' then
          SETRANGE("Lot No.",ReservEntry."Lot No.");
        if ReservEntry."Serial No." <> '' then
          SETRANGE("Serial No.",ReservEntry."Serial No.");
        if FINDFIRST then begin
          ReservEntry."Appl.-from Item Entry" := "Appl.-from Item Entry";
          ReservEntry."Appl.-to Item Entry" := "Appl.-to Item Entry";
        end;
      end;
    END;

    LOCAL PROCEDURE CheckSupplyAndTrack@100(InventoryProfileFromDemand@1001 : Record "Inventory Profile";InventoryProfileFromSupply@1000 : Record "Inventory Profile");
    BEGIN
      if InventoryProfileFromSupply."Source Type" = DATABASE::"Item Ledger Entry" then
        Track(InventoryProfileFromDemand,InventoryProfileFromSupply,false,false,InventoryProfileFromSupply.Binding)
      else
        Track(InventoryProfileFromDemand,InventoryProfileFromSupply,false,false,InventoryProfileFromDemand.Binding);
    END;

    LOCAL PROCEDURE CheckPlanSKU@103(SKU@1003 : Record "Stockkeeping Unit";DemandExists@1000 : Boolean;SupplyExists@1001 : Boolean;IsReorderPointPlanning@1002 : Boolean) : Boolean;
    BEGIN
      if (CurrWorksheetType = CurrWorksheetType::Requisition) and
         (SKU."Replenishment System" in [SKU."Replenishment System"::"Prod. Order",SKU."Replenishment System"::Assembly])
      then
        exit(false);

      if DemandExists or SupplyExists or IsReorderPointPlanning then
        exit(true);

      exit(false);
    END;

    LOCAL PROCEDURE PrepareDemand@107(VAR InventoryProfile@1000 : Record "Inventory Profile";IsReorderPointPlanning@1002 : Boolean;ToDate@1001 : Date);
    BEGIN
      // Transfer attributes
      if (TempSKU."Reordering Policy" = TempSKU."Reordering Policy"::Order) or
         (TempSKU."Manufacturing Policy" = TempSKU."Manufacturing Policy"::"Make-to-Order")
      then
        PrepareOrderToOrderLink(InventoryProfile);
      UpdatePriorities(InventoryProfile,IsReorderPointPlanning,ToDate);
    END;

    LOCAL PROCEDURE DemandMatchedSupply@106(VAR FromInventoryProfile@1000 : Record "Inventory Profile";VAR ToInventoryProfile@1001 : Record "Inventory Profile";SKU@1006 : Record "Stockkeeping Unit") : Boolean;
    VAR
      xFromInventoryProfile@1002 : Record "Inventory Profile";
      xToInventoryProfile@1003 : Record "Inventory Profile";
      UntrackedQty@1005 : Decimal;
    BEGIN
      xToInventoryProfile.COPYFILTERS(FromInventoryProfile);
      xFromInventoryProfile.COPYFILTERS(ToInventoryProfile);
      with FromInventoryProfile do begin
        SETRANGE("Attribute Priority",1,7);
        if FINDSET then begin
          repeat
            ToInventoryProfile.SETRANGE(Binding,Binding);
            ToInventoryProfile.SETRANGE("Primary Order Status","Primary Order Status");
            ToInventoryProfile.SETRANGE("Primary Order No.","Primary Order No.");
            ToInventoryProfile.SETRANGE("Primary Order Line","Primary Order Line");
            ToInventoryProfile.SetTrackingFilter(FromInventoryProfile);
            if ToInventoryProfile.FINDSET then
              repeat
                UntrackedQty += ToInventoryProfile."Untracked Quantity";
              until ToInventoryProfile.NEXT = 0;
            UntrackedQty -= "Untracked Quantity";
          until NEXT = 0;
          if (UntrackedQty = 0) and (SKU."Reordering Policy" = SKU."Reordering Policy"::"Lot-for-Lot") then begin
            SETRANGE("Attribute Priority",0);
            CALCSUMS("Untracked Quantity");
            if "Untracked Quantity" = 0 then begin
              COPYFILTERS(xToInventoryProfile);
              ToInventoryProfile.COPYFILTERS(xFromInventoryProfile);
              exit(true);
            end;
          end;
        end;
        COPYFILTERS(xToInventoryProfile);
        ToInventoryProfile.COPYFILTERS(xFromInventoryProfile);
        exit(false);
      end;
    END;

    LOCAL PROCEDURE ReservedForProdComponent@108(ReservationEntry@1000 : Record "Reservation Entry") : Boolean;
    BEGIN
      if not ReservationEntry.Positive then
        exit(ReservationEntry."Source Type" = DATABASE::"Prod. Order Component");
      if ReservationEntry.GET(ReservationEntry."Entry No.",false) then
        exit(ReservationEntry."Source Type" = DATABASE::"Prod. Order Component");
    END;

    LOCAL PROCEDURE ShouldInsertTrackingEntry@110(FromTrkgReservEntry@1001 : Record "Reservation Entry") : Boolean;
    VAR
      InsertedReservEntry@1002 : Record "Reservation Entry";
    BEGIN
      with InsertedReservEntry do begin
        SETRANGE("Source ID",FromTrkgReservEntry."Source ID");
        SETRANGE("Source Ref. No.",FromTrkgReservEntry."Source Ref. No.");
        SETRANGE("Source Type",FromTrkgReservEntry."Source Type");
        SETRANGE("Source Subtype",FromTrkgReservEntry."Source Subtype");
        SETRANGE("Source Batch Name",FromTrkgReservEntry."Source Batch Name");
        SETRANGE("Source Prod. Order Line",FromTrkgReservEntry."Source Prod. Order Line");
        SETRANGE("Reservation Status",FromTrkgReservEntry."Reservation Status");
        exit(ISEMPTY);
      end;
    END;

    LOCAL PROCEDURE CloseInventoryProfile@114(VAR ClosedInvtProfile@1000 : Record "Inventory Profile";VAR OpenInvtProfile@1001 : Record "Inventory Profile";ActionMessage@1003 : '" ",New,"Change Qty.",Reschedule,"Resched.& Chg. Qty.",Cancel');
    VAR
      PlanningStageToMaintain@1002 : '" ","Line Created","Routing Created",Exploded,Obsolete';
    BEGIN
      OpenInvtProfile."Untracked Quantity" -= ClosedInvtProfile."Untracked Quantity";
      OpenInvtProfile.MODIFY;

      if OpenInvtProfile.Binding = OpenInvtProfile.Binding::"Order-to-Order" then
        PlanningStageToMaintain := PlanningStageToMaintain::Exploded
      else
        PlanningStageToMaintain := PlanningStageToMaintain::"Line Created";

      if ActionMessage <> ActionMessage::" " then
        if OpenInvtProfile.IsSupply then
          MaintainPlanningLine(OpenInvtProfile,PlanningStageToMaintain,ScheduleDirection::Backward)
        else
          MaintainPlanningLine(ClosedInvtProfile,PlanningStageToMaintain,ScheduleDirection::Backward);

      Track(ClosedInvtProfile,OpenInvtProfile,false,false,OpenInvtProfile.Binding);

      if ClosedInvtProfile.Binding = ClosedInvtProfile.Binding::"Order-to-Order" then
        ClosedInvtProfile."Remaining Quantity (Base)" -= ClosedInvtProfile."Untracked Quantity";

      ClosedInvtProfile."Untracked Quantity" := 0;
      if ClosedInvtProfile."Remaining Quantity (Base)" = 0 then
        ClosedInvtProfile.DELETE
      else
        ClosedInvtProfile.MODIFY;
    END;

    LOCAL PROCEDURE CloseDemand@123(VAR DemandInvtProfile@1001 : Record "Inventory Profile";VAR SupplyInvtProfile@1000 : Record "Inventory Profile");
    BEGIN
      CloseInventoryProfile(DemandInvtProfile,SupplyInvtProfile,SupplyInvtProfile."Action Message");
    END;

    LOCAL PROCEDURE CloseSupply@124(VAR DemandInvtProfile@1001 : Record "Inventory Profile";VAR SupplyInvtProfile@1000 : Record "Inventory Profile") : Boolean;
    BEGIN
      CloseInventoryProfile(SupplyInvtProfile,DemandInvtProfile,SupplyInvtProfile."Action Message");
      exit(SupplyInvtProfile.NEXT <> 0);
    END;

    LOCAL PROCEDURE QtyPickedForSourceDocument@113(TrkgReservEntry@1001 : Record "Reservation Entry") : Decimal;
    VAR
      WhseEntry@1000 : Record "Warehouse Entry";
    BEGIN
      WhseEntry.SETRANGE("Item No.",TrkgReservEntry."Item No.");
      WhseEntry.SetSourceFilter(
        TrkgReservEntry."Source Type",TrkgReservEntry."Source Subtype",TrkgReservEntry."Source ID",
        TrkgReservEntry."Source Ref. No.",false);
      WhseEntry.SETRANGE("Lot No.",TrkgReservEntry."Lot No.");
      WhseEntry.SETRANGE("Serial No.",TrkgReservEntry."Serial No.");
      WhseEntry.SETFILTER("Qty. (Base)",'<0');
      WhseEntry.CALCSUMS("Qty. (Base)");
      exit(WhseEntry."Qty. (Base)");
    END;

    LOCAL PROCEDURE CreateTempSKUForComponentsLocation@112(VAR Item@1001 : Record Item);
    VAR
      SKU@1000 : Record "Stockkeeping Unit";
    BEGIN
      if ManufacturingSetup."Components at Location" = '' then
        exit;

      SKU.SETRANGE("Item No.",Item."No.");
      SKU.SETRANGE("Location Code",ManufacturingSetup."Components at Location");
      Item.COPYFILTER("Variant Filter",SKU."Variant Code");
      if SKU.ISEMPTY then
        CreateTempSKUForLocation(Item."No.",ManufacturingSetup."Components at Location");
    END;

    LOCAL PROCEDURE ForecastInitDemand@127(VAR InventoryProfile@1000 : Record "Inventory Profile";ProductionForecastEntry@1003 : Record "Production Forecast Entry";ItemNo@1004 : Code[20];LocationCode@1001 : Code[10];TotalForecastQty@1002 : Decimal);
    BEGIN
      with InventoryProfile do begin
        INIT;
        "Line No." := NextLineNo;
        "Source Type" := DATABASE::"Production Forecast Entry";
        "Planning Flexibility" := "Planning Flexibility"::None;
        "Qty. per Unit of Measure" := 1;
        "MPS Order" := true;
        "Source ID" := ProductionForecastEntry."Production Forecast Name";
        "Item No." := ItemNo;
        if ManufacturingSetup."Use Forecast on Locations" then
          "Location Code" := ProductionForecastEntry."Location Code"
        else
          "Location Code" := LocationCode;
        "Remaining Quantity (Base)" := TotalForecastQty;
        "Untracked Quantity" := TotalForecastQty;
      end;
    END;

    LOCAL PROCEDURE SetPurchase@118(VAR PurchaseLine@1003 : Record "Purchase Line";VAR InventoryProfile@1000 : Record "Inventory Profile");
    BEGIN
      with ReqLine do begin
        "Ref. Order Type" := "Ref. Order Type"::Purchase;
        "Ref. Order No." := InventoryProfile."Source ID";
        "Ref. Line No." := InventoryProfile."Source Ref. No.";
        PurchaseLine.GET(PurchaseLine."Document Type"::Order,"Ref. Order No.","Ref. Line No.");
        TransferFromPurchaseLine(PurchaseLine);
      end;
    END;

    LOCAL PROCEDURE SetProdOrder@119(VAR ProdOrderLine@1002 : Record "Prod. Order Line";VAR InventoryProfile@1000 : Record "Inventory Profile");
    BEGIN
      with ReqLine do begin
        "Ref. Order Type" := "Ref. Order Type"::"Prod. Order";
        "Ref. Order Status" := InventoryProfile."Source Order Status";
        "Ref. Order No." := InventoryProfile."Source ID";
        "Ref. Line No." := InventoryProfile."Source Prod. Order Line";
        ProdOrderLine.GET("Ref. Order Status","Ref. Order No.","Ref. Line No.");
        TransferFromProdOrderLine(ProdOrderLine);
      end;
    END;

    LOCAL PROCEDURE SetAssembly@122(VAR AsmHeader@1001 : Record "Assembly Header";VAR InventoryProfile@1000 : Record "Inventory Profile");
    BEGIN
      with ReqLine do begin
        "Ref. Order Type" := "Ref. Order Type"::Assembly;
        "Ref. Order No." := InventoryProfile."Source ID";
        "Ref. Line No." := 0;
        AsmHeader.GET(AsmHeader."Document Type"::Order,"Ref. Order No.");
        TransferFromAsmHeader(AsmHeader);
      end;
    END;

    LOCAL PROCEDURE SetTransfer@120(VAR TransLine@1000 : Record "Transfer Line";VAR InventoryProfile@1001 : Record "Inventory Profile");
    BEGIN
      with ReqLine do begin
        "Ref. Order Type" := "Ref. Order Type"::Transfer;
        "Ref. Order Status" := 0; // A Transfer Order has no status
        "Ref. Order No." := InventoryProfile."Source ID";
        "Ref. Line No." := InventoryProfile."Source Ref. No.";
        TransLine.GET("Ref. Order No.","Ref. Line No.");
        TransferFromTransLine(TransLine);
      end;
    END;

    LOCAL PROCEDURE SKURequiresLotAccumulation@131(VAR StockkeepingUnit@1000 : Record "Stockkeeping Unit") : Boolean;
    VAR
      BlankPeriod@1001 : DateFormula;
    BEGIN
      with StockkeepingUnit do
        if "Reordering Policy" = "Reordering Policy"::"Lot-for-Lot" then begin
          EVALUATE(BlankPeriod,'');
          exit("Lot Accumulation Period" <> BlankPeriod);
        end;
      exit(false);
    END;

    BEGIN
    END.
  }
}

