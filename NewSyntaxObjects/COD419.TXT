OBJECT Codeunit 419 File Management
{
  OBJECT-PROPERTIES
  {
    Date=20171006D;
    Time=120000T;
    Version List=NAVW111.0;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Text001@1004 : TextConst 'ENU=Default';
      Text002@1001 : TextConst 'ENU=You must enter a file path.';
      Text003@1005 : TextConst 'ENU=You must enter a file name.';
      FileDoesNotExistErr@1007 : TextConst '@@@=%1 File Path;ENU=The file %1 does not exist.';
      Text006@1003 : TextConst 'ENU=Export';
      Text007@1002 : TextConst 'ENU=Import';
      PathHelper@1011 : DotNet "'mscorlib'.System.IO.Path";
      DirectoryHelper@1013 : DotNet "'mscorlib'.System.IO.Directory" RUNONCLIENT;
      ClientFileHelper@1012 : DotNet "'mscorlib'.System.IO.File" RUNONCLIENT;
      ServerFileHelper@1015 : DotNet "'mscorlib'.System.IO.File";
      ServerDirectoryHelper@1030 : DotNet "'mscorlib'.System.IO.Directory";
      Text010@1008 : TextConst 'ENU=The file %1 has not been uploaded.';
      Text011@1009 : TextConst 'ENU=You must specify a source file name.';
      Text012@1010 : TextConst 'ENU=You must specify a target file name.';
      Text013@1014 : TextConst 'ENU=The file name %1 already exists.';
      DirectoryDoesNotExistErr@1032 : TextConst '@@@="%1=Directory user is trying to upload does not exist";ENU=Directory %1 does not exist.';
      CreatePathQst@1028 : TextConst 'ENU=The path %1 does not exist. Do you want to add it now?';
      AllFilesFilterTxt@1000 : TextConst '@@@={Locked};ENU=*.*';
      AllFilesDescriptionTxt@1024 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=All Files (*.*)|*.*';
      XMLFileType@1006 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XML Files (*.xml)|*.xml';
      WordFileType@1016 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Word Files (*.doc)|*.doc';
      Word2007FileType@1017 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="Word Files (*.docx;*.doc)|*.docx;*.doc"';
      ExcelFileType@1018 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Excel Files (*.xls)|*.xls';
      Excel2007FileType@1019 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls"';
      XSDFileType@1020 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XSD Files (*.xsd)|*.xsd';
      HTMFileType@1021 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=HTM Files (*.htm)|*.htm';
      XSLTFileType@1022 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XSLT Files (*.xslt)|*.xslt';
      TXTFileType@1023 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Text Files (*.txt)|*.txt';
      RDLFileTypeTok@1031 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="SQL Report Builder (*.rdl;*.rdlc)|*.rdl;*.rdlc"';
      UnsupportedFileExtErr@1025 : TextConst 'ENU=Unsupported file extension (.%1). The supported file extensions are (%2).';
      SingleFilterErr@1026 : TextConst 'ENU=Specify a file filter and an extension filter when using this function.';
      InvalidWindowsChrStringTxt@1027 : TextConst '@@@={Locked};ENU="""#%&*:<>?\/{|}~"';
      ZipArchive@1029 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchive";
      ZipArchiveMode@1033 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchiveMode";

    [Internal]
    PROCEDURE BLOBImport@3(VAR BLOBRef@1000 : TEMPORARY Record TempBlob;Name@1002 : Text) : Text;
    BEGIN
      exit(BLOBImportWithFilter(BLOBRef,Text007,Name,AllFilesDescriptionTxt,AllFilesFilterTxt));
    END;

    [Internal]
    PROCEDURE BLOBImportWithFilter@27(VAR TempBlob@1000 : Record TempBlob;DialogCaption@1005 : Text;Name@1002 : Text;FileFilter@1003 : Text;ExtFilter@1008 : Text) : Text;
    VAR
      NVInStream@1001 : InStream;
      NVOutStream@1004 : OutStream;
      UploadResult@1006 : Boolean;
      ErrorMessage@1007 : Text;
    BEGIN
      // ExtFilter examples: 'csv,txt' if you only accept *.csv and *.txt or '*.*' if you accept any extensions
      CLEARLASTERROR;

      if (FileFilter = '') xor (ExtFilter = '') then
        ERROR(SingleFilterErr);

      // There is no way to check if NVInStream is null before using it after calling the
      // UPLOADINTOSTREAM therefore if result is false this is the only way we can throw the error.
      UploadResult := UPLOADINTOSTREAM(DialogCaption,'',FileFilter,Name,NVInStream);
      if UploadResult then
        ValidateFileExtension(Name,ExtFilter);
      if UploadResult then begin
        TempBlob.Blob.CREATEOUTSTREAM(NVOutStream);
        COPYSTREAM(NVOutStream,NVInStream);
        exit(Name);
      end;
      ErrorMessage := GETLASTERRORTEXT;
      if ErrorMessage <> '' then
        ERROR(ErrorMessage);

      exit('');
    END;

    LOCAL PROCEDURE BLOBExportLocal@68(VAR InStream@1000 : InStream;Name@1001 : Text;IsCommonDialog@1002 : Boolean) : Text;
    VAR
      ToFile@1004 : Text;
      Path@1006 : Text;
      IsDownloaded@1007 : Boolean;
    BEGIN
      if IsCommonDialog then begin
        if STRPOS(Name,'*') = 0 then
          ToFile := Name
        else
          ToFile := DELCHR(INSSTR(Name,Text001,1),'=','*');
        Path := PathHelper.GetDirectoryName(ToFile);
        ToFile := GetFileName(ToFile);
      end else begin
        ToFile := ClientTempFileName(GetExtension(Name));
        Path := Magicpath;
      end;
      IsDownloaded := DOWNLOADFROMSTREAM(InStream,Text006,Path,GetToFilterText('',Name),ToFile);
      if IsDownloaded then
        exit(ToFile);
      exit('');
    END;

    [Internal]
    PROCEDURE BLOBExportWithEncoding@67(VAR TempBlob@1002 : TEMPORARY Record TempBlob;Name@1001 : Text;CommonDialog@1000 : Boolean;Encoding@1004 : TextEncoding) : Text;
    VAR
      NVInStream@1003 : InStream;
    BEGIN
      TempBlob.Blob.CREATEINSTREAM(NVInStream,Encoding);
      exit(BLOBExportLocal(NVInStream,Name,CommonDialog));
    END;

    [Internal]
    PROCEDURE BLOBExport@4(VAR TempBlob@1002 : TEMPORARY Record TempBlob;Name@1001 : Text;CommonDialog@1000 : Boolean) : Text;
    VAR
      NVInStream@1003 : InStream;
    BEGIN
      TempBlob.Blob.CREATEINSTREAM(NVInStream);
      exit(BLOBExportLocal(NVInStream,Name,CommonDialog));
    END;

    [Internal]
    PROCEDURE ServerTempFileName@5(FileExtension@1002 : Text) FileName : Text;
    VAR
      TempFile@1000 : File;
    BEGIN
      TempFile.CREATETEMPFILE;
      FileName := CreateFileNameWithExtension(TempFile.NAME,FileExtension);
      TempFile.CLOSE;
    END;

    [Internal]
    PROCEDURE ClientTempFileName@6(FileExtension@1002 : Text) ClientFileName : Text;
    VAR
      TempFile@1004 : File;
      ClientTempPath@1000 : Text;
    BEGIN
      // Returns the pseudo uniquely generated name of a non existing file in the client temp directory
      TempFile.CREATETEMPFILE;
      ClientFileName := CreateFileNameWithExtension(TempFile.NAME,FileExtension);
      TempFile.CLOSE;
      TempFile.CREATE(ClientFileName);
      TempFile.CLOSE;
      ClientTempPath := GetDirectoryName(DownloadTempFile(ClientFileName));
      if ERASE(ClientFileName) then;
      ClientFileHelper.Delete(ClientTempPath + '\' + PathHelper.GetFileName(ClientFileName));
      ClientFileName := CreateFileNameWithExtension(ClientTempPath + '\' + FORMAT(CREATEGUID),FileExtension);
    END;

    [Internal]
    PROCEDURE CreateClientTempSubDirectory@54() ClientDirectory : Text;
    VAR
      ServerFile@1000 : File;
      ServerFileName@1001 : Text;
    BEGIN
      // Creates a new subdirectory in the client's TEMP folder
      ServerFile.CREATE(CREATEGUID);
      ServerFileName := ServerFile.NAME;
      ServerFile.CLOSE;
      ClientDirectory := GetDirectoryName(DownloadTempFile(ServerFileName));
      if ERASE(ServerFileName) then;
      DeleteClientFile(CombinePath(ClientDirectory,ServerFileName));
      ClientDirectory := CombinePath(ClientDirectory,CREATEGUID);
      CreateClientDirectory(ClientDirectory);
    END;

    [External]
    PROCEDURE DownloadTempFile@7(ServerFileName@1001 : Text) : Text;
    VAR
      FileName@1102601003 : Text;
      Path@1102601004 : Text;
    BEGIN
      FileName := ServerFileName;
      Path := Magicpath;
      DOWNLOAD(ServerFileName,'',Path,AllFilesDescriptionTxt,FileName);
      exit(FileName);
    END;

    [External]
    PROCEDURE UploadFileSilent@10(ClientFilePath@1001 : Text) : Text;
    BEGIN
      exit(
        UploadFileSilentToServerPath(ClientFilePath,''));
    END;

    [Internal]
    PROCEDURE UploadFileSilentToServerPath@73(ClientFilePath@1001 : Text;ServerFilePath@1005 : Text) : Text;
    VAR
      ClientFileAttributes@1004 : DotNet "'mscorlib'.System.IO.FileAttributes";
      ServerFileName@1006 : Text;
      TempClientFile@1000 : Text;
      FileName@1002 : Text;
      FileExtension@1003 : Text;
    BEGIN
      if not ClientFileHelper.Exists(ClientFilePath) then
        ERROR(FileDoesNotExistErr,ClientFilePath);
      FileName := GetFileName(ClientFilePath);
      FileExtension := GetExtension(FileName);

      TempClientFile := ClientTempFileName(FileExtension);
      ClientFileHelper.Copy(ClientFilePath,TempClientFile,true);

      if ServerFilePath <> '' then
        ServerFileName := ServerFilePath
      else
        ServerFileName := ServerTempFileName(FileExtension);

      if not UPLOAD('',Magicpath,AllFilesDescriptionTxt,GetFileName(TempClientFile),ServerFileName) then
        ERROR(Text010,ClientFilePath);

      ClientFileHelper.SetAttributes(TempClientFile,ClientFileAttributes.Normal);
      ClientFileHelper.Delete(TempClientFile);
      exit(ServerFileName);
    END;

    [Internal]
    PROCEDURE UploadFile@21(WindowTitle@1003 : Text[50];ClientFileName@1001 : Text) ServerFileName : Text;
    VAR
      Filter@1005 : Text;
    BEGIN
      Filter := GetToFilterText('',ClientFileName);

      if PathHelper.GetFileNameWithoutExtension(ClientFileName) = '' then
        ClientFileName := '';

      ServerFileName := UploadFileWithFilter(WindowTitle,ClientFileName,Filter,AllFilesFilterTxt);
    END;

    [Internal]
    PROCEDURE UploadFileWithFilter@25(WindowTitle@1003 : Text[50];ClientFileName@1001 : Text;FileFilter@1000 : Text;ExtFilter@1004 : Text) ServerFileName : Text;
    VAR
      Uploaded@1002 : Boolean;
    BEGIN
      CLEARLASTERROR;

      if (FileFilter = '') xor (ExtFilter = '') then
        ERROR(SingleFilterErr);

      Uploaded := UPLOAD(WindowTitle,'',FileFilter,ClientFileName,ServerFileName);
      if Uploaded then
        ValidateFileExtension(ClientFileName,ExtFilter);
      if Uploaded then
        exit(ServerFileName);

      if GETLASTERRORTEXT <> '' then
        ERROR('%1',GETLASTERRORTEXT);

      exit('');
    END;

    [External]
    PROCEDURE Magicpath@9() : Text;
    BEGIN
      exit('<TEMP>');   // MAGIC PATH makes sure we don't get a prompt
    END;

    [Internal]
    PROCEDURE DownloadHandler@2(FromFile@1000 : Text;DialogTitle@1001 : Text;ToFolder@1002 : Text;ToFilter@1003 : Text;ToFile@1004 : Text) : Boolean;
    VAR
      Downloaded@1005 : Boolean;
    BEGIN
      CLEARLASTERROR;
      Downloaded := DOWNLOAD(FromFile,DialogTitle,ToFolder,ToFilter,ToFile);
      if not Downloaded then
        if GETLASTERRORTEXT <> '' then
          ERROR('%1',GETLASTERRORTEXT);
      exit(Downloaded);
    END;

    [Internal]
    PROCEDURE DownloadToFile@13(ServerFileName@1002 : Text;ClientFileName@1000 : Text);
    VAR
      TempClientFileName@1001 : Text;
    BEGIN
      ValidateFileNames(ServerFileName,ClientFileName);
      TempClientFileName := DownloadTempFile(ServerFileName);
      MoveFile(TempClientFileName,ClientFileName);
    END;

    [Internal]
    PROCEDURE AppendAllTextToClientFile@44(ServerFileName@1001 : Text;ClientFileName@1000 : Text);
    BEGIN
      ValidateFileNames(ServerFileName,ClientFileName);
      ClientFileHelper.AppendAllText(ClientFileName,ServerFileHelper.ReadAllText(ServerFileName));
    END;

    [Internal]
    PROCEDURE MoveAndRenameClientFile@11(OldFilePath@1001 : Text;NewFileName@1004 : Text;NewSubDirectoryName@1002 : Text) NewFilePath : Text;
    VAR
      directory@1003 : Text;
    BEGIN
      if OldFilePath = '' then
        ERROR(Text002);

      if NewFileName = '' then
        ERROR(Text003);

      if not ClientFileHelper.Exists(OldFilePath) then
        ERROR(FileDoesNotExistErr,OldFilePath);

      // Get the directory from the OldFilePath, if directory is empty it will just use the current location.
      directory := GetDirectoryName(OldFilePath);

      // create the sub directory name is name is given
      if NewSubDirectoryName <> '' then begin
        directory := PathHelper.Combine(directory,NewSubDirectoryName);
        DirectoryHelper.CreateDirectory(directory);
      end;

      NewFilePath := PathHelper.Combine(directory,NewFileName);
      MoveFile(OldFilePath,NewFilePath);

      exit(NewFilePath);
    END;

    [Internal]
    PROCEDURE CreateClientFile@81(FilePathName@1000 : Text);
    VAR
      StreamWriter@1001 : DotNet "'mscorlib'.System.IO.StreamWriter" RUNONCLIENT;
    BEGIN
      if not ClientFileHelper.Exists(FilePathName) then begin
        StreamWriter := ClientFileHelper.CreateText(FilePathName);
        StreamWriter.Close;
      end;
    END;

    [Internal]
    PROCEDURE DeleteClientFile@12(FilePath@1001 : Text) : Boolean;
    BEGIN
      if not ClientFileHelper.Exists(FilePath) then
        exit(false);

      ClientFileHelper.Delete(FilePath);
      exit(true);
    END;

    [Internal]
    PROCEDURE CopyClientFile@43(SourceFileName@1000 : Text;DestFileName@1001 : Text;OverWrite@1002 : Boolean);
    BEGIN
      ClientFileHelper.Copy(SourceFileName,DestFileName,OverWrite);
    END;

    [External]
    PROCEDURE ClientFileExists@14(FilePath@1001 : Text) : Boolean;
    BEGIN
      if not CanRunDotNetOnClient then
        exit(false);
      exit(ClientFileHelper.Exists(FilePath));
    END;

    [External]
    PROCEDURE ClientDirectoryExists@42(DirectoryPath@1001 : Text) : Boolean;
    BEGIN
      if not CanRunDotNetOnClient then
        exit(false);
      exit(DirectoryHelper.Exists(DirectoryPath));
    END;

    [Internal]
    PROCEDURE CreateClientDirectory@49(DirectoryPath@1000 : Text);
    BEGIN
      if not ClientDirectoryExists(DirectoryPath) then
        DirectoryHelper.CreateDirectory(DirectoryPath);
    END;

    [Internal]
    PROCEDURE DeleteClientDirectory@82(DirectoryPath@1000 : Text);
    BEGIN
      if ClientDirectoryExists(DirectoryPath) then
        DirectoryHelper.Delete(DirectoryPath,true);
    END;

    [Internal]
    PROCEDURE UploadClientDirectorySilent@57(DirectoryPath@1000 : Text;FileExtensionFilter@1002 : Text;IncludeSubDirectories@1003 : Boolean) ServerDirectoryPath : Text;
    VAR
      SearchOption@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.SearchOption" RUNONCLIENT;
      ArrayHelper@1005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array" RUNONCLIENT;
      ClientFilePath@1008 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String" RUNONCLIENT;
      ServerFilePath@1001 : Text;
      RelativeServerPath@1010 : Text;
      i@1006 : Integer;
      ArrayLength@1007 : Integer;
    BEGIN
      if not ClientDirectoryExists(DirectoryPath) then
        ERROR(DirectoryDoesNotExistErr,DirectoryPath);

      if IncludeSubDirectories then
        ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath,FileExtensionFilter,SearchOption.AllDirectories)
      else
        ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath,FileExtensionFilter,SearchOption.TopDirectoryOnly);

      ArrayLength := ArrayHelper.GetLength(0);

      if ArrayLength = 0 then
        exit;

      ServerDirectoryPath := ServerCreateTempSubDirectory;

      for i := 1 to ArrayLength do begin
        ClientFilePath := ArrayHelper.GetValue(i - 1);
        RelativeServerPath := COPYSTR(ClientFilePath.Replace(DirectoryPath,''),2); // COPYSTR to remove leading \
        ServerFilePath := CombinePath(ServerDirectoryPath,RelativeServerPath);
        ServerCreateDirectory(GetDirectoryName(ServerFilePath));
        UploadFileSilentToServerPath(ClientFilePath,ServerFilePath);
      end;
    END;

    [Internal]
    PROCEDURE MoveFile@15(SourceFileName@1001 : Text;TargetFileName@1002 : Text);
    BEGIN
      // System.IO.File.Move is not used due to a known issue in KB310316
      if not ClientFileHelper.Exists(SourceFileName) then
        ERROR(FileDoesNotExistErr,SourceFileName);

      if UPPERCASE(SourceFileName) = UPPERCASE(TargetFileName) then
        exit;

      ValidateClientPath(GetDirectoryName(TargetFileName));

      DeleteClientFile(TargetFileName);
      ClientFileHelper.Copy(SourceFileName,TargetFileName);
      ClientFileHelper.Delete(SourceFileName);
    END;

    [Internal]
    PROCEDURE CopyServerFile@32(SourceFileName@1001 : Text;TargetFileName@1002 : Text;Overwrite@1000 : Boolean);
    BEGIN
      ServerFileHelper.Copy(SourceFileName,TargetFileName,Overwrite);
    END;

    [External]
    PROCEDURE ServerFileExists@33(FilePath@1001 : Text) : Boolean;
    BEGIN
      exit(EXISTS(FilePath));
    END;

    [Internal]
    PROCEDURE DeleteServerFile@34(FilePath@1001 : Text) : Boolean;
    BEGIN
      if not EXISTS(FilePath) then
        exit(false);

      ServerFileHelper.Delete(FilePath);
      exit(true);
    END;

    [Internal]
    PROCEDURE ServerDirectoryExists@48(DirectoryPath@1000 : Text) : Boolean;
    BEGIN
      exit(ServerDirectoryHelper.Exists(DirectoryPath));
    END;

    [Internal]
    PROCEDURE ServerCreateDirectory@47(DirectoryPath@1000 : Text);
    BEGIN
      if not ServerDirectoryExists(DirectoryPath) then
        ServerDirectoryHelper.CreateDirectory(DirectoryPath);
    END;

    [Internal]
    PROCEDURE ServerCreateTempSubDirectory@59() DirectoryPath : Text;
    VAR
      ServerTempFile@1001 : Text;
    BEGIN
      ServerTempFile := ServerTempFileName('tmp');
      DirectoryPath := CombinePath(GetDirectoryName(ServerTempFile),FORMAT(CREATEGUID));
      ServerCreateDirectory(DirectoryPath);
      DeleteServerFile(ServerTempFile);
    END;

    [Internal]
    PROCEDURE ServerRemoveDirectory@55(DirectoryPath@1000 : Text;Recursive@1001 : Boolean);
    BEGIN
      if ServerDirectoryExists(DirectoryPath) then
        ServerDirectoryHelper.Delete(DirectoryPath,Recursive);
    END;

    [External]
    PROCEDURE GetFileName@16(FilePath@1001 : Text) : Text;
    BEGIN
      exit(PathHelper.GetFileName(FilePath));
    END;

    [External]
    PROCEDURE GetSafeFileName@69(FileName@1000 : Text) : Text;
    VAR
      DotNetString@1001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      Result@1005 : Text;
      Str@1006 : Text;
    BEGIN
      DotNetString := FileName;
      foreach Str in DotNetString.Split(PathHelper.GetInvalidFileNameChars) do
        Result += Str;
      exit(Result);
    END;

    [Internal]
    PROCEDURE GetFileNameWithoutExtension@35(FilePath@1000 : Text) : Text;
    BEGIN
      exit(PathHelper.GetFileNameWithoutExtension(FilePath));
    END;

    [Internal]
    PROCEDURE GetDirectoryName@8(FileName@1001 : Text) : Text;
    BEGIN
      if FileName = '' then
        exit(FileName);

      FileName := DELCHR(FileName,'<');
      exit(PathHelper.GetDirectoryName(FileName));
    END;

    [Internal]
    PROCEDURE GetClientDirectoryFilesList@51(VAR NameValueBuffer@1002 : Record "Name/Value Buffer";DirectoryPath@1000 : Text);
    VAR
      ArrayHelper@1001 : DotNet "'mscorlib'.System.Array" RUNONCLIENT;
      i@1003 : Integer;
    BEGIN
      NameValueBuffer.RESET;
      NameValueBuffer.DELETEALL;

      ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath);
      for i := 1 to ArrayHelper.GetLength(0) do begin
        NameValueBuffer.ID := i;
        EVALUATE(NameValueBuffer.Name,ArrayHelper.GetValue(i - 1));
        NameValueBuffer.INSERT;
      end;
    END;

    [Internal]
    PROCEDURE GetServerDirectoryFilesList@64(VAR NameValueBuffer@1000 : Record "Name/Value Buffer";DirectoryPath@1001 : Text);
    VAR
      ArrayHelper@1002 : DotNet "'mscorlib'.System.Array";
      i@1003 : Integer;
    BEGIN
      NameValueBuffer.RESET;
      NameValueBuffer.DELETEALL;

      ArrayHelper := ServerDirectoryHelper.GetFiles(DirectoryPath);
      for i := 1 to ArrayHelper.GetLength(0) do begin
        NameValueBuffer.ID := i;
        EVALUATE(NameValueBuffer.Name,ArrayHelper.GetValue(i - 1));
        NameValueBuffer.Value := COPYSTR(GetFileNameWithoutExtension(NameValueBuffer.Name),1,250);
        NameValueBuffer.INSERT;
      end;
    END;

    [Internal]
    PROCEDURE GetServerDirectoryFilesListInclSubDirs@72(VAR TempNameValueBuffer@1000 : TEMPORARY Record "Name/Value Buffer";DirectoryPath@1001 : Text);
    BEGIN
      TempNameValueBuffer.RESET;
      TempNameValueBuffer.DELETEALL;

      GetServerDirectoryFilesListInclSubDirsInner(TempNameValueBuffer,DirectoryPath);
    END;

    LOCAL PROCEDURE GetServerDirectoryFilesListInclSubDirsInner@80(VAR NameValueBuffer@1000 : Record "Name/Value Buffer";DirectoryPath@1001 : Text);
    VAR
      ArrayHelper@1002 : DotNet "'mscorlib'.System.Array";
      FileSystemEntry@1004 : Text;
      Index@1003 : Integer;
      LastId@1005 : Integer;
    BEGIN
      ArrayHelper := ServerDirectoryHelper.GetFileSystemEntries(DirectoryPath);
      for Index := 1 to ArrayHelper.GetLength(0) do begin
        if NameValueBuffer.FINDLAST then
          LastId := NameValueBuffer.ID;
        EVALUATE(FileSystemEntry,ArrayHelper.GetValue(Index - 1));
        if ServerDirectoryExists(FileSystemEntry) then
          GetServerDirectoryFilesListInclSubDirsInner(NameValueBuffer,FileSystemEntry)
        else begin
          NameValueBuffer.ID := LastId + 1;
          NameValueBuffer.Name := COPYSTR(FileSystemEntry,1,250);
          NameValueBuffer.Value := COPYSTR(GetFileNameWithoutExtension(NameValueBuffer.Name),1,250);
          NameValueBuffer.INSERT;
        end;
      end;
    END;

    [Internal]
    PROCEDURE GetClientFileProperties@53(FullFileName@1000 : Text;VAR ModifyDate@1001 : Date;VAR ModifyTime@1002 : Time;VAR Size@1003 : Integer);
    VAR
      FileInfo@1004 : DotNet "'mscorlib'.System.IO.FileInfo" RUNONCLIENT;
      ModifyDateTime@1005 : DateTime;
    BEGIN
      ModifyDateTime := ClientFileHelper.GetLastWriteTime(FullFileName);
      ModifyDate := DT2DATE(ModifyDateTime);
      ModifyTime := DT2TIME(ModifyDateTime);
      Size := FileInfo.FileInfo(FullFileName).Length;
    END;

    [Internal]
    PROCEDURE CombinePath@50(BasePath@1000 : Text;Suffix@1001 : Text) : Text;
    BEGIN
      exit(PathHelper.Combine(BasePath,Suffix));
    END;

    [Internal]
    PROCEDURE BLOBImportFromServerFile@17(VAR TempBlob@1001 : Record TempBlob;FilePath@1000 : Text);
    VAR
      OutStream@1004 : OutStream;
      InStream@1003 : InStream;
      InputFile@1002 : File;
    BEGIN
      if not FILE.EXISTS(FilePath) then
        ERROR(FileDoesNotExistErr,FilePath);

      InputFile.OPEN(FilePath);
      InputFile.CREATEINSTREAM(InStream);
      TempBlob.Blob.CREATEOUTSTREAM(OutStream);
      COPYSTREAM(OutStream,InStream);
      InputFile.CLOSE;
    END;

    [Internal]
    PROCEDURE BLOBExportToServerFile@18(VAR TempBlob@1001 : Record TempBlob;FilePath@1000 : Text);
    VAR
      OutStream@1004 : OutStream;
      InStream@1003 : InStream;
      OutputFile@1002 : File;
    BEGIN
      if FILE.EXISTS(FilePath) then
        ERROR(Text013,FilePath);

      OutputFile.WRITEMODE(true);
      OutputFile.CREATE(FilePath);
      OutputFile.CREATEOUTSTREAM(OutStream);
      TempBlob.Blob.CREATEINSTREAM(InStream);
      COPYSTREAM(OutStream,InStream);
      OutputFile.CLOSE;
    END;

    [Internal]
    PROCEDURE GetToFilterText@19(FilterString@1002 : Text;FileName@1000 : Text) : Text;
    VAR
      OutExt@1001 : Text;
    BEGIN
      if FilterString <> '' then
        exit(FilterString);

      case UPPERCASE(GetExtension(FileName)) of
        'DOC':
          OutExt := WordFileType;
        'DOCX':
          OutExt := Word2007FileType;
        'XLS':
          OutExt := ExcelFileType;
        'XLSX':
          OutExt := Excel2007FileType;
        'XSLT':
          OutExt := XSLTFileType;
        'XML':
          OutExt := XMLFileType;
        'XSD':
          OutExt := XSDFileType;
        'HTM':
          OutExt := HTMFileType;
        'TXT':
          OutExt := TXTFileType;
        'RDL':
          OutExt := RDLFileTypeTok;
        'RDLC':
          OutExt := RDLFileTypeTok;
      end;
      if OutExt = '' then
        exit(AllFilesDescriptionTxt);
      exit(OutExt + '|' + AllFilesDescriptionTxt);  // Also give the option of the general selection
    END;

    [External]
    PROCEDURE GetExtension@20(Name@1000 : Text) : Text;
    VAR
      FileExtension@1002 : Text;
    BEGIN
      FileExtension := PathHelper.GetExtension(Name);

      if FileExtension <> '' then
        FileExtension := DELCHR(FileExtension,'<','.');

      exit(FileExtension);
    END;

    [External]
    PROCEDURE OpenFileDialog@1(WindowTitle@1000 : Text[50];DefaultFileName@1001 : Text;FilterString@1002 : Text) : Text;
    VAR
      OpenFileDialog@1006 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.OpenFileDialog" RUNONCLIENT;
      DialagResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      OpenFileDialog := OpenFileDialog.OpenFileDialog;
      OpenFileDialog.ShowReadOnly := false;
      OpenFileDialog.FileName := GetFileName(DefaultFileName);
      OpenFileDialog.Title := WindowTitle;
      OpenFileDialog.Filter := GetToFilterText(FilterString,DefaultFileName);
      OpenFileDialog.InitialDirectory := GetDirectoryName(DefaultFileName);

      DialagResult := OpenFileDialog.ShowDialog;
      if DialagResult.CompareTo(DialagResult.OK) = 0 then
        exit(OpenFileDialog.FileName);
      exit('');
    END;

    PROCEDURE SaveFileDialog@23(WindowTitle@1000 : Text[50];DefaultFileName@1001 : Text;FilterString@1002 : Text) : Text;
    VAR
      SaveFileDialog@1008 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.SaveFileDialog" RUNONCLIENT;
      DialagResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      SaveFileDialog := SaveFileDialog.SaveFileDialog;
      SaveFileDialog.CheckPathExists := true;
      SaveFileDialog.OverwritePrompt := true;
      SaveFileDialog.FileName := GetFileName(DefaultFileName);
      SaveFileDialog.Title := WindowTitle;
      SaveFileDialog.Filter := GetToFilterText(FilterString,DefaultFileName);
      SaveFileDialog.InitialDirectory := GetDirectoryName(DefaultFileName);

      DialagResult := SaveFileDialog.ShowDialog;
      if DialagResult.CompareTo(DialagResult.OK) = 0 then
        exit(SaveFileDialog.FileName);
      exit('');
    END;

    [External]
    PROCEDURE SelectFolderDialog@52(WindowTitle@1001 : Text;VAR SelectedFolder@1003 : Text) : Boolean;
    VAR
      FolderBrowser@1000 : DotNet "'System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.FolderBrowserDialog" RUNONCLIENT;
      DialogResult@1002 : DotNet "'System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      FolderBrowser := FolderBrowser.FolderBrowserDialog;
      FolderBrowser.ShowNewFolderButton := true;
      FolderBrowser.Description := WindowTitle;

      DialogResult := FolderBrowser.ShowDialog;
      if DialogResult = 1 then begin
        SelectedFolder := FolderBrowser.SelectedPath;
        exit(true);
      end;
    END;

    [External]
    PROCEDURE CanRunDotNetOnClient@41() : Boolean;
    VAR
      ClientTypeManagement@1001 : Codeunit ClientTypeManagement;
    BEGIN
      exit(ClientTypeManagement.IsWindowsClientType);
    END;

    [External]
    PROCEDURE IsWebClient@46() : Boolean;
    VAR
      ClientTypeManagement@1001 : Codeunit ClientTypeManagement;
    BEGIN
      exit(ClientTypeManagement.IsCommonWebClientType);
    END;

    [External]
    PROCEDURE IsWindowsClient@39() : Boolean;
    VAR
      ClientTypeManagement@1000 : Codeunit ClientTypeManagement;
    BEGIN
      exit(ClientTypeManagement.IsWindowsClientType);
    END;

    [Internal]
    PROCEDURE IsValidFileName@22(FileName@1000 : Text) : Boolean;
    VAR
      String@1001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
    BEGIN
      if FileName = '' then
        exit(false);

      String := GetFileName(FileName);
      if String.IndexOfAny(PathHelper.GetInvalidFileNameChars) <> -1 then
        exit(false);

      String := GetDirectoryName(FileName);
      if String.IndexOfAny(PathHelper.GetInvalidPathChars) <> -1 then
        exit(false);

      exit(true);
    END;

    LOCAL PROCEDURE ValidateFileNames@24(ServerFileName@1000 : Text;ClientFileName@1001 : Text);
    BEGIN
      if not IsValidFileName(ServerFileName) then
        ERROR(Text011);

      if not IsValidFileName(ClientFileName) then
        ERROR(Text012);
    END;

    [Internal]
    PROCEDURE ValidateFileExtension@26(FilePath@1000 : Text;ValidExtensions@1001 : Text);
    VAR
      FileExt@1003 : Text;
      LowerValidExts@1004 : Text;
    BEGIN
      if STRPOS(ValidExtensions,AllFilesFilterTxt) <> 0 then
        exit;

      FileExt := LOWERCASE(GetExtension(GetFileName(FilePath)));
      LowerValidExts := LOWERCASE(ValidExtensions);

      if STRPOS(LowerValidExts,FileExt) = 0 then
        ERROR(STRSUBSTNO(UnsupportedFileExtErr,FileExt,LowerValidExts));
    END;

    LOCAL PROCEDURE ValidateClientPath@45(FilePath@1000 : Text);
    BEGIN
      if FilePath = '' then
        exit;
      if DirectoryHelper.Exists(FilePath) then
        exit;

      if CONFIRM(CreatePathQst,true,FilePath) then
        DirectoryHelper.CreateDirectory(FilePath)
      else
        ERROR('');
    END;

    LOCAL PROCEDURE CreateFileNameWithExtension@58(FileNameWithoutExtension@1000 : Text;Extension@1001 : Text) FileName : Text;
    BEGIN
      FileName := FileNameWithoutExtension;
      if Extension <> '' then begin
        if Extension[1] <> '.' then
          FileName := FileName + '.';
        FileName := FileName + Extension;
      end
    END;

    [Internal]
    PROCEDURE Ansi2SystemEncoding@28(Destination@1000 : OutStream;Source@1001 : InStream);
    VAR
      StreamReader@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamReader";
      Encoding@1003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
      EncodedTxt@1002 : Text;
    BEGIN
      StreamReader := StreamReader.StreamReader(Source,Encoding.Default,true);
      EncodedTxt := StreamReader.ReadToEnd;
      Destination.WRITETEXT(EncodedTxt);
    END;

    [Internal]
    PROCEDURE Ansi2SystemEncodingTxt@29(Destination@1001 : OutStream;Source@1000 : Text);
    VAR
      StreamWriter@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamWriter";
      Encoding@1003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
    BEGIN
      StreamWriter := StreamWriter.StreamWriter(Destination,Encoding.Default);
      StreamWriter.Write(Source);
      StreamWriter.Close;
    END;

    [External]
    PROCEDURE BrowseForFolderDialog@30(WindowTitle@1000 : Text[50];DefaultFolderName@1001 : Text;ShowNewFolderButton@1002 : Boolean) : Text;
    VAR
      FolderBrowserDialog@1006 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.FolderBrowserDialog" RUNONCLIENT;
      DialagResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      FolderBrowserDialog := FolderBrowserDialog.FolderBrowserDialog;
      FolderBrowserDialog.Description := WindowTitle;
      FolderBrowserDialog.SelectedPath := DefaultFolderName;
      FolderBrowserDialog.ShowNewFolderButton := ShowNewFolderButton;

      DialagResult := FolderBrowserDialog.ShowDialog;
      if DialagResult.CompareTo(DialagResult.OK) = 0 then
        exit(FolderBrowserDialog.SelectedPath);
      exit(DefaultFolderName);
    END;

    [External]
    PROCEDURE StripNotsupportChrInFileName@31(InText@1000 : Text) : Text;
    BEGIN
      exit(DELCHR(InText,'=',InvalidWindowsChrStringTxt));
    END;

    [Internal]
    PROCEDURE CreateZipArchiveObject@36() FilePath : Text;
    BEGIN
      FilePath := ServerTempFileName('zip');
      OpenZipFile(FilePath);
    END;

    [Internal]
    PROCEDURE OpenZipFile@62(ServerZipFilePath@1035 : Text);
    VAR
      Zipfile@1001 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFile";
      ZipAchiveMode@1000 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchiveMode";
    BEGIN
      ZipArchive := Zipfile.Open(ServerZipFilePath,ZipAchiveMode.Create);
    END;

    [Internal]
    PROCEDURE AddFileToZipArchive@37(SourceFileFullPath@1000 : Text;PathInZipFile@1001 : Text);
    VAR
      Zip@1002 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFileExtensions";
    BEGIN
      Zip.CreateEntryFromFile(ZipArchive,SourceFileFullPath,PathInZipFile);
    END;

    [Internal]
    PROCEDURE CloseZipArchive@38();
    BEGIN
      if not ISNULL(ZipArchive) then
        ZipArchive.Dispose;
    END;

    [Internal]
    PROCEDURE IsGZip@40(ServerSideFileName@1000 : Text) : Boolean;
    VAR
      FileStream@1005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileStream";
      FileMode@1006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileMode";
      ID@1007 : ARRAY [2] OF Integer;
    BEGIN
      FileStream := FileStream.FileStream(ServerSideFileName,FileMode.Open);
      ID[1] := FileStream.ReadByte;
      ID[2] := FileStream.ReadByte;
      FileStream.Close;

      // from GZIP file format specification version 4.3
      // Member header and trailer
      // ID1 (IDentification 1)
      // ID2 (IDentification 2)
      // These have the fixed values ID1 = 31 (0x1f, \037), ID2 = 139 (0x8b, \213), to identify the file as being in gzip format.

      exit((ID[1] = 31) and (ID[2] = 139));
    END;

    [Internal]
    PROCEDURE ExtractZipFile@56(ZipFilePath@1001 : Text;DestinationFolder@1006 : Text);
    VAR
      Zip@1004 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFileExtensions";
      ZipFile@1000 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFile";
    BEGIN
      if not ServerFileHelper.Exists(ZipFilePath) then
        ERROR(FileDoesNotExistErr,ZipFilePath);

      // Create directory if it doesn't exist
      ServerCreateDirectory(DestinationFolder);

      ZipArchive := ZipFile.Open(ZipFilePath,ZipArchiveMode.Read);
      Zip.ExtractToDirectory(ZipArchive,DestinationFolder);
      CloseZipArchive;
    END;

    [Internal]
    PROCEDURE ExtractZipFileAndGetFileList@63(ServerZipFilePath@1000 : Text;VAR NameValueBuffer@1001 : Record "Name/Value Buffer");
    VAR
      ServerDestinationFolder@1002 : Text;
    BEGIN
      ServerDestinationFolder := ServerCreateTempSubDirectory;
      ExtractZipFile(ServerZipFilePath,ServerDestinationFolder);
      GetServerDirectoryFilesList(NameValueBuffer,ServerDestinationFolder);
    END;

    [Internal]
    PROCEDURE IsClientDirectoryEmpty@60(Path@1000 : Text) : Boolean;
    BEGIN
      if DirectoryHelper.Exists(Path) then
        exit(DirectoryHelper.GetFiles(Path).Length = 0);
      exit(false);
    END;

    [Internal]
    PROCEDURE IsServerDirectoryEmpty@61(Path@1000 : Text) : Boolean;
    BEGIN
      if ServerDirectoryHelper.Exists(Path) then
        exit(ServerDirectoryHelper.GetFiles(Path).Length = 0);
      exit(false);
    END;

    [External]
    PROCEDURE IsWebOrDeviceClient@65() : Boolean;
    VAR
      ActiveSession@1000 : Record "Active Session";
    BEGIN
      if ActiveSession.GET(SERVICEINSTANCEID,SESSIONID) then
        exit(ActiveSession."Client Type" in [ActiveSession."Client Type"::"Web Client",
                                             ActiveSession."Client Type"::Phone,
                                             ActiveSession."Client Type"::Tablet]);

      exit(false);
    END;

    [Internal]
    PROCEDURE GetFileContent@66(FilePath@1000 : Text) Result : Text;
    VAR
      FileHandle@1001 : File;
      InStr@1002 : InStream;
    BEGIN
      if not FILE.EXISTS(FilePath) then
        exit;

      FileHandle.OPEN(FilePath,TEXTENCODING::UTF8);
      FileHandle.CREATEINSTREAM(InStr);

      InStr.READTEXT(Result);
    END;

    BEGIN
    END.
  }
}

