OBJECT Codeunit 5836 Cost Calculation Management
{
  OBJECT-PROPERTIES
  {
    Date=20171006D;
    Time=120000T;
    Version List=NAVW111.0;
  }
  PROPERTIES
  {
    Permissions=TableData "Item Ledger Entry"=r,
                TableData "Value Entry"=r;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      ExpOvhdCost@1001 : Decimal;

    [External]
    PROCEDURE ResourceCostPerUnit@44(No@1005 : Code[20];VAR DirUnitCost@1004 : Decimal;VAR IndirCostPct@1003 : Decimal;VAR OvhdRate@1002 : Decimal;VAR UnitCost@1001 : Decimal);
    VAR
      Resource@1000 : Record Resource;
    BEGIN
      Resource.GET(No);
      DirUnitCost := Resource."Direct Unit Cost";
      OvhdRate := 0;
      IndirCostPct := Resource."Indirect Cost %";
      UnitCost := Resource."Unit Cost";
    END;

    [External]
    PROCEDURE RoutingCostPerUnit@7(Type@1000 : '"Work Center","Machine Center"';No@1001 : Code[20];VAR DirUnitCost@1002 : Decimal;VAR IndirCostPct@1003 : Decimal;VAR OvhdRate@1004 : Decimal;VAR UnitCost@1005 : Decimal;VAR UnitCostCalculation@1006 : 'Time,Unit');
    VAR
      WorkCenter@1007 : Record "Work Center";
      MachineCenter@1008 : Record "Machine Center";
    BEGIN
      case Type of
        Type::"Work Center":
          WorkCenter.GET(No);
        Type::"Machine Center":
          MachineCenter.GET(No);
      end;
      RoutingCostPerUnit2(Type,DirUnitCost,IndirCostPct,OvhdRate,UnitCost,UnitCostCalculation,WorkCenter,MachineCenter);
    END;

    [External]
    PROCEDURE RoutingCostPerUnit2@20(Type@1000 : '"Work Center","Machine Center"';VAR DirUnitCost@1002 : Decimal;VAR IndirCostPct@1003 : Decimal;VAR OvhdRate@1004 : Decimal;VAR UnitCost@1005 : Decimal;VAR UnitCostCalculation@1006 : 'Time,Unit';WorkCenter@1009 : Record "Work Center";MachineCenter@1010 : Record "Machine Center");
    BEGIN
      UnitCostCalculation := UnitCostCalculation::Time;
      case Type of
        Type::"Work Center":
          begin
            UnitCostCalculation := WorkCenter."Unit Cost Calculation";
            IndirCostPct := WorkCenter."Indirect Cost %";
            OvhdRate := WorkCenter."Overhead Rate";
            if WorkCenter."Specific Unit Cost" then begin
              DirUnitCost := CalcDirUnitCost(UnitCost,OvhdRate,IndirCostPct);
            end else begin
              DirUnitCost := WorkCenter."Direct Unit Cost";
              UnitCost := WorkCenter."Unit Cost";
            end;
          end;
        Type::"Machine Center":
          begin
            MachineCenter.TESTFIELD("Work Center No.");
            DirUnitCost := MachineCenter."Direct Unit Cost";
            OvhdRate := MachineCenter."Overhead Rate";
            IndirCostPct := MachineCenter."Indirect Cost %";
            UnitCost := MachineCenter."Unit Cost";
          end;
      end;
    END;

    [External]
    PROCEDURE CalcShareOfTotalCapCost@8(ProdOrderLine@1000 : Record "Prod. Order Line";VAR ShareOfTotalCapCost@1002 : Decimal);
    VAR
      Qty@1001 : Decimal;
    BEGIN
      with ProdOrderLine do begin
        SETCURRENTKEY(Status,"Prod. Order No.","Routing No.","Routing Reference No.");
        SETRANGE(Status,Status);
        SETRANGE("Prod. Order No.","Prod. Order No.");
        SETRANGE("Routing Reference No.","Routing Reference No.");
        SETRANGE("Routing No.","Routing No.");
        ShareOfTotalCapCost := 0;
        if Status = Status::Finished then begin
          Qty := "Finished Quantity";
          CALCSUMS("Finished Quantity");
          if "Finished Quantity" <> 0 then
            ShareOfTotalCapCost := Qty / "Finished Quantity";
        end else begin
          Qty := Quantity;
          CALCSUMS(Quantity);
          if Quantity <> 0 then
            ShareOfTotalCapCost := Qty / Quantity;
        end;
      end;
    END;

    [External]
    PROCEDURE CalcProdOrderLineStdCost@16(ProdOrderLine@1000 : Record "Prod. Order Line";CurrencyFactor@1007 : Decimal;RndgPrec@1006 : Decimal;VAR StdMatCost@1005 : Decimal;VAR StdCapDirCost@1004 : Decimal;VAR StdSubDirCost@1008 : Decimal;VAR StdCapOvhdCost@1003 : Decimal;VAR StdMfgOvhdCost@1002 : Decimal);
    VAR
      Item@1001 : Record Item;
      InvtAdjmtEntryOrder@1010 : Record "Inventory Adjmt. Entry (Order)";
      QtyBase@1009 : Decimal;
    BEGIN
      with ProdOrderLine do begin
        if InvtAdjmtEntryOrder.GET(InvtAdjmtEntryOrder."Order Type"::Production,"Prod. Order No.","Line No.") and
           InvtAdjmtEntryOrder."Completely Invoiced"
        then begin
          Item."Single-Level Material Cost" := InvtAdjmtEntryOrder."Single-Level Material Cost";
          Item."Single-Level Capacity Cost" := InvtAdjmtEntryOrder."Single-Level Capacity Cost";
          Item."Single-Level Subcontrd. Cost" := InvtAdjmtEntryOrder."Single-Level Subcontrd. Cost";
          Item."Single-Level Cap. Ovhd Cost" := InvtAdjmtEntryOrder."Single-Level Cap. Ovhd Cost";
          Item."Single-Level Mfg. Ovhd Cost" := InvtAdjmtEntryOrder."Single-Level Mfg. Ovhd Cost";
          QtyBase := "Finished Qty. (Base)";
        end else begin
          Item.GET("Item No.");
          QtyBase := "Quantity (Base)";
        end;

        StdMatCost := StdMatCost +
          ROUND(QtyBase * Item."Single-Level Material Cost" * CurrencyFactor,RndgPrec);
        StdCapDirCost := StdCapDirCost +
          ROUND(QtyBase * Item."Single-Level Capacity Cost" * CurrencyFactor,RndgPrec);
        StdSubDirCost := StdSubDirCost +
          ROUND(QtyBase * Item."Single-Level Subcontrd. Cost" * CurrencyFactor,RndgPrec);
        StdCapOvhdCost := StdCapOvhdCost +
          ROUND(QtyBase * Item."Single-Level Cap. Ovhd Cost" * CurrencyFactor,RndgPrec);
        StdMfgOvhdCost := StdMfgOvhdCost +
          ROUND(QtyBase * Item."Single-Level Mfg. Ovhd Cost" * CurrencyFactor,RndgPrec);
      end;
    END;

    [External]
    PROCEDURE CalcProdOrderLineExpCost@15(ProdOrderLine@1001 : Record "Prod. Order Line";ShareOfTotalCapCost@1009 : Decimal;VAR ExpMatCost@1010 : Decimal;VAR ExpCapDirCost@1008 : Decimal;VAR ExpSubDirCost@1007 : Decimal;VAR ExpCapOvhdCost@1006 : Decimal;VAR ExpMfgOvhdCost@1002 : Decimal);
    VAR
      WorkCenter@1005 : Record "Work Center";
      ProdOrderComp@1000 : Record "Prod. Order Component";
      ProdOrderRtngLine@1003 : Record "Prod. Order Routing Line";
      ExpOperCost@1004 : Decimal;
      ExpMfgDirCost@1011 : Decimal;
      ExpCapDirCostRtng@1014 : Decimal;
      ExpSubDirCostRtng@1013 : Decimal;
      ExpCapOvhdCostRtng@1012 : Decimal;
    BEGIN
      with ProdOrderLine do begin
        ProdOrderComp.SETCURRENTKEY(Status,"Prod. Order No.","Prod. Order Line No.");
        ProdOrderComp.SETRANGE(Status,Status);
        ProdOrderComp.SETRANGE("Prod. Order No.","Prod. Order No.");
        ProdOrderComp.SETRANGE("Prod. Order Line No.","Line No.");
        if ProdOrderComp.FIND('-') then
          repeat
            ExpMatCost := ExpMatCost + ProdOrderComp."Cost Amount";
          until ProdOrderComp.NEXT = 0;

        ProdOrderRtngLine.SETRANGE(Status,Status);
        ProdOrderRtngLine.SETRANGE("Prod. Order No.","Prod. Order No.");
        ProdOrderRtngLine.SETRANGE("Routing No.","Routing No.");
        ProdOrderRtngLine.SETRANGE("Routing Reference No.","Routing Reference No.");
        if ProdOrderRtngLine.FIND('-') then
          repeat
            ExpOperCost :=
              ProdOrderRtngLine."Expected Operation Cost Amt." -
              ProdOrderRtngLine."Expected Capacity Ovhd. Cost";

            if ProdOrderRtngLine.Type = ProdOrderRtngLine.Type::"Work Center" then begin
              if not WorkCenter.GET(ProdOrderRtngLine."No.") then
                CLEAR(WorkCenter);
            end else
              CLEAR(WorkCenter);

            if WorkCenter."Subcontractor No." <> '' then
              ExpSubDirCostRtng := ExpSubDirCostRtng + ExpOperCost
            else
              ExpCapDirCostRtng := ExpCapDirCostRtng + ExpOperCost;
            ExpCapOvhdCostRtng := ExpCapOvhdCostRtng + ProdOrderRtngLine."Expected Capacity Ovhd. Cost";
          until ProdOrderRtngLine.NEXT = 0;

        ExpCapDirCost := ExpCapDirCost + ROUND(ExpCapDirCostRtng * ShareOfTotalCapCost);
        ExpSubDirCost := ExpSubDirCost + ROUND(ExpSubDirCostRtng * ShareOfTotalCapCost);
        ExpCapOvhdCost := ExpCapOvhdCost + ROUND(ExpCapOvhdCostRtng * ShareOfTotalCapCost);
        ExpMfgDirCost := ExpMatCost + ExpCapDirCost + ExpSubDirCost + ExpCapOvhdCost;
        ExpOvhdCost := ExpOvhdCost + "Overhead Rate" * "Quantity (Base)";
        ExpMfgOvhdCost := ExpOvhdCost +
          ROUND(CalcOvhdCost(ExpMfgDirCost,"Indirect Cost %",0,0));
      end;
    END;

    [External]
    PROCEDURE CalcProdOrderLineActCost@22(ProdOrderLine@1000 : Record "Prod. Order Line";VAR ActMatCost@1018 : Decimal;VAR ActCapDirCost@1007 : Decimal;VAR ActSubDirCost@1020 : Decimal;VAR ActCapOvhdCost@1008 : Decimal;VAR ActMfgOvhdCost@1010 : Decimal;VAR ActMatCostCostACY@1019 : Decimal;VAR ActCapDirCostACY@1016 : Decimal;VAR ActSubDirCostACY@1006 : Decimal;VAR ActCapOvhdCostACY@1015 : Decimal;VAR ActMfgOvhdCostACY@1013 : Decimal);
    VAR
      TempSourceInvtAdjmtEntryOrder@1027 : TEMPORARY Record "Inventory Adjmt. Entry (Order)";
      CalcInvtAdjmtOrder@1026 : Codeunit "Calc. Inventory Adjmt. - Order";
      OutputQty@1003 : Decimal;
    BEGIN
      if ProdOrderLine.Status < ProdOrderLine.Status::Released then begin
        ActMatCost := 0;
        ActCapDirCost := 0;
        ActSubDirCost := 0;
        ActCapOvhdCost := 0;
        ActMfgOvhdCost := 0;
        ActMatCostCostACY := 0;
        ActCapDirCostACY := 0;
        ActCapOvhdCostACY := 0;
        ActSubDirCostACY := 0;
        ActMfgOvhdCostACY := 0;
        exit;
      end;

      with TempSourceInvtAdjmtEntryOrder do begin
        SetProdOrderLine(ProdOrderLine);
        OutputQty := CalcInvtAdjmtOrder.CalcOutputQty(TempSourceInvtAdjmtEntryOrder,false);
        CalcInvtAdjmtOrder.CalcActualUsageCosts(TempSourceInvtAdjmtEntryOrder,OutputQty,TempSourceInvtAdjmtEntryOrder);

        ActMatCost += "Single-Level Material Cost";
        ActCapDirCost += "Single-Level Capacity Cost";
        ActSubDirCost += "Single-Level Subcontrd. Cost";
        ActCapOvhdCost += "Single-Level Cap. Ovhd Cost";
        ActMfgOvhdCost += "Single-Level Mfg. Ovhd Cost";
        ActMatCostCostACY += "Single-Lvl Material Cost (ACY)";
        ActCapDirCostACY += "Single-Lvl Capacity Cost (ACY)";
        ActCapOvhdCostACY += "Single-Lvl Cap. Ovhd Cost(ACY)";
        ActSubDirCostACY += "Single-Lvl Subcontrd Cost(ACY)";
        ActMfgOvhdCostACY += "Single-Lvl Mfg. Ovhd Cost(ACY)";
      end;
    END;

    [External]
    PROCEDURE CalcProdOrderExpCapNeed@17(ProdOrder@1001 : Record "Production Order";DrillDown@1002 : Boolean) : Decimal;
    VAR
      ProdOrderRtngLine@1003 : Record "Prod. Order Routing Line";
      ProdOrderCapNeed@1000 : Record "Prod. Order Capacity Need";
      WorkCenter@1004 : Record "Work Center";
      NeededTime@1005 : Decimal;
      ExpectedCapNeed@1006 : Decimal;
    BEGIN
      with ProdOrder do
        if Status <> Status::Finished then begin
          ProdOrderCapNeed.SETRANGE(Status,Status);
          ProdOrderCapNeed.SETRANGE("Prod. Order No.","No.");
          ProdOrderCapNeed.SETFILTER(Type,GETFILTER("Capacity Type Filter"));
          ProdOrderCapNeed.SETFILTER("No.","Capacity No. Filter");
          ProdOrderCapNeed.SETFILTER("Work Center No.","Work Center Filter");
          ProdOrderCapNeed.SETFILTER(Date,GETFILTER("Date Filter"));
          ProdOrderCapNeed.SETRANGE("Requested Only",false);
          if ProdOrderCapNeed.FINDSET then begin
            repeat
              if ProdOrderCapNeed.Type = ProdOrderCapNeed.Type::"Work Center" then begin
                if not WorkCenter.GET(ProdOrderCapNeed."No.") then
                  CLEAR(WorkCenter);
              end else
                CLEAR(WorkCenter);
              if WorkCenter."Subcontractor No." = '' then begin
                NeededTime += ProdOrderCapNeed."Needed Time (ms)";
                ProdOrderCapNeed.MARK(true);
              end;
            until ProdOrderCapNeed.NEXT = 0;
            ProdOrderCapNeed.MARKEDONLY(true);
          end;
          if DrillDown then
            PAGE.RUN(0,ProdOrderCapNeed,ProdOrderCapNeed."Needed Time")
          else
            exit(NeededTime);
        end else begin
          ProdOrderRtngLine.SETRANGE(Status,Status);
          ProdOrderRtngLine.SETRANGE("Prod. Order No.","No.");
          if ProdOrderRtngLine.FINDSET then begin
            repeat
              if ProdOrderRtngLine.Type = ProdOrderRtngLine.Type::"Work Center" then begin
                if not WorkCenter.GET(ProdOrderRtngLine."No.") then
                  CLEAR(WorkCenter);
              end else
                CLEAR(WorkCenter);
              if WorkCenter."Subcontractor No." = '' then begin
                ExpectedCapNeed += ProdOrderRtngLine."Expected Capacity Need";
                ProdOrderRtngLine.MARK(true);
              end;
            until ProdOrderRtngLine.NEXT = 0;
            ProdOrderRtngLine.MARKEDONLY(true);
          end;
          if DrillDown then
            PAGE.RUN(0,ProdOrderRtngLine,ProdOrderRtngLine."Expected Capacity Need")
          else
            exit(ExpectedCapNeed);
        end;
    END;

    [External]
    PROCEDURE CalcProdOrderActTimeUsed@19(ProdOrder@1001 : Record "Production Order";DrillDown@1002 : Boolean) : Decimal;
    VAR
      CapLedgEntry@1003 : Record "Capacity Ledger Entry";
      WorkCenter@1004 : Record "Work Center";
      CalendarMgt@1005 : Codeunit CalendarManagement;
      Qty@1000 : Decimal;
    BEGIN
      with CapLedgEntry do begin
        if ProdOrder.Status < ProdOrder.Status::Released then
          exit(0);

        SETCURRENTKEY("Order Type","Order No.");
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrder."No.");
        if FINDSET then begin
          repeat
            if Type = Type::"Work Center" then begin
              if not WorkCenter.GET("No.") then
                CLEAR(WorkCenter);
            end else
              CLEAR(WorkCenter);
            if WorkCenter."Subcontractor No." = '' then begin
              if "Qty. per Cap. Unit of Measure" = 0 then
                GetCapacityUoM(CapLedgEntry);
              Qty +=
                ("Setup Time" + "Run Time") /
                "Qty. per Cap. Unit of Measure" *
                CalendarMgt.TimeFactor("Cap. Unit of Measure Code");
              MARK(true);
            end;
          until NEXT = 0;
          MARKEDONLY(true);
        end;

        if DrillDown then
          PAGE.RUN(0,CapLedgEntry,Quantity)
        else
          exit(Qty);
      end;
    END;

    LOCAL PROCEDURE GetCapacityUoM@43(VAR CapacityLedgerEntry@1000 : Record "Capacity Ledger Entry");
    VAR
      WorkCenter@1001 : Record "Work Center";
    BEGIN
      CapacityLedgerEntry."Qty. per Cap. Unit of Measure" := 1;
      if WorkCenter.GET(CapacityLedgerEntry."Work Center No.") then
        CapacityLedgerEntry."Cap. Unit of Measure Code" := WorkCenter."Unit of Measure Code";
    END;

    [External]
    PROCEDURE CalcOutputQtyBaseOnPurchOrder@6(ProdOrderLine@1000 : Record "Prod. Order Line";ProdOrderRtngLine@1001 : Record "Prod. Order Routing Line") : Decimal;
    VAR
      PurchLine@1002 : Record "Purchase Line";
      Item@1003 : Record Item;
      UOMMgt@1004 : Codeunit "Unit of Measure Management";
      OutstandingBaseQty@1005 : Decimal;
    BEGIN
      with PurchLine do begin
        SETCURRENTKEY(
          "Document Type",Type,"Prod. Order No.","Prod. Order Line No.","Routing No.","Operation No.");
        SETRANGE("Document Type","Document Type"::Order);
        SETRANGE(Type,Type::Item);
        SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Prod. Order Line No.",ProdOrderLine."Line No.");
        SETRANGE("Routing No.",ProdOrderRtngLine."Routing No.");
        SETRANGE("Operation No.",ProdOrderRtngLine."Operation No.");
        if FIND('-') then
          repeat
            if Item."No." <> "No." then
              Item.GET("No.");
            OutstandingBaseQty :=
              OutstandingBaseQty +
              UOMMgt.GetQtyPerUnitOfMeasure(Item,"Unit of Measure Code") * "Outstanding Quantity";
          until NEXT = 0;
        exit(OutstandingBaseQty);
      end;
    END;

    [External]
    PROCEDURE CalcActOutputQtyBase@5(ProdOrderLine@1000 : Record "Prod. Order Line";ProdOrderRtngLine@1001 : Record "Prod. Order Routing Line") : Decimal;
    VAR
      CapLedgEntry@1002 : Record "Capacity Ledger Entry";
    BEGIN
      with CapLedgEntry do begin
        if ProdOrderLine.Status < ProdOrderLine.Status::Released then
          exit(0);

        SETCURRENTKEY(
          "Order Type","Order No.","Order Line No.","Routing No.","Routing Reference No.","Operation No.");
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Order Line No.",ProdOrderLine."Line No.");
        SETRANGE("Routing No.",ProdOrderRtngLine."Routing No.");
        SETRANGE("Routing Reference No.",ProdOrderRtngLine."Routing Reference No.");
        SETRANGE("Operation No.",ProdOrderRtngLine."Operation No.");
        CALCSUMS("Output Quantity");
        exit("Output Quantity");
      end;
    END;

    [External]
    PROCEDURE CalcActOperOutputAndScrap@13(ProdOrderLine@1002 : Record "Prod. Order Line";ProdOrderRtngLine@1001 : Record "Prod. Order Routing Line") OutputQtyBase : Decimal;
    VAR
      CapLedgEntry@1000 : Record "Capacity Ledger Entry";
    BEGIN
      with CapLedgEntry do begin
        if ProdOrderLine.Status < ProdOrderLine.Status::Released then
          exit(0);

        SETCURRENTKEY(
          "Order Type","Order No.","Order Line No.","Routing No.","Routing Reference No.","Operation No.","Last Output Line");
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Order Line No.",ProdOrderLine."Line No.");
        SETRANGE("Routing No.",ProdOrderRtngLine."Routing No.");
        SETRANGE("Routing Reference No.",ProdOrderRtngLine."Routing Reference No.");
        SETRANGE("Last Output Line",true);
        if FIND('-') then
          repeat
            OutputQtyBase += "Output Quantity" + "Scrap Quantity";
          until NEXT = 0;

        exit(OutputQtyBase);
      end;
    END;

    [External]
    PROCEDURE CalcActNeededQtyBase@18(ProdOrderLine@1000 : Record "Prod. Order Line";ProdOrderComp@1001 : Record "Prod. Order Component";OutputQtyBase@1004 : Decimal) : Decimal;
    VAR
      CompQtyBasePerMfgQtyBase@1002 : Decimal;
    BEGIN
      CompQtyBasePerMfgQtyBase := ProdOrderComp."Quantity (Base)" / ProdOrderLine."Qty. per Unit of Measure";
      exit(CalcQtyAdjdForBOMScrap(OutputQtyBase * CompQtyBasePerMfgQtyBase,ProdOrderComp."Scrap %"));
    END;

    [External]
    PROCEDURE CalcActTimeAndQtyBase@25(ProdOrderLine@1007 : Record "Prod. Order Line";OperationNo@1000 : Code[10];VAR ActRunTime@1004 : Decimal;VAR ActSetupTime@1003 : Decimal;VAR ActOutputQty@1002 : Decimal;VAR ActScrapQty@1001 : Decimal);
    VAR
      CapLedgEntry@1005 : Record "Capacity Ledger Entry";
    BEGIN
      with CapLedgEntry do begin
        SETCURRENTKEY(
          "Order Type","Order No.","Order Line No.","Routing No.","Routing Reference No.",
          "Operation No.","Last Output Line");

        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Order Line No.",ProdOrderLine."Line No.");
        SETRANGE("Routing No.",ProdOrderLine."Routing No.");
        SETRANGE("Routing Reference No.",ProdOrderLine."Routing Reference No.");
        SETRANGE("Operation No.",OperationNo);
        if FIND('-') then
          repeat
            ActSetupTime += "Setup Time";
            ActRunTime += "Run Time";
            // Base Units
            ActOutputQty += "Output Quantity";
            ActScrapQty += "Scrap Quantity";
          until NEXT = 0;
      end;
    END;

    [External]
    PROCEDURE CalcCompItemQtyBase@12(ProdBOMComponent@1000 : Record "Production BOM Line";CalculationDate@1008 : Date;MfgItemQtyBase@1001 : Decimal;RtngNo@1002 : Code[20];AdjdForRtngScrap@1003 : Boolean) : Decimal;
    VAR
      RtngLine@1004 : Record "Routing Line";
    BEGIN
      with ProdBOMComponent do begin
        MfgItemQtyBase := CalcQtyAdjdForBOMScrap(MfgItemQtyBase,"Scrap %");
        if AdjdForRtngScrap and FindRountingLine(RtngLine,ProdBOMComponent,CalculationDate,RtngNo) then
          MfgItemQtyBase :=
            CalcQtyAdjdForRoutingScrap(MfgItemQtyBase,RtngLine."Scrap Factor % (Accumulated)",RtngLine."Fixed Scrap Qty. (Accum.)");
        MfgItemQtyBase := MfgItemQtyBase * Quantity * GetQtyPerUnitOfMeasure;

        exit(MfgItemQtyBase);
      end;
    END;

    [External]
    PROCEDURE CalcCostTime@3(MfgItemQtyBase@1001 : Decimal;SetupTime@1002 : Decimal;SetupTimeUOMCode@1003 : Code[10];RunTime@1004 : Decimal;RunTimeUOMCode@1005 : Code[10];RtngLotSize@1006 : Decimal;ScrapFactorPctAccum@1007 : Decimal;FixedScrapQtyAccum@1008 : Decimal;WorkCenterNo@1009 : Code[20];UnitCostCalculation@1010 : 'Time,Unit';CostInclSetup@1011 : Boolean;ConcurrentCapacities@1014 : Decimal) CostTime@1000 : Decimal;
    VAR
      CalendarMgt@1012 : Codeunit CalendarManagement;
      RunTimePer@1013 : Decimal;
    BEGIN
      if ConcurrentCapacities = 0 then
        ConcurrentCapacities := 1;

      case UnitCostCalculation of
        UnitCostCalculation::Time:
          begin
            if RtngLotSize = 0 then
              RtngLotSize := 1;
            RunTimePer := RunTime / RtngLotSize;
            CostTime :=
              CalcQtyAdjdForRoutingScrap(
                ROUND(
                  RunTimePer * MfgItemQtyBase * CalendarMgt.QtyperTimeUnitofMeasure(WorkCenterNo,RunTimeUOMCode),
                  0.00001),
                ScrapFactorPctAccum,
                ROUND(
                  RunTimePer * FixedScrapQtyAccum * CalendarMgt.QtyperTimeUnitofMeasure(WorkCenterNo,RunTimeUOMCode),
                  0.00001));
            if CostInclSetup then
              CostTime :=
                CostTime +
                ROUND(
                  ConcurrentCapacities *
                  SetupTime * CalendarMgt.QtyperTimeUnitofMeasure(WorkCenterNo,SetupTimeUOMCode),
                  0.00001);
          end;
        UnitCostCalculation::Unit:
          CostTime := CalcQtyAdjdForRoutingScrap(MfgItemQtyBase,ScrapFactorPctAccum,FixedScrapQtyAccum);
      end;
    END;

    [External]
    PROCEDURE CalcQtyAdjdForBOMScrap@4(Qty@1000 : Decimal;ScrapPct@1001 : Decimal) : Decimal;
    BEGIN
      exit(Qty * (1 + ScrapPct / 100));
    END;

    [External]
    PROCEDURE CalcQtyAdjdForRoutingScrap@1(Qty@1000 : Decimal;ScrapFactorPctAccum@1001 : Decimal;FixedScrapQtyAccum@1002 : Decimal) : Decimal;
    BEGIN
      exit(Qty * (1 + ScrapFactorPctAccum) + FixedScrapQtyAccum);
    END;

    [External]
    PROCEDURE CalcDirCost@11(Cost@1000 : Decimal;OvhdCost@1001 : Decimal;VarPurchCost@1002 : Decimal) : Decimal;
    BEGIN
      exit(Cost - OvhdCost - VarPurchCost);
    END;

    [External]
    PROCEDURE CalcDirUnitCost@21(UnitCost@1000 : Decimal;OvhdRate@1001 : Decimal;IndirCostPct@1002 : Decimal) : Decimal;
    BEGIN
      exit((UnitCost - OvhdRate) / (1 + IndirCostPct / 100));
    END;

    [External]
    PROCEDURE CalcOvhdCost@10(DirCost@1000 : Decimal;IndirCostPct@1001 : Decimal;OvhdRate@1002 : Decimal;QtyBase@1003 : Decimal) : Decimal;
    BEGIN
      exit(DirCost * IndirCostPct / 100 + OvhdRate * QtyBase);
    END;

    [External]
    PROCEDURE CalcUnitCost@14(DirCost@1000 : Decimal;IndirCostPct@1001 : Decimal;OvhdRate@1002 : Decimal;RndgPrec@1003 : Decimal) : Decimal;
    BEGIN
      exit(ROUND(DirCost * (1 + IndirCostPct / 100) + OvhdRate,RndgPrec));
    END;

    [External]
    PROCEDURE FindRountingLine@35(VAR RoutingLine@1001 : Record "Routing Line";ProdBOMLine@1000 : Record "Production BOM Line";CalculationDate@1002 : Date;RoutingNo@1003 : Code[20]) RecFound : Boolean;
    VAR
      VersionMgt@1004 : Codeunit VersionManagement;
    BEGIN
      if RoutingNo = '' then
        exit(false);

      RecFound := false;
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      RoutingLine.SETRANGE("Version Code",VersionMgt.GetRtngVersion(RoutingNo,CalculationDate,true));
      if not RoutingLine.ISEMPTY then begin
        if ProdBOMLine."Routing Link Code" <> '' then
          RoutingLine.SETRANGE("Routing Link Code",ProdBOMLine."Routing Link Code");
        RecFound := RoutingLine.FINDFIRST;
        if not RecFound then begin
          RoutingLine.SETRANGE("Routing Link Code");
          RecFound := RoutingLine.FINDFIRST;
        end;
      end;

      exit(RecFound);
    END;

    [External]
    PROCEDURE GetRndgSetup@2(VAR GLSetup@1000 : Record "General Ledger Setup";VAR Currency@1001 : Record Currency;VAR RndgSetupRead@1002 : Boolean);
    BEGIN
      if RndgSetupRead then
        exit;
      GLSetup.GET;
      GLSetup.TESTFIELD("Amount Rounding Precision");
      GLSetup.TESTFIELD("Unit-Amount Rounding Precision");
      if GLSetup."Additional Reporting Currency" <> '' then begin
        Currency.GET(GLSetup."Additional Reporting Currency");
        Currency.TESTFIELD("Amount Rounding Precision");
        Currency.TESTFIELD("Unit-Amount Rounding Precision");
      end;
      RndgSetupRead := true;
    END;

    [External]
    PROCEDURE TransferCost@9(VAR Cost@1000 : Decimal;VAR UnitCost@1001 : Decimal;SrcCost@1002 : Decimal;Qty@1003 : Decimal;UnitAmtRndgPrec@1004 : Decimal);
    BEGIN
      Cost := SrcCost;
      if Qty <> 0 then
        UnitCost := ROUND(Cost / Qty,UnitAmtRndgPrec);
    END;

    [External]
    PROCEDURE SplitItemLedgerEntriesExist@24(VAR TempItemLedgEntry@1002 : TEMPORARY Record "Item Ledger Entry";QtyBase@1004 : Decimal;ItemLedgEntryNo@1000 : Integer) : Boolean;
    VAR
      ItemLedgEntry@1001 : Record "Item Ledger Entry";
      ItemLedgEntry2@1003 : Record "Item Ledger Entry";
    BEGIN
      if ItemLedgEntryNo = 0 then
        exit(false);
      TempItemLedgEntry.RESET;
      TempItemLedgEntry.DELETEALL;
      if ItemLedgEntry.GET(ItemLedgEntryNo) and (ItemLedgEntry.Quantity <> QtyBase) then
        if ItemLedgEntry2.GET(ItemLedgEntry."Entry No." - 1) and
           IsSameDocLineItemLedgEntry(ItemLedgEntry,ItemLedgEntry2,QtyBase)
        then begin
          TempItemLedgEntry := ItemLedgEntry2;
          TempItemLedgEntry.INSERT;
          TempItemLedgEntry := ItemLedgEntry;
          TempItemLedgEntry.INSERT;
          exit(true);
        end;

      exit(false);
    END;

    LOCAL PROCEDURE IsSameDocLineItemLedgEntry@46(ItemLedgEntry@1000 : Record "Item Ledger Entry";ItemLedgEntry2@1002 : Record "Item Ledger Entry";QtyBase@1003 : Decimal) : Boolean;
    BEGIN
      with ItemLedgEntry2 do
        exit(
          ("Document Type" = ItemLedgEntry."Document Type") and
          ("Document No." = ItemLedgEntry."Document No.") and
          ("Document Line No." = ItemLedgEntry."Document Line No.") and
          ("Posting Date" = ItemLedgEntry."Posting Date") and
          ("Source Type" = ItemLedgEntry."Source Type") and
          ("Source No." = ItemLedgEntry."Source No.") and
          ("Entry Type" = ItemLedgEntry."Entry Type") and
          ("Item No." = ItemLedgEntry."Item No.") and
          ("Location Code" = ItemLedgEntry."Location Code") and
          ("Variant Code" = ItemLedgEntry."Variant Code") and
          (QtyBase = Quantity + ItemLedgEntry.Quantity) and
          (Quantity = "Invoiced Quantity"));
    END;

    [External]
    PROCEDURE CalcSalesLineCostLCY@32(SalesLine@1000 : Record "Sales Line";QtyType@1005 : 'General,Invoicing') TotalAdjCostLCY : Decimal;
    VAR
      PostedQtyBase@1001 : Decimal;
      RemQtyToCalcBase@1006 : Decimal;
    BEGIN
      case SalesLine."Document Type" of
        SalesLine."Document Type"::Order,SalesLine."Document Type"::Invoice:
          if ((SalesLine."Quantity Shipped" <> 0) or (SalesLine."Shipment No." <> '')) and
             ((QtyType = QtyType::General) or (SalesLine."Qty. to Invoice" > SalesLine."Qty. to Ship"))
          then
            CalcSalesLineShptAdjCostLCY(SalesLine,QtyType,TotalAdjCostLCY,PostedQtyBase,RemQtyToCalcBase);
        SalesLine."Document Type"::"Return Order",SalesLine."Document Type"::"Credit Memo":
          if ((SalesLine."Return Qty. Received" <> 0) or (SalesLine."Return Receipt No." <> '')) and
             ((QtyType = QtyType::General) or (SalesLine."Qty. to Invoice" > SalesLine."Return Qty. to Receive"))
          then
            CalcSalesLineRcptAdjCostLCY(SalesLine,QtyType,TotalAdjCostLCY,PostedQtyBase,RemQtyToCalcBase);
      end;
    END;

    LOCAL PROCEDURE CalcSalesLineShptAdjCostLCY@34(SalesLine@1002 : Record "Sales Line";QtyType@1001 : 'General,Invoicing';VAR TotalAdjCostLCY@1000 : Decimal;VAR PostedQtyBase@1004 : Decimal;VAR RemQtyToCalcBase@1003 : Decimal);
    VAR
      SalesShptLine@1005 : Record "Sales Shipment Line";
      QtyShippedNotInvcdBase@1006 : Decimal;
      AdjCostLCY@1007 : Decimal;
    BEGIN
      with SalesShptLine do begin
        if SalesLine."Shipment No." <> '' then begin
          SETRANGE("Document No.",SalesLine."Shipment No.");
          SETRANGE("Line No.",SalesLine."Shipment Line No.");
        end else begin
          SETCURRENTKEY("Order No.","Order Line No.");
          SETRANGE("Order No.",SalesLine."Document No.");
          SETRANGE("Order Line No.",SalesLine."Line No.");
        end;
        SETRANGE(Correction,false);
        if QtyType = QtyType::Invoicing then begin
          SETFILTER("Qty. Shipped Not Invoiced",'<>0');
          RemQtyToCalcBase := SalesLine."Qty. to Invoice (Base)" - SalesLine."Qty. to Ship (Base)";
        end else
          RemQtyToCalcBase := SalesLine."Quantity (Base)";

        if FINDSET then
          repeat
            if "Qty. per Unit of Measure" = 0 then
              QtyShippedNotInvcdBase := "Qty. Shipped Not Invoiced"
            else
              QtyShippedNotInvcdBase :=
                ROUND("Qty. Shipped Not Invoiced" * "Qty. per Unit of Measure",0.00001);

            AdjCostLCY := CalcSalesShptLineCostLCY(SalesShptLine,QtyType);

            case true of
              QtyType = QtyType::Invoicing:
                if RemQtyToCalcBase > QtyShippedNotInvcdBase then begin
                  TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
                  RemQtyToCalcBase := RemQtyToCalcBase - QtyShippedNotInvcdBase;
                  PostedQtyBase := PostedQtyBase + QtyShippedNotInvcdBase;
                end else begin
                  PostedQtyBase := PostedQtyBase + RemQtyToCalcBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / QtyShippedNotInvcdBase * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              SalesLine."Shipment No." <> '':
                begin
                  PostedQtyBase := PostedQtyBase + QtyShippedNotInvcdBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / "Quantity (Base)" * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              else begin
                PostedQtyBase := PostedQtyBase + "Quantity (Base)";
                TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
              end;
            end;
          until (NEXT = 0) or (RemQtyToCalcBase = 0);
      end;
    END;

    LOCAL PROCEDURE CalcSalesLineRcptAdjCostLCY@37(SalesLine@1002 : Record "Sales Line";QtyType@1001 : 'General,Invoicing';VAR TotalAdjCostLCY@1000 : Decimal;VAR PostedQtyBase@1004 : Decimal;VAR RemQtyToCalcBase@1003 : Decimal);
    VAR
      ReturnRcptLine@1005 : Record "Return Receipt Line";
      RtrnQtyRcvdNotInvcdBase@1006 : Decimal;
      AdjCostLCY@1007 : Decimal;
    BEGIN
      with ReturnRcptLine do begin
        if SalesLine."Return Receipt No." <> '' then begin
          SETRANGE("Document No.",SalesLine."Return Receipt No.");
          SETRANGE("Line No.",SalesLine."Return Receipt Line No.");
        end else begin
          SETCURRENTKEY("Return Order No.","Return Order Line No.");
          SETRANGE("Return Order No.",SalesLine."Document No.");
          SETRANGE("Return Order Line No.",SalesLine."Line No.");
        end;
        SETRANGE(Correction,false);
        if QtyType = QtyType::Invoicing then begin
          SETFILTER("Return Qty. Rcd. Not Invd.",'<>0');
          RemQtyToCalcBase :=
            SalesLine."Qty. to Invoice (Base)" - SalesLine."Return Qty. to Receive (Base)";
        end else
          RemQtyToCalcBase := SalesLine."Quantity (Base)";

        if FINDSET then
          repeat
            if "Qty. per Unit of Measure" = 0 then
              RtrnQtyRcvdNotInvcdBase := "Return Qty. Rcd. Not Invd."
            else
              RtrnQtyRcvdNotInvcdBase :=
                ROUND("Return Qty. Rcd. Not Invd." * "Qty. per Unit of Measure",0.00001);

            AdjCostLCY := CalcReturnRcptLineCostLCY(ReturnRcptLine,QtyType);

            case true of
              QtyType = QtyType::Invoicing:
                if RemQtyToCalcBase > RtrnQtyRcvdNotInvcdBase then begin
                  TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
                  RemQtyToCalcBase := RemQtyToCalcBase - RtrnQtyRcvdNotInvcdBase;
                  PostedQtyBase := PostedQtyBase + RtrnQtyRcvdNotInvcdBase;
                end else begin
                  PostedQtyBase := PostedQtyBase + RemQtyToCalcBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / RtrnQtyRcvdNotInvcdBase * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              SalesLine."Return Receipt No." <> '':
                begin
                  PostedQtyBase := PostedQtyBase + RtrnQtyRcvdNotInvcdBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / "Quantity (Base)" * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              else begin
                PostedQtyBase := PostedQtyBase + "Quantity (Base)";
                TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
              end;
            end;
          until (NEXT = 0) or (RemQtyToCalcBase = 0);
      end;
    END;

    LOCAL PROCEDURE CalcSalesShptLineCostLCY@31(SalesShptLine@1000 : Record "Sales Shipment Line";QtyType@1003 : 'General,Invoicing,Shipping') AdjCostLCY : Decimal;
    VAR
      ItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with SalesShptLine do begin
        if (Quantity = 0) or (Type = Type::"Charge (Item)") then
          exit(0);

        if Type = Type::Item then begin
          FilterPstdDocLnItemLedgEntries(ItemLedgEntry);
          if ItemLedgEntry.ISEMPTY then
            exit(0);
          AdjCostLCY := CalcPostedDocLineCostLCY(ItemLedgEntry,QtyType);
        end else begin
          if QtyType = QtyType::Invoicing then
            AdjCostLCY := -"Qty. Shipped Not Invoiced" * "Unit Cost (LCY)"
          else
            AdjCostLCY := -Quantity * "Unit Cost (LCY)";
        end;
      end;
    END;

    LOCAL PROCEDURE CalcReturnRcptLineCostLCY@33(ReturnRcptLine@1000 : Record "Return Receipt Line";QtyType@1003 : 'General,Invoicing,Shipping') AdjCostLCY : Decimal;
    VAR
      ItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with ReturnRcptLine do begin
        if (Quantity = 0) or (Type = Type::"Charge (Item)") then
          exit(0);

        if Type = Type::Item then begin
          FilterPstdDocLnItemLedgEntries(ItemLedgEntry);
          if ItemLedgEntry.ISEMPTY then
            exit(0);
          AdjCostLCY := CalcPostedDocLineCostLCY(ItemLedgEntry,QtyType);
        end else begin
          if QtyType = QtyType::Invoicing then
            AdjCostLCY := "Return Qty. Rcd. Not Invd." * "Unit Cost (LCY)"
          else
            AdjCostLCY := Quantity * "Unit Cost (LCY)";
        end;
      end;
    END;

    LOCAL PROCEDURE CalcPostedDocLineCostLCY@36(VAR ItemLedgEntry@1000 : Record "Item Ledger Entry";QtyType@1002 : 'General,Invoicing,Shipping,Consuming') AdjCostLCY : Decimal;
    VAR
      ValueEntry@1003 : Record "Value Entry";
    BEGIN
      with ItemLedgEntry do begin
        FINDSET;
        repeat
          if (QtyType = QtyType::Invoicing) or (QtyType = QtyType::Consuming) then begin
            CALCFIELDS("Cost Amount (Expected)");
            AdjCostLCY := AdjCostLCY + "Cost Amount (Expected)";
          end else begin
            ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
            ValueEntry.SETRANGE("Item Ledger Entry No.","Entry No.");
            if ValueEntry.FINDSET then
              repeat
                if (ValueEntry."Entry Type" <> ValueEntry."Entry Type"::Revaluation) and
                   (ValueEntry."Item Charge No." = '')
                then
                  AdjCostLCY :=
                    AdjCostLCY + ValueEntry."Cost Amount (Expected)" + ValueEntry."Cost Amount (Actual)";
              until ValueEntry.NEXT = 0;
          end;
        until NEXT = 0;
      end;
    END;

    [External]
    PROCEDURE CalcSalesInvLineCostLCY@23(SalesInvLine@1000 : Record "Sales Invoice Line") AdjCostLCY : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with SalesInvLine do begin
        if Quantity = 0 then
          exit(0);

        if Type in [Type::Item,Type::"Charge (Item)"] then begin
          FilterPstdDocLineValueEntries(ValueEntry);
          AdjCostLCY := -SumValueEntriesCostAmt(ValueEntry);
        end else
          AdjCostLCY := Quantity * "Unit Cost (LCY)";
      end;
    END;

    [External]
    PROCEDURE CalcSalesCrMemoLineCostLCY@81(SalesCrMemoLine@1002 : Record "Sales Cr.Memo Line") AdjCostLCY : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with SalesCrMemoLine do begin
        if Quantity = 0 then
          exit(0);

        if Type in [Type::Item,Type::"Charge (Item)"] then begin
          FilterPstdDocLineValueEntries(ValueEntry);
          AdjCostLCY := SumValueEntriesCostAmt(ValueEntry);
        end else
          AdjCostLCY := Quantity * "Unit Cost (LCY)";
      end;
    END;

    [External]
    PROCEDURE CalcServCrMemoLineCostLCY@41(ServCrMemoLine@1002 : Record "Service Cr.Memo Line") AdjCostLCY : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with ServCrMemoLine do begin
        if Quantity = 0 then
          exit(0);

        if Type = Type::Item then begin
          FilterPstdDocLineValueEntries(ValueEntry);
          AdjCostLCY := SumValueEntriesCostAmt(ValueEntry);
        end else
          AdjCostLCY := Quantity * "Unit Cost (LCY)";
      end;
    END;

    [External]
    PROCEDURE CalcCustLedgAdjmtCostLCY@28(CustLedgEntry@1000 : Record "Cust. Ledger Entry") : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with CustLedgEntry do begin
        if not ("Document Type" in ["Document Type"::Invoice,"Document Type"::"Credit Memo"]) then
          FIELDERROR("Document Type");

        ValueEntry.SETCURRENTKEY("Document No.");
        ValueEntry.SETRANGE("Document No.","Document No.");
        if "Document Type" = "Document Type"::Invoice then
          ValueEntry.SETFILTER(
            "Document Type",
            '%1|%2',
            ValueEntry."Document Type"::"Sales Invoice",ValueEntry."Document Type"::"Service Invoice")
        else
          ValueEntry.SETFILTER(
            "Document Type",
            '%1|%2',
            ValueEntry."Document Type"::"Sales Credit Memo",ValueEntry."Document Type"::"Service Credit Memo");
        ValueEntry.SETRANGE(Adjustment,true);
        exit(SumValueEntriesCostAmt(ValueEntry));
      end;
    END;

    [External]
    PROCEDURE CalcCustAdjmtCostLCY@27(VAR Customer@1000 : Record Customer) : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with ValueEntry do begin
        SETCURRENTKEY("Source Type","Source No.");
        SETRANGE("Source Type","Source Type"::Customer);
        SETRANGE("Source No.",Customer."No.");
        SETFILTER("Posting Date",Customer.GETFILTER("Date Filter"));
        SETFILTER("Global Dimension 1 Code",Customer.GETFILTER("Global Dimension 1 Filter"));
        SETFILTER("Global Dimension 2 Code",Customer.GETFILTER("Global Dimension 2 Filter"));
        SETRANGE(Adjustment,true);

        CALCSUMS("Cost Amount (Actual)");
        exit("Cost Amount (Actual)");
      end;
    END;

    [External]
    PROCEDURE CalcCustLedgActualCostLCY@128(CustLedgEntry@1000 : Record "Cust. Ledger Entry") : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with CustLedgEntry do begin
        if not ("Document Type" in ["Document Type"::Invoice,"Document Type"::"Credit Memo"]) then
          FIELDERROR("Document Type");

        ValueEntry.SETCURRENTKEY("Document No.");
        ValueEntry.SETRANGE("Document No.","Document No.");
        if "Document Type" = "Document Type"::Invoice then
          ValueEntry.SETFILTER(
            "Document Type",
            '%1|%2',
            ValueEntry."Document Type"::"Sales Invoice",ValueEntry."Document Type"::"Service Invoice")
        else
          ValueEntry.SETFILTER(
            "Document Type",
            '%1|%2',
            ValueEntry."Document Type"::"Sales Credit Memo",ValueEntry."Document Type"::"Service Credit Memo");
        ValueEntry.SETFILTER("Entry Type",'<> %1',ValueEntry."Entry Type"::Revaluation);
        exit(SumValueEntriesCostAmt(ValueEntry));
      end;
    END;

    [External]
    PROCEDURE CalcCustActualCostLCY@127(VAR Customer@1000 : Record Customer) CostAmt : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
      ResLedgerEntry@1002 : Record "Res. Ledger Entry";
    BEGIN
      with ValueEntry do begin
        SETRANGE("Source Type","Source Type"::Customer);
        SETRANGE("Source No.",Customer."No.");
        SETFILTER("Posting Date",Customer.GETFILTER("Date Filter"));
        SETFILTER("Global Dimension 1 Code",Customer.GETFILTER("Global Dimension 1 Filter"));
        SETFILTER("Global Dimension 2 Code",Customer.GETFILTER("Global Dimension 2 Filter"));
        SETFILTER("Entry Type",'<> %1',"Entry Type"::Revaluation);
        CALCSUMS("Cost Amount (Actual)");
        CostAmt := "Cost Amount (Actual)";
      end;

      with ResLedgerEntry do begin
        SETRANGE("Source Type","Source Type"::Customer);
        SETRANGE("Source No.",Customer."No.");
        SETFILTER("Posting Date",Customer.GETFILTER("Date Filter"));
        SETFILTER("Global Dimension 1 Code",Customer.GETFILTER("Global Dimension 1 Filter"));
        SETFILTER("Global Dimension 2 Code",Customer.GETFILTER("Global Dimension 2 Filter"));
        CALCSUMS("Total Cost");
        CostAmt += "Total Cost";
      end;
    END;

    [External]
    PROCEDURE NonInvtblCostAmt@29(VAR Customer@1001 : Record Customer) : Decimal;
    VAR
      ValueEntry@1002 : Record "Value Entry";
    BEGIN
      with ValueEntry do begin
        SETRANGE("Source Type","Source Type"::Customer);
        SETRANGE("Source No.",Customer."No.");
        SETFILTER("Posting Date",Customer.GETFILTER("Date Filter"));
        SETFILTER("Global Dimension 1 Code",Customer.GETFILTER("Global Dimension 1 Filter"));
        SETFILTER("Global Dimension 2 Code",Customer.GETFILTER("Global Dimension 2 Filter"));
        CALCSUMS("Cost Amount (Non-Invtbl.)");
        exit("Cost Amount (Non-Invtbl.)");
      end;
    END;

    [External]
    PROCEDURE SumValueEntriesCostAmt@30(VAR ValueEntry@1000 : Record "Value Entry") CostAmt : Decimal;
    BEGIN
      with ValueEntry do
        if FINDSET then
          repeat
            CostAmt := CostAmt + "Cost Amount (Actual)";
          until NEXT = 0;
      exit(CostAmt);
    END;

    [External]
    PROCEDURE GetDocType@26(TableNo@1000 : Integer) : Integer;
    VAR
      ItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with ItemLedgEntry do
        case TableNo of
          DATABASE::"Purch. Rcpt. Header":
            exit("Document Type"::"Purchase Receipt");
          DATABASE::"Purch. Inv. Header":
            exit("Document Type"::"Purchase Invoice");
          DATABASE::"Purch. Cr. Memo Hdr.":
            exit("Document Type"::"Purchase Credit Memo");
          DATABASE::"Return Shipment Header":
            exit("Document Type"::"Purchase Return Shipment");
          DATABASE::"Sales Shipment Header":
            exit("Document Type"::"Sales Shipment");
          DATABASE::"Sales Invoice Header":
            exit("Document Type"::"Sales Invoice");
          DATABASE::"Sales Cr.Memo Header":
            exit("Document Type"::"Sales Credit Memo");
          DATABASE::"Return Receipt Header":
            exit("Document Type"::"Sales Return Receipt");
          DATABASE::"Transfer Shipment Header":
            exit("Document Type"::"Transfer Shipment");
          DATABASE::"Transfer Receipt Header":
            exit("Document Type"::"Transfer Receipt");
          DATABASE::"Posted Assembly Header":
            exit("Document Type"::"Posted Assembly");
        end;
    END;

    [External]
    PROCEDURE CalcServLineCostLCY@39(ServLine@1000 : Record "Service Line";QtyType@1005 : 'General,Invoicing,Shipping,Consuming,ServLineItems,ServLineResources,ServLineCosts') TotalAdjCostLCY : Decimal;
    VAR
      PostedQtyBase@1001 : Decimal;
      RemQtyToCalcBase@1006 : Decimal;
    BEGIN
      case ServLine."Document Type" of
        ServLine."Document Type"::Order,ServLine."Document Type"::Invoice:
          if ((ServLine."Quantity Shipped" <> 0) or (ServLine."Shipment No." <> '')) and
             ((QtyType = QtyType::General) or
              (QtyType = QtyType::ServLineItems) or
              (QtyType = QtyType::ServLineResources) or
              (QtyType = QtyType::ServLineCosts) or
              (ServLine."Qty. to Invoice" > ServLine."Qty. to Ship") or
              (ServLine."Qty. to Consume" > 0))
          then
            CalcServLineShptAdjCostLCY(ServLine,QtyType,TotalAdjCostLCY,PostedQtyBase,RemQtyToCalcBase);
      end;
    END;

    LOCAL PROCEDURE CalcServLineShptAdjCostLCY@38(ServLine@1002 : Record "Service Line";QtyType@1001 : 'General,Invoicing,Shipping,Consuming';VAR TotalAdjCostLCY@1000 : Decimal;VAR PostedQtyBase@1004 : Decimal;VAR RemQtyToCalcBase@1003 : Decimal);
    VAR
      ServShptLine@1005 : Record "Service Shipment Line";
      QtyShippedNotInvcdBase@1006 : Decimal;
      AdjCostLCY@1007 : Decimal;
    BEGIN
      with ServShptLine do begin
        if ServLine."Shipment No." <> '' then begin
          SETRANGE("Document No.",ServLine."Shipment No.");
          SETRANGE("Line No.",ServLine."Shipment Line No.");
        end else begin
          SETCURRENTKEY("Order No.","Order Line No.");
          SETRANGE("Order No.",ServLine."Document No.");
          SETRANGE("Order Line No.",ServLine."Line No.");
        end;
        SETRANGE(Correction,false);
        if QtyType = QtyType::Invoicing then begin
          SETFILTER("Qty. Shipped Not Invoiced",'<>0');
          RemQtyToCalcBase := ServLine."Qty. to Invoice (Base)" - ServLine."Qty. to Ship (Base)";
        end else
          if (QtyType = QtyType::Consuming) and (ServLine."Qty. to Consume" > 0) then
            RemQtyToCalcBase := ServLine."Qty. to Consume (Base)"
          else
            RemQtyToCalcBase := ServLine."Quantity (Base)";

        if FINDSET then
          repeat
            if "Qty. per Unit of Measure" = 0 then
              QtyShippedNotInvcdBase := "Qty. Shipped Not Invoiced"
            else
              QtyShippedNotInvcdBase :=
                ROUND("Qty. Shipped Not Invoiced" * "Qty. per Unit of Measure",0.00001);

            AdjCostLCY := CalcServShptLineCostLCY(ServShptLine,QtyType);

            case true of
              QtyType = QtyType::Invoicing,QtyType = QtyType::Consuming:
                if RemQtyToCalcBase > QtyShippedNotInvcdBase then begin
                  TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
                  RemQtyToCalcBase := RemQtyToCalcBase - QtyShippedNotInvcdBase;
                  PostedQtyBase := PostedQtyBase + QtyShippedNotInvcdBase;
                end else begin
                  PostedQtyBase := PostedQtyBase + RemQtyToCalcBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / QtyShippedNotInvcdBase * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              ServLine."Shipment No." <> '':
                begin
                  PostedQtyBase := PostedQtyBase + QtyShippedNotInvcdBase;
                  TotalAdjCostLCY :=
                    TotalAdjCostLCY + AdjCostLCY / "Quantity (Base)" * RemQtyToCalcBase;
                  RemQtyToCalcBase := 0;
                end;
              else begin
                PostedQtyBase := PostedQtyBase + "Quantity (Base)";
                TotalAdjCostLCY := TotalAdjCostLCY + AdjCostLCY;
              end;
            end;
          until (NEXT = 0) or (RemQtyToCalcBase = 0);
      end;
    END;

    LOCAL PROCEDURE CalcServShptLineCostLCY@50(ServShptLine@1000 : Record "Service Shipment Line";QtyType@1003 : 'General,Invoicing,Shipping,Consuming') AdjCostLCY : Decimal;
    VAR
      ItemLedgEntry@1001 : Record "Item Ledger Entry";
    BEGIN
      with ServShptLine do begin
        if Quantity = 0 then
          exit(0);

        if Type = Type::Item then begin
          FilterPstdDocLnItemLedgEntries(ItemLedgEntry);
          if ItemLedgEntry.ISEMPTY then
            exit(0);
          AdjCostLCY := CalcPostedDocLineCostLCY(ItemLedgEntry,QtyType);
        end else begin
          if QtyType = QtyType::Invoicing then
            AdjCostLCY := -"Qty. Shipped Not Invoiced" * "Unit Cost (LCY)"
          else
            AdjCostLCY := -Quantity * "Unit Cost (LCY)";
        end;
      end;
    END;

    [External]
    PROCEDURE CalcServInvLineCostLCY@40(ServInvLine@1000 : Record "Service Invoice Line") AdjCostLCY : Decimal;
    VAR
      ValueEntry@1001 : Record "Value Entry";
    BEGIN
      with ServInvLine do begin
        if Quantity = 0 then
          exit(0);

        if Type = Type::Item then begin
          FilterPstdDocLineValueEntries(ValueEntry);
          AdjCostLCY := -SumValueEntriesCostAmt(ValueEntry);
        end else
          AdjCostLCY := Quantity * "Unit Cost (LCY)";
      end;
    END;

    [External]
    PROCEDURE AdjustForRevNegCon@42(VAR ActMatCost@1000 : Decimal;VAR ActMatCostCostACY@1001 : Decimal;VAR ItemLedgEntry@1002 : Record "Item Ledger Entry");
    VAR
      ValueEntry@1003 : Record "Value Entry";
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      ItemLedgEntry.SETRANGE(Positive,true);
      if ItemLedgEntry.FINDSET then
        repeat
          ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntry."Entry No.");
          ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Revaluation);
          if ValueEntry.FINDSET then
            repeat
              ActMatCost += ValueEntry."Cost Amount (Actual)";
              ActMatCostCostACY += ValueEntry."Cost Amount (Actual) (ACY)";
            until ValueEntry.NEXT = 0;
        until ItemLedgEntry.NEXT = 0;
    END;

    BEGIN
    END.
  }
}

